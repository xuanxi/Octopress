<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Steven Chan]]></title>
  <link href="http://xuanxi.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-09-26T15:16:51+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/07/reading-android-manual/"/>
    <updated>2014-09-07T15:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/07/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出具有良好用户体验的产品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style-1/">Android Style (1)</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/07/29/android-style-2/">Android Style (2)</a><br/>
设计风格，主要是视觉方面。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns-1/">Android Patterns (1)</a><br/>
设计模式，主要是交互方面。</p>

<p><em>注：由于最近找到了 Android Design 的较好的<a href="http://adchs.github.io/">翻译版本</a>，Design 的内容我就直接在那里学习了，这里不再重复翻译：）</em></p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
样式与主题</p>

<p><a href="http://blog.xuanxi.me/blog/2014/08/23/android-processes-and-threads/">Processes and Threads</a><br/>
进程与线程</p>

<p>Service 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/08/26/android-services/">Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-bound-services/">Bound Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-aidl/">AIDL</a></p>

<p>Activity 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-fragments/">Fragments</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-loaders/">Loaders</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-tasks-and-back-stack/">Tasks and Back Stack</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Tasks and Back Stack]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-tasks-and-back-stack/"/>
    <updated>2014-09-02T12:10:18+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-tasks-and-back-stack</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">http://developer.android.com/guide/components/tasks-and-back-stack.html</a></p>

<p>一个应用通常会包含多个 Activity，每个 Activity 完成特定的工作，并可以启动其它 Activity。比如，邮件应用使用一个 Activity 来展示邮件列表，点击一封邮件将会打开一个新的 Activity 来展示邮件内容。</p>

<p>一个 Activity 甚至可以打开其它应用的 Activity。比如，你的应用要发送邮件，你可以定义一个 Intent 来启动设备中支持这个 Intent 的邮件应用，并进入到该应用的邮件编辑页面（如果设备中有多个邮件应用，系统会以列表形式让你选择启动哪一个），当邮件发送成功后，会退回到你的应用界面，整个流程看起来，发送邮件的界面就像是你的应用界面的一部分。由此可见，尽管打开的 Activity 可能来自不同的应用，但系统会将所有 Activity 放到同一个 Task 里，以实现无缝的用户体验。本文介绍 Android 如何通过 Task 和 Back Stack 来管理 Activity。</p>

<!--more-->


<p>一个 Task 是许多 Activity 的集合，这些 Activity 连在一起表示用户对某项事务的一个完整的交互过程，这些 Activity 同时受 Back Stack 的管理，所有 Activity 以打开的顺序排列在 Back Stack 中。一个 Task 对应一个 Back Stack。（准确来说，应该是用户的整个交互对应一个 Back Stack，因为交互过程中可能会产生新的 Task，下文会讲到。）</p>

<p>大多数 Task 由 Home 界面开始，当用户在 Launcher（应用启动器）或 Home 点击应用图标，该应用的 Task 将会进入前台。在启动应用时，如果该应用的 Task 不存在（即最近没有使用过，因为如果最近使用过，通常会存在后台 Task），系统会为应用创建一个新的 Task，并以起始 Activity（通常是 main Activity）作为 Back Stack 的第一个 Activity。</p>

<p>如果从当前 Activity 启动另一个 Activity，新的 Activity 将被置于 Task 栈顶，同时获得界面焦点，而前一个 Activity 仍会保留在栈里，并处于 stopped 状态。当用户点击返回按键，新的 Activity 会出栈（被销毁），而前一个 Activity 恢复。由此可见，Back stack 其实就是一个“后进先出”的结构。</p>

<p><img src="/images/diagram_backstack.png" alt="diagram_backstack" /></p>

<p>如果用户继续点击返回按键，栈中的所有 Activity 都被弹出，直到返回 Home（或者 Task 启动前正在运行的 Activity），同时，这个 Task 不再存在。</p>

<p>每个 Task 都是独立的单元，当一个新的 Task 被启动，或者用户按 Home 键返回 Home 界面，前一个 Task 将会退到后台（看不见了），Task 中的所有 Activity 都会处于 stopped 的状态，不过，Task 的 Back Stack 仍然保持不变，当它重新回到前台时，界面将会显示 Task 中最顶端的 Activity。</p>

<p><img src="/images/diagram_multitasking.png" alt="diagram_multitasking" /></p>

<p>注意：<br/>
后台可以存在多个 Task，不过，如果后台 Task 过多，系统可能会销毁一些以腾出内存空间，被销毁 Task 中的 Activity 的状态都会丢失。</p>

<p>如果一个 Activity 可以被应用中的多个 Activity 启动，默认情况下，每次启动都会创建一个该 Activity 的实例，并新实例放在栈顶。如下图所示：</p>

<p><img src="/images/diagram_multiple_instances.png" alt="diagram_multiple_instances" /></p>

<p>这里做一下总结：</p>

<p>（1）当 Activity A 启动 Activity B，A stopped，但系统会保存 A 的状态（比如滑动的位置和输入的信息）。当用户按返回按键从 B 返回，A 就会以上一次的状态复原。</p>

<p>（2）当用户通过 Home 键离开一个 Task（离开应用），当前的 Activity stopped，Task 也随之进入后台，但系统会保存 Task 中所有 Activity 的状态。当用户稍后通过 Launcher 图标再次打开应用时，Task 就回到前台，并显示栈顶的 Activity 及复原离开时的状态。</p>

<p>（3）如果用户点击返回按键，当前 Activity 弹出栈并被销毁，上一个 Activity 恢复显示。系统不会保存被销毁的 Activity 的状态。</p>

<p>（4）Activity 可以被多次实例化，甚至从其它的 Task 实例化。</p>

<h2>Saving Activity State</h2>

<p>就如上面所讨论的，在 Activity stopped 的时候，系统会保存 Activity 的状态，这样，当用户返回时，界面显示会跟离开时一样。但是，在 Activity destroyed 的时候，你可以，或者说应该使用  Activity 提供回调方法 onSaveInstanceState() 保存当前状态。</p>

<p>补充：开发者用 onSaveInstanceState() 保存的状态通常是业务相关的，比如视频或音乐的播放进度。</p>

<h2>Managing Tasks</h2>

<p>上面讨论的 Android 管理 Task 和 Back Stack 的方式适合大多数使用场景，你不需要关心一个 Activity 的入栈出栈。可是，如果你希望打破常规，比如你希望在一个新的 Task 中打开 Activity，而不是放到当前 Task 的栈顶；或者希望可以重用 Task 中已经存在的 Activity 实例，而不是再次创建新的实例；又或者希望在离开 Task 时可以保留 root Activity 等等。你可以通过设置 manifest 文件中的  <code>&lt;activity&gt;</code> 元素，或者为 startActivity() 方法的参数 Intent 设置 flag，来实现多种 Task 管理。</p>

<p>例如，<code>&lt;activity&gt;</code> 元素可设置的属性有：<br/>
taskAffinity<br/>
launchMode<br/>
allowTaskReparenting<br/>
clearTaskOnLaunch<br/>
alwaysRetainTaskState<br/>
finishOnTaskLaunch</p>

<p>以及可以设置的 intent flags 值有：<br/>
FLAG_ACTIVITY_NEW_TASK<br/>
FLAG_ACTIVITY_CLEAR_TOP<br/>
FLAG_ACTIVITY_SINGLE_TOP</p>

<p>下面的内容将会详细讲解如何使用这些设置。</p>

<h3>Defining launch modes</h3>

<p>launch modes（运行模式）用来描述一个新的 Activity 实例和当前 Task 的关系，有两种方式定义 launch modes：</p>

<p>使用 manifest 文件<br/>
使用 Intent flags</p>

<p>比如 Activity A starts Activity B，B 可以在 manifest 中设置 launch mode 的同时，A 也可以设置 Intent flag。在 A 和 B 都设置的情况下，A 的设置会覆盖 B 的设置。</p>

<p>注意：某些 launch modes 可以用在 manifest 上但不能用在 Intent flag 上；同样，某些 launch modes 可以用在 Intent flag 上但不能用在 manifest 上。</p>

<h4>（1）Using the manifest file</h4>

<p>设置 <code>&lt;activity&gt;</code> 元素的 launchMode 属性，有四种 launchMode：</p>

<p>&ldquo;standard&rdquo; (默认模式)<br/>
系统会在当前的 Task 中创建 Activity 的新实例。Activity 可以被多次实例化，这些实例可以存在于一个 Task 中，或者分布在不同的 Task 中（Android 的组件机制，其它的应用可以使用你的 Activity）。</p>

<p>&ldquo;singleTop&rdquo;  <br/>
当一个 Activity 实例位于栈顶的时候，再通过 Intent 跳转到本身这个 Activity，将不会创建一个新的实例压入栈中（不会调用 onCreate()，而调用 onNewIntent()）。例如：现在栈的情况为：A B C D。D 的 Launch mode 设置成了 singleTop，那么在 D 中启动 Intent 跳转到 D，那么将不会新创建一个 D 的实例压入栈中，此时栈的情况依然为：A B C D。但是如果此时  B 的模式也是 singleTop，D 跳转到 B，则会新建一个 B 的实例压入栈，因为此时 B 不位于栈顶，此时栈的情况就变成了：A B C D B。</p>

<p>&ldquo;singleTask"<br/>
系统所有 Task 中只会存在一个该 Activity 实例（不管当前 Task 还是其它 Task）。另外，singleTask 模式的 Activity 不管是位于栈顶还是栈底，再次运行这个 Activity 时，都会 destory 掉它上面的 Activity 来保证整个栈中只有一个自己。<br/>
注意：即使在新的 Task 中打开 Activity，当返回的时候，仍然会回到前一个 Task 的栈顶 Activity，这里是 Back Stack 所起的作用。</p>

<p>如果 singleTask 的 Activity 存在于一个已有的后台 Task 中，打开这个 Activity 时会将整个后台 Task 装入当前的 Back Task 中。<br/>
<img src="/images/diagram_backstack_singletask_multiactivity.png" alt="diagram_backstack_singletask_multiactivity" /></p>

<p>&ldquo;singleInstance"<br/>
与 singleTask 相似，不过，该模式的 Activity 所在的栈中只有它自己一个 Activity。</p>

<h4>（2）Using Intent flags</h4>

<p>FLAG_ACTIVITY_NEW_TASK<br/>
同"singleTask"，注意如果要打开的 Activity 已存在，会调用 onNewIntent() 方法而不是 onCreate().</p>

<p>FLAG_ACTIVITY_SINGLE_TOP<br/>
同"singleTop"</p>

<p>FLAG_ACTIVITY_CLEAR_TOP<br/>
如果要打开的 Activity 已存在于当前 Task，就会销毁该 Activity 之上的 Activity。该标识通常和 FLAG_ACTIVITY_NEW_TASK 一起使用，
launchMode 属性中无此功能选项。</p>

<h3>Handling affinities</h3>

<h3>Clearing the back stack</h3>

<h3>Starting a task</h3>

<p>将一个 Activity 配置为 Task 的起始 Activity：
```
<activity ... ></p>

<pre><code>&lt;intent-filter ... &gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
...
</code></pre>

<p></activity>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Loaders]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-loaders/"/>
    <updated>2014-09-02T12:09:14+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-loaders</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/loaders.html">http://developer.android.com/guide/components/loaders.html</a></p>

<p>Loader 在 Android 3.0 版本被引入，它使得在 Activity 或 Fragment 中异步加载数据变得简单。Loader 有以下特性：<br/>
1. 在所有 Activity 和 Fragment 中都可用；<br/>
2. 异步加载数据；<br/>
3. 它会监控数据的变动，并在变动时传送新的数据；
4. 当由于配置改变而被重新创建后，它们自动重连到上一个 Loader 的游标，所以不必重新查询数据。</p>

<p>关键类：<br/>
LoaderManager<br/>
Loader</p>

<!--more-->


<h2>1. Loader API Summary</h2>

<p>使用 Loader 会涉及到几个类和接口，下面做一下介绍：</p>

<p>（1）LoaderManager</p>

<p>抽象类，用在 Activity 或 Fragment 里管理 Loader 实例。通常与 CursorLoader 结合使用，也可以定义自己的 Loader。每个 Activity 或 Fragment 只能有一个 LoaderManager 实例，但一个 LoaderManager 可以持有多个 Loader。</p>

<p>（2）LoaderManager.LoaderCallbacks</p>

<p>一个用于客户端（即用户界面）与 LoaderManager 交互的回调接口。例如，你使用回调方法 onCreateLoader() 来创建一个新的 Loader。</p>

<p>（3）Loader</p>

<p>抽象类，用来执行异步数据加载操作。它是具体 Loader 的基类。一般情况下使用 CursorLoader，但是你也可以实现你自己的子类。一旦 Loader 被激活，它们将监视它们的数据源并且在数据改变时发送新的结果。</p>

<p>（4）AsyncTaskLoader</p>

<p>抽象类，类似 AsyncTask。</p>

<p>（5）CursorLoader
AsyncTaskLoader 的子类，它查询 ContentResolver 然后返回一个 Cursor。它实现了 Loader 协议，可以在后台查询 Cursor 而不阻塞 UI。</p>

<p>上面所列的类和接口是实现 Loader 的基础组件，你的每个 Loader 实现并不一定需要所有的组件，但至少要有一个 LoaderManager 和一个具体的 Loader（如 CursorLoader）。</p>

<h2>2. Using Loaders in an Application</h2>

<p>This section describes how to use loaders in an Android application. An application that uses loaders typically includes the following:</p>

<p>使用 Loader 通常要包含以下内容：</p>

<p>（1）一个 Activity 或 Fragment；<br/>
（2）一个 LoaderManager 实例；<br/>
（3）一个 CursorLoader 实例，对应 ContentProvider 数据源；<br/>
（4）实现 LoaderManager.LoaderCallbacks；<br/>
（5）实现显示数据的方式，如 SimpleCursorAdapter；<br/>
（6）数据源，如 ContentProvider。</p>

<h3>Starting a Loader</h3>

<p>在 Activity 的 onCreate() 方法或 Fragment 的 onActivityCreated() 方法中初始化一个 Loader：
<code>
// Prepare the loader.  Either re-connect with an existing one,
// or start a new one.
getLoaderManager().initLoader(0, null, this);
</code>
initLoader() 方法有以下参数：</p>

<p>（1）代表这个 Loader 的唯一 ID。<br/>
（2）Optional arguments to supply to the loader at construction (null in this example).<br/>
（3）LoaderManager.LoaderCallbacks 的实现。</p>

<p>对 initLoader() 的调用可以确保一个 Loadder 实例被初始化并处于活动状态。它可能有两种结果：</p>

<p>（1）如果该 ID 的 Loader 实例已经存在，则重用最后一个创建的 Loader。（不是对应 ID 的 Loader 哦）<br/>
（2）如果不存在，就响应 LoaderManager.LoaderCallbacks 接口中的 onCreateLoader() 方法。</p>

<p>initLoader() 方法会返回被创建好的 Loader 的实例，但我们不需要获取它，因为 LoaderManager 会管理好它的生命周期，你基本上不用直接和 Loader 打交道，你的主要工作是处理好 LoaderManager.LoaderCallbacks 的接口。</p>

<h3>Restarting a Loader</h3>

<h3>Using the LoaderManager Callbacks</h3>

<h2>3. Example</h2>

<p>```
public static class CursorLoaderListFragment extends ListFragment</p>

<pre><code>    implements OnQueryTextListener, LoaderManager.LoaderCallbacks&lt;Cursor&gt; {

// This is the Adapter being used to display the list's data.
SimpleCursorAdapter mAdapter;

// If non-null, this is the current filter the user has provided.
String mCurFilter;

@Override public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);

    // Give some text to display if there is no data.  In a real
    // application this would come from a resource.
    setEmptyText("No phone numbers");

    // We have a menu item to show in action bar.
    setHasOptionsMenu(true);

    // Create an empty adapter we will use to display the loaded data.
    mAdapter = new SimpleCursorAdapter(getActivity(),
            android.R.layout.simple_list_item_2, null,
            new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS },
            new int[] { android.R.id.text1, android.R.id.text2 }, 0);
    setListAdapter(mAdapter);

    // Prepare the loader.  Either re-connect with an existing one,
    // or start a new one.
    getLoaderManager().initLoader(0, null, this);
}

@Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    // Place an action bar item for searching.
    MenuItem item = menu.add("Search");
    item.setIcon(android.R.drawable.ic_menu_search);
    item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
    SearchView sv = new SearchView(getActivity());
    sv.setOnQueryTextListener(this);
    item.setActionView(sv);
}

public boolean onQueryTextChange(String newText) {
    // Called when the action bar search text has changed.  Update
    // the search filter, and restart the loader to do a new query
    // with this filter.
    mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
    getLoaderManager().restartLoader(0, null, this);
    return true;
}

@Override public boolean onQueryTextSubmit(String query) {
    // Don't care about this.
    return true;
}

@Override public void onListItemClick(ListView l, View v, int position, long id) {
    // Insert desired behavior here.
    Log.i("FragmentComplexList", "Item clicked: " + id);
}

// These are the Contacts rows that we will retrieve.
static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
    Contacts._ID,
    Contacts.DISPLAY_NAME,
    Contacts.CONTACT_STATUS,
    Contacts.CONTACT_PRESENCE,
    Contacts.PHOTO_ID,
    Contacts.LOOKUP_KEY,
};
public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {
    // This is called when a new Loader needs to be created.  This
    // sample only has one Loader, so we don't care about the ID.
    // First, pick the base URI to use depending on whether we are
    // currently filtering.
    Uri baseUri;
    if (mCurFilter != null) {
        baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                Uri.encode(mCurFilter));
    } else {
        baseUri = Contacts.CONTENT_URI;
    }

    // Now create and return a CursorLoader that will take care of
    // creating a Cursor for the data being displayed.
    String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
            + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
            + Contacts.DISPLAY_NAME + " != '' ))";
    return new CursorLoader(getActivity(), baseUri,
            CONTACTS_SUMMARY_PROJECTION, select, null,
            Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
}

public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) {
    // Swap the new cursor in.  (The framework will take care of closing the
    // old cursor once we return.)
    mAdapter.swapCursor(data);
}

public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
    // This is called when the last Cursor provided to onLoadFinished()
    // above is about to be closed.  We need to make sure we are no
    // longer using it.
    mAdapter.swapCursor(null);
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Fragments]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-fragments/"/>
    <updated>2014-09-02T12:07:46+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-fragments</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/fragments.html">http://developer.android.com/guide/components/fragments.html</a></p>

<p>要点：<br/>
1. Design Philosophy（设计哲学）<br/>
2. Creating a Fragment（创建 Fragment） <br/>
3. Managing Fragments（管理 Fragment）<br/>
4. Performing Fragment Transactions（执行 Fragment 事务）<br/>
5. Communicating with the Activity（与 Activity 通信） <br/>
6. Handling the Fragment Lifecycle（维护 Fragment 生命周期）</p>

<p>关键类:<br/>
Fragment<br/>
FragmentManager<br/>
FragmentTransaction</p>

<!--more-->


<p>Fragment 是 Activity 界面的一部分，你可以在一个 Activity 中组合几个 Fragment 来构建 multi-pane 界面，并可以在其它 Activity 重用一个 Fragment。Fragment 有自己的生命周期，可以接收输入事件，可以在 Activity 运行期间被加入或移除（类似“子 Activity”）。</p>

<p>Fragment 必须内嵌到 Activity 里，它的生命周期受 Activity 生命周期的影响。例如 Activity paused，其中所有 Fragment 也 paused；Activity destroyed，其中所有 Fragment 也 destroyed。不过，当 Activity 在运行期间，你可以独立地操作 Fragment，比如加入或移除，而受 Activity 生命周期的影响。</p>

<p>你可以通过布局或代码加入一个 Fragment，也可以使用不带 UI 的 Fragment。</p>

<h2>1. Design Philosophy</h2>

<p>Android 在 3.0 版本引入 Fragment，主要为了支持在大屏幕（如平板）中创建动态和自适应的界面。通过将一个 Activity 布局划分为几个碎片（fragments），你就可以在应用运行期间动态改变界面，以及在一个 Activity 维护的返回栈（back stack）中保存这些变动。</p>

<p>下图展示了 Fragment 分别在平板和手机上的使用：
<img src="/images/fragments.png" alt="fragments" /></p>

<p>你应该将 Fragment 设计成一个标准化的可重用的组件，避免不同 Fragment 之间相互调用。当应用要同时支持手机和平板时，你可通过布局配置来重用 Fragment。</p>

<h2>2. Creating a Fragment</h2>

<p>要创建 Fragment，你必须创建一个 Fragment 类的子类（或者继承现成的 Fragment 子类）。Fragment 的代码看起来与 Activity 非常像，比如都包含以下生命周期方法：onCreate(), onStart(), onPause(), and onStop()。事实上，如果你将一个使用 Activity 的应用修改为使用 Fragment，你可能只需要将 Activity 生命周期方法中的代码复制到对应的 Fragment 生命周期方法中就行。</p>

<p><img src="/images/fragment_lifecycle.png" alt="fragment_lifecycle" /></p>

<p>一般地情况下，你至少需要实现以下生命周期方法：</p>

<p>（1）onCreate()<br/>
系统在创建 Fragment 的时候调用该方法。在这里初始化一些无论 paused 还是 stopped 状态都仍然要保留的数据。</p>

<p>（2）onCreateView()<br/>
系统在第一次绘制 Fragment 界面的时候调用该方法。为了绘制 Fragment 的 UI，此方法必须返回这个 Fragment 布局的根 View。如果不提供界面的话，也可以返回 null。</p>

<p>（3）onPause()<br/>
用户将要离开这个 Fragment 时，系统会首先调用该方法（然而它不总是意味着 Fragment 将被销毁）。通常你应该在这里保存用户的修改，因为用户有可能不会再回来。</p>

<p>大多数应用应当为每一个 Fragment 实现至少上述3个方法，你也可以使用其它的回调方法处理对应阶段的事情。全部的生命周期回调方法将会在后面的 Handlingthe Fragment Lifecycle 章节中讨论。</p>

<p>另外，Android 也提供了几个特定用途的 Fragment 供你继承使用：</p>

<p>DialogFragment<br/>
显示一个浮动对话框。相比普通的 AlertDialog，官方更推荐使用 DialogFragment，因为你可以将 DialogFragment 加入返回栈中，以便返回时再次显示它。</p>

<p>ListFragment<br/>
显示一个列表，与 ListActivity 类似，提供了相关的处理 ListView 的方法，如 onListItemClick()。</p>

<p>PreferenceFragment<br/>
显示列表形式的偏好设置，与 PreferenceActivity 类似，在创建“设置”界面的时候使用。</p>

<h3>Adding a user interface</h3>

<p>Fragment 通常被认为是 Activity 界面的一部分，它将自身布局加入到 Activity 中。要为 Fragment 提供布局，你必须实现 onCreateView() 回调方法，并返回布局的根。</p>

<p>注意：ListFragment 已经有默认的 onCreateView() 实现，并提供了 ListView，如下源码：
```
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,</p>

<pre><code>Bundle savedInstanceState) {
  return inflater.inflate(com.android.internal.R.layout.list_content,
            container, false);
</code></pre>

<p>}
```</p>

<p>onCreateView() 方法提供了 LayoutInflater 对象来加载布局。一个 Fragment 示例如下：
```
public static class ExampleFragment extends Fragment {</p>

<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                         Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    return inflater.inflate(R.layout.example_fragment, container, false);
}
</code></pre>

<p>}
```
另外，onCreateView() 中的 container 参数是 Activity 布局中用来插入 Fragment 布局的 ViewGroup。savedInstanceState 参数是上一次保存的状态（如果作了保存的话）。</p>

<p>inflate (int resource, ViewGroup root, boolean attachToRoot) 方法的参数说明如下：</p>

<p>resource：布局的 id。</p>

<p>root：布局的参考父 View，如果 attachToRoot 为 true，就将它作为布局的新 root 一并返回；如果 attachToRoot 为 false，就将它的 LayoutParams 参数应用到布局本来的 root。这里必须将 onCreateView() 提供的 container 传进来，以获得 container 的 LayoutParams 参数，并应用到 Fragment 布局的 root 上，以便 Fragment 布局可以正确地插入到 Activity 布局中。</p>

<p>attachToRoot：介绍如 root 参数所述。在 onCreateView() 中的情况是 false，因为系统已经实现将布局插入到 container 中，没必要把 container 重复加入到 Fragment 布局。</p>

<p>现在，你已经知道怎样定义一个 Fragment，下一节将介绍怎样将这个 Fragment 加入 Activity 中。</p>

<h3>Adding a fragment to an activity</h3>

<p>有两种方式将 Fragment 加入到 Activity 中：</p>

<p>（1）通过 <code>&lt;fragment&gt;</code> 标签</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:orientation="horizontal"
android:layout_width="match_parent"
android:layout_height="match_parent"&gt;
&lt;fragment android:name="com.example.news.ArticleListFragment"
        android:id="@+id/list"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="match_parent" /&gt;
&lt;fragment android:name="com.example.news.ArticleReaderFragment"
        android:id="@+id/viewer"
        android:layout_weight="2"
        android:layout_width="0dp"
        android:layout_height="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
<code>``
</code>android:name<code>属性指定了 Fragment 类。系统在创建这个 Activity 时，会依次调用 Fragment 的 onCreateView() 方法以获得 Fragment 的实际布局，然后将布局直接替换对应的</code><fragment>` 元素。</p>

<p>注意：需要为每个 Fragment 指定一个唯一标识，以便系统使用这个标识来做还原操作（在 Activity restarted 的时候），同时你也可能用这个标识来执行事务，比如删除 Fragment。有两种方式提供唯一标识：<br/>
android:id<br/>
android:tag</p>

<p>（2）通过代码</p>

<p>在 Activity 运行过程中，你随时可以加入一个 Fragment，仅需要指定一个父 ViewGroup。</p>

<p>要执行 Fragment 事务（比如加入、移除、替换），你必须使用 FragmentTransaction 中的接口：
<code>
FragmentManager fragmentManager = getFragmentManager()
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
</code>
然后你可以用 add() 方法加入一个 Fragment：
<code>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</code></p>

<p>add() 的第一个参数是父 ViewGroup，第二个参数是要加入的 Fragment。</p>

<p>一旦对 FragmentTransaction 作了改动，你必须调用 commit() 来提交改动。</p>

<h3>Adding a fragment without a UI</h3>

<p>上面的例子介绍了如何加入带界面的 Fragment，不过，你也可以使用不带界面的 Fragment 来处理后台任务。</p>

<p>要加入不带界面的 Fragment，使用 add(Fragment, String) 方法，第二个参数使用 “tag” 而不是 “id”。因为不带界面，所以不用重写 onCreateView()。</p>

<h2>3. Managing Fragments</h2>

<p>管理 Fragment 使用 FragmentManager，在 Activity 中通过 getFragmentManager() 获得 FragmentManager 对象。</p>

<p>在 FragmentManager 中可以做的事情是：</p>

<p>（1）获得 Fragment 对象。findFragmentById() 方法获得带界面的 Fragment；findFragmentByTag() 方法获得不带界面的 Fragment。</p>

<p>（2）从返回栈里弹出 Fragment。使用 popBackStack() 方法，模拟返回命令。</p>

<p>（3）为返回栈变动注册监听器。使用 addOnBackStackChangedListener() 方法。</p>

<p>更多信息请看 <a href="http://developer.android.com/reference/android/app/FragmentManager.html">FragmentManager</a>。</p>

<h2>4. Performing Fragment Transactions</h2>

<p>Fragment 的一个重要功能是可以灵活地响应用户交互，比如加入、移除或替换界面。一组动作称之为一个事务，你可以使用 FragmentTransaction 的接口来运行一个事务。你也可以将事务保存到由 Activity 管理的返回栈中，以便让用户按顺序返回。</p>

<p>你可以通过 FragmentManager 对象来获得 FragmentTransaction 实例：
<code>
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
</code>
之后通过 add()、remove() 或 replace() 方法来响应交互，最后调用 commit() 来提交。</p>

<p>不过，在你调用 commit() 之前，你可能需要调用 addToBackStack() 来使用返回栈，这样，在点击虚拟返回按键时，会返回到上一次的 Fragment 状态。</p>

<p>例如，下面的代码展示了如何用一个 Fragment 替换现有的 Fragment，并将状态保存到返回栈中：
```
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();</p>

<p>// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);</p>

<p>// Commit the transaction
transaction.commit();
```</p>

<h2>5. Communicating with the Activity</h2>

<p>虽然 Fragment 的实现是独立于 Activity 的，但在任何时候，一个实例化的 Fragment 都会与当前绑定的 Activity 相关，这样就涉及到与 Activity 通信的问题。</p>

<p>比如 Fragment 里可以通过 getActivity() 方法来访问 Activity：
<code>
View listView = getActivity().findViewById(R.id.list);
</code>
同样，Activity 也可以在 Fragment 里调用 findFragmentById() 或 findFragmentByTag() 来获得 Fragment 实例：
<code>
ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
</code></p>

<h3>Creating event callbacks to the activity</h3>

<p>某些情况下，你可能需要让 Activity 响应 Fragment 中的事件，一个好方法是，在 Fragment 中声明一个回调接口，在 Activity 中实现这个接口。</p>

<p>比如，一个新闻应用的 Activity 中有两个 Fragment，一个展示列表（A），一个展示详情（B），当 A 的列表项被点击，A 必须告诉 Activity 这个点击事件，并由 Activity 去通知 B 加载详情数据。这个例子中，A 定义了一个 OnArticleSelectedListener 接口：
```
public static class FragmentA extends ListFragment {</p>

<pre><code>...
// Container Activity must implement this interface
public interface OnArticleSelectedListener {
    public void onArticleSelected(Uri articleUri);
}
...
</code></pre>

<p>}
<code>
为了确认 Activity 是否实现了接口，可以在 onAttach() 中做一个转换处理：
</code>
public static class FragmentA extends ListFragment {</p>

<pre><code>OnArticleSelectedListener mListener;
...
@Override
public void onAttach(Activity activity) {
    super.onAttach(activity);
    try {
        mListener = (OnArticleSelectedListener) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
    }
}
...
</code></pre>

<p>}
```
如果没实现接口，就会抛出 ClassCastException 异常。</p>

<p>接着，就可以在触发事件的地方调用接口了：
```
public static class FragmentA extends ListFragment {</p>

<pre><code>OnArticleSelectedListener mListener;
...
@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    // Append the clicked item's row ID with the content provider Uri
    Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
    // Send the event and Uri to the host activity
    mListener.onArticleSelected(noteUri);
}
...
</code></pre>

<p>}
```</p>

<h3>Adding items to the Action Bar</h3>

<p>（略）</p>

<h2>6. Handling the Fragment Lifecycle</h2>

<p>管理 Fragment 的生命周期，在大多地方与管理 Activity 的生命周期相似。一个 Fragment 的生命状态有以下三种：</p>

<p>（1）Resumed<br/>
Fragment 可见。</p>

<p>（2）Paused<br/>
另一个 Activity 处于前台并拥有焦点，但 Fragment 所在的 Activity 仍然可见（比如前台 Activity 有部分透明）。</p>

<p>（3）Stopped<br/>
Fragment 不可见，要么是宿主 Activity 处于 stopped 状态，要么是这个 Fragment 被移除（如用户滑动到下一个 Fragment）并处于后台堆栈中。stopped 状态的 Fragment 仍然生存，所有的状态和成员信息都被系统保留着。如果宿主 Activity 被销毁，Fragment 也同时被销毁。</p>

<p>下图为 Activity 生命周期与 Fragment 生命周期的对应关系：
<img src="/images/activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle" /></p>

<p>跟 Activity 一样，你可以使用 Boundle 来保存 Fragment 的状态，万一 Activity 所在进程被杀掉了，你就可以在重建 Activity 的时候还原 Fragment 的状态。你可以在 onSaveInstanceState() 里保存状态，并在 onCreate() 、onCreateView() 或 onActivityCreated() 中恢复状态。</p>

<h3>Coordinating with the activity lifecycle</h3>

<p>onAttach()<br/>
当 Fragment 开始与 Activity 建立关联时被调用，Activity 实例被传进来。</p>

<p>onCreateView()<br/>
当 Fragment UI 与 Activity 布局建立关联时被调用。</p>

<p>onActivityCreated()<br/>
在 Activity 的 onCreate() 方法返回之后被调用。</p>

<p>onDestroyView()<br/>
Called when the view hierarchy associated with the fragment is being removed.</p>

<p>onDetach()<br/>
Called when the fragment is being disassociated from the activity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android AIDL]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/28/android-aidl/"/>
    <updated>2014-08-28T10:13:19+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/28/android-aidl</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/aidl.html">http://developer.android.com/guide/components/aidl.html</a></p>

<p>AIDL 与其它 IDLs（接口定义语言）类似，它允许你定义客户端和服务端都能够识别的编程接口，然后通过 IPC 就可以实现两端的通信。不过，在使用 AIDL 之前，你应该思考是否一定要采用 AIDL：如果你不需要跨进程通信，那么直接实现 Binder 即可；如果你需要跨进程通信，但不要求处理多线程任务，那么使用 Messenger 即可。</p>

<p>在你开始设计 AIDL 接口之前，要意识到接口调用就是函数调用，这涉及到执行线程的问题，你不能假设调用在什么线程上执行，而事实上，这取决于调用源自本地进程还是远程进程：<br/>
（1）在本地进程调用的话，接口在调用者所在线程上执行。比如，如果在 UI 线程调用，就在 UI 线程执行。不过，这样的话就没必要用到 AIDL 了，而应该直接用 Binder。（这样说来，AIDL 其实也可以用在非 IPC 场景？）<br/>
（2）从远程进程调用的话，系统会在本地进程中建立一个线程池，并在线程池中取出线程来执行。要注意处理线程安全。<br/>
（3）The oneway keyword modifies the behavior of remote calls. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the Binder thread pool as a normal remote call. If oneway is used with a local call, there is no impact and the call is still synchronous.</p>

<!--more-->


<h2>1. Defining an AIDL Interface</h2>

<h3>1.1 Create the .aidl file</h3>

<p>AIDL 使用 Java 语法来声明接口，接口可以是一个或多个带参数和返回值的方法，这些参数和返回值可以是任何类型，甚至是其他 AIDL 生成的接口。</p>

<p>AIDL 默认支持以下数据类型：<br/>
（1）所有 Java 基本类型（such as int, long, char, boolean, and so on）<br/>
（2）String<br/>
（3）CharSequence<br/>
（4）List<br/>
All elements in the List must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. A List may optionally be used as a &ldquo;generic&rdquo; class (for example, List<String>). The actual concrete class that the other side receives is always an ArrayList, although the method is generated to use the List interface.<br/>
（5）Map<br/>
All elements in the Map must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. Generic maps, (such as those of the form Map&lt;String,Integer> are not supported. The actual concrete class that the other side receives is always a HashMap, although the method is generated to use the Map interface.</p>

<p>如果不是上面所列举的类型，你就需要使用 import 声明。</p>

<p>下面是一个 .aidl 例子：
```
// IRemoteService.aidl
package com.example.android;</p>

<p>// Declare any non-default types here with import statements</p>

<p>/<em>* Example service interface </em>/
interface IRemoteService {</p>

<pre><code>/** Request the process ID of this service, to do evil things with it. */
int getPid();

/** Demonstrates some basic types that you can use as parameters
 * and return values in AIDL.
 */
void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
        double aDouble, String aString);
</code></pre>

<p>}
```
只要将定义好的 .aidl 文件放入 src/ directory 路径下，SDK 就会在构建工程时自动生成 IBinder 接口文件在 gen/ directory，生成的文件名与 .aidl 文件名一样，并以 .java 为扩展名。</p>

<p>如果你使用 Eclipse，并打开了自动构建选项，IBinder 接口文件会立即生成。</p>

<h3>1.2 Implement the interface</h3>

<p>在上一步生成的接口文件中包含了一个 Stub 子类，它是 .aidl 接口的抽象实现。Stub 同时定义了一些辅助方法，尤其是 asInterface()，这个方法在客户端会使用到，用于返回 IBinder 对象。</p>

<p>接下来是实现 Stub 类：
```
private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {</p>

<pre><code>public int getPid(){
    return Process.myPid();
}
public void basicTypes(int anInt, long aLong, boolean aBoolean,
    float aFloat, double aDouble, String aString) {
    // Does nothing
}
</code></pre>

<p>};
```
在实现 AIDL 接口时还有几点要注意的：<br/>
（1）接口不保证会在（Service 所在的本地进程的）主线程上执行，因此，你一开始就应该考虑多线程的问题，以确保线程安全。<br/>
（2）默认情况下，RPC（远程过程调用，是 IPC 的一种形式）是同步的，如果你确定调用是耗时的，就不应该在主线程上调用，而应该在工作线程上调用。<br/>
（3）远程接口上的异常不会传递到调用方法上。</p>

<h3>1.3 Expose the interface to clients</h3>

<p>一旦实现了 Stub，你就可以将它暴露给客户端了。在 Service 的 onBind() 方法返回 Stub 对象。
```
public class RemoteService extends Service {</p>

<pre><code>@Override
public void onCreate() {
    super.onCreate();
}

@Override
public IBinder onBind(Intent intent) {
    // Return the interface
    return mBinder;
}

private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
    public int getPid(){
        return Process.myPid();
    }
    public void basicTypes(int anInt, long aLong, boolean aBoolean,
        float aFloat, double aDouble, String aString) {
        // Does nothing
    }
};
</code></pre>

<p>}
```
同时，需要将 .aidl 文件放在客户端工程的 src/ directory 中，以便生成 Java 形式的接口文件。</p>

<p>现在，当客户端调用 bindService() 去连接 Service 时，客户端的 onServiceConnected() 回调方法里会得到 Service 在 onBind() 中返回的 mBinder 对象。</p>

<p>当客户端从 onServiceConnected() 中得到 IBinder 对象后，还需要用 YourServiceInterface.Stub.asInterface(service) 方法将 IBinder 转换为 YourServiceInterface 类型（也就是上面生成的 Java 类），这样才能调用定义的接口。如以下代码：</p>

<p>```
IRemoteService mIRemoteService;
private ServiceConnection mConnection = new ServiceConnection() {</p>

<pre><code>// Called when the connection with the service is established
public void onServiceConnected(ComponentName className, IBinder service) {
    // Following the example above for an AIDL interface,
    // this gets an instance of the IRemoteInterface, which we can use to call on the service
    mIRemoteService = IRemoteService.Stub.asInterface(service);
}

// Called when the connection with the service disconnects unexpectedly
public void onServiceDisconnected(ComponentName className) {
    Log.e(TAG, "Service has unexpectedly disconnected");
    mIRemoteService = null;
}
</code></pre>

<p>};
```</p>

<h2>2. Passing Objects over IPC</h2>

<p>通过 IPC，你可以将一个对象传输到另一个进程。Android 提供了 Parcelable 来实现这个传输过程：Parcelable 将对象拆解为有序的基本类型，装载到 Parcel 上，然后在其它进程重新组装为对象。</p>

<p>创建支持 Parcelable 协议的类，要做以下几点：</p>

<p>（1）实现 Parcelable 接口。<br/>
（2）实现 writeToParcel 方法，将数据写入 Parcel。<br/>
（3）增加一个静态字段——CREATOR，实现 Parcelable.Creator 接口。<br/>
（4）最后，创建 .aidl 文件，在其中声明这个 Parcelable 类。</p>

<p>下面的 Rect.aidl 文件中声明了一个 Parcelable 类：
```
package android.graphics;</p>

<p>// Declare Rect so AIDL can find it and knows that it implements
// the parcelable protocol.
parcelable Rect;
```</p>

<p>下面是一个实现 Parcelable 协议的例子：
```
import android.os.Parcel;
import android.os.Parcelable;</p>

<p>public final class Rect implements Parcelable {</p>

<pre><code>public int left;
public int top;
public int right;
public int bottom;

public static final Parcelable.Creator&lt;Rect&gt; CREATOR = new
</code></pre>

<p>Parcelable.Creator<Rect>() {</p>

<pre><code>    public Rect createFromParcel(Parcel in) {
        return new Rect(in);
    }

    public Rect[] newArray(int size) {
        return new Rect[size];
    }
};

public Rect() {
}

private Rect(Parcel in) {
    readFromParcel(in);
}

public void writeToParcel(Parcel out) {
    out.writeInt(left);
    out.writeInt(top);
    out.writeInt(right);
    out.writeInt(bottom);
}

public void readFromParcel(Parcel in) {
    left = in.readInt();
    top = in.readInt();
    right = in.readInt();
    bottom = in.readInt();
}
</code></pre>

<p>}
```
这个 Recent 类要处理的数据比较简单（都是整型），你可以查看 <a href="http://developer.android.com/reference/android/os/Parcel.html">Parcel</a> 支持的其它数据类型。</p>

<h2>3. Calling an IPC Method</h2>

<p>下面是调用远程接口的步骤：</p>

<p>（1）将 .aidl 文件放置到源码目录下。<br/>
（2）声明 IBinder 对象。<br/>
（3）实现 ServiceConnection。<br/>
（4）调用 Context.bindService()。<br/>
（5）在 onServiceConnected() 中调用 YourInterfaceName.Stub.asInterface((IBinder)service) 得到 IBinder 对象。<br/>
（6）到这步，你就可以使用接口方法了。注意，你应该捕获 DeadObjectException。<br/>
（7）要断开连接，调用 Context.unbindService()。</p>

<p>A few comments on calling an IPC service:<br/>
Objects are reference counted across processes.<br/>
You can send anonymous objects as method arguments.</p>

<p>下面是使用 AIDL 接口的例子：
```
public static class Binding extends Activity {</p>

<pre><code>/** The primary interface we will be calling on the service. */
IRemoteService mService = null;
/** Another interface we use on the service. */
ISecondary mSecondaryService = null;

Button mKillButton;
TextView mCallbackText;

private boolean mIsBound;

/**
 * Standard initialization of this activity.  Set up the UI, then wait
 * for the user to poke it before doing anything.
 */
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.remote_service_binding);

    // Watch for button clicks.
    Button button = (Button)findViewById(R.id.bind);
    button.setOnClickListener(mBindListener);
    button = (Button)findViewById(R.id.unbind);
    button.setOnClickListener(mUnbindListener);
    mKillButton = (Button)findViewById(R.id.kill);
    mKillButton.setOnClickListener(mKillListener);
    mKillButton.setEnabled(false);

    mCallbackText = (TextView)findViewById(R.id.callback);
    mCallbackText.setText("Not attached.");
}

/**
 * Class for interacting with the main interface of the service.
 */
private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // This is called when the connection with the service has been
        // established, giving us the service object we can use to
        // interact with the service.  We are communicating with our
        // service through an IDL interface, so get a client-side
        // representation of that from the raw service object.
        mService = IRemoteService.Stub.asInterface(service);
        mKillButton.setEnabled(true);
        mCallbackText.setText("Attached.");

        // We want to monitor the service for as long as we are
        // connected to it.
        try {
            mService.registerCallback(mCallback);
        } catch (RemoteException e) {
            // In this case the service has crashed before we could even
            // do anything with it; we can count on soon being
            // disconnected (and then reconnected if it can be restarted)
            // so there is no need to do anything here.
        }

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_connected,
                Toast.LENGTH_SHORT).show();
    }

    public void onServiceDisconnected(ComponentName className) {
        // This is called when the connection with the service has been
        // unexpectedly disconnected -- that is, its process crashed.
        mService = null;
        mKillButton.setEnabled(false);
        mCallbackText.setText("Disconnected.");

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_disconnected,
                Toast.LENGTH_SHORT).show();
    }
};

/**
 * Class for interacting with the secondary interface of the service.
 */
private ServiceConnection mSecondaryConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // Connecting to a secondary interface is the same as any
        // other interface.
        mSecondaryService = ISecondary.Stub.asInterface(service);
        mKillButton.setEnabled(true);
    }

    public void onServiceDisconnected(ComponentName className) {
        mSecondaryService = null;
        mKillButton.setEnabled(false);
    }
};

private OnClickListener mBindListener = new OnClickListener() {
    public void onClick(View v) {
        // Establish a couple connections with the service, binding
        // by interface names.  This allows other applications to be
        // installed that replace the remote service by implementing
        // the same interface.
        bindService(new Intent(IRemoteService.class.getName()),
                mConnection, Context.BIND_AUTO_CREATE);
        bindService(new Intent(ISecondary.class.getName()),
                mSecondaryConnection, Context.BIND_AUTO_CREATE);
        mIsBound = true;
        mCallbackText.setText("Binding.");
    }
};

private OnClickListener mUnbindListener = new OnClickListener() {
    public void onClick(View v) {
        if (mIsBound) {
            // If we have received the service, and hence registered with
            // it, then now is the time to unregister.
            if (mService != null) {
                try {
                    mService.unregisterCallback(mCallback);
                } catch (RemoteException e) {
                    // There is nothing special we need to do if the service
                    // has crashed.
                }
            }

            // Detach our existing connection.
            unbindService(mConnection);
            unbindService(mSecondaryConnection);
            mKillButton.setEnabled(false);
            mIsBound = false;
            mCallbackText.setText("Unbinding.");
        }
    }
};

private OnClickListener mKillListener = new OnClickListener() {
    public void onClick(View v) {
        // To kill the process hosting our service, we need to know its
        // PID.  Conveniently our service has a call that will return
        // to us that information.
        if (mSecondaryService != null) {
            try {
                int pid = mSecondaryService.getPid();
                // Note that, though this API allows us to request to
                // kill any process based on its PID, the kernel will
                // still impose standard restrictions on which PIDs you
                // are actually able to kill.  Typically this means only
                // the process running your application and any additional
                // processes created by that app as shown here; packages
                // sharing a common UID will also be able to kill each
                // other's processes.
                Process.killProcess(pid);
                mCallbackText.setText("Killed service process.");
            } catch (RemoteException ex) {
                // Recover gracefully from the process hosting the
                // server dying.
                // Just for purposes of the sample, put up a notification.
                Toast.makeText(Binding.this,
                        R.string.remote_call_failed,
                        Toast.LENGTH_SHORT).show();
            }
        }
    }
};

// ----------------------------------------------------------------------
// Code showing how to deal with callbacks.
// ----------------------------------------------------------------------

/**
 * This implementation is used to receive callbacks from the remote
 * service.
 */
private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {
    /**
     * This is called by the remote service regularly to tell us about
     * new values.  Note that IPC calls are dispatched through a thread
     * pool running in each process, so the code executing here will
     * NOT be running in our main thread like most other things -- so,
     * to update the UI, we need to use a Handler to hop over there.
     */
    public void valueChanged(int value) {
        mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));
    }
};

private static final int BUMP_MSG = 1;

private Handler mHandler = new Handler() {
    @Override public void handleMessage(Message msg) {
        switch (msg.what) {
            case BUMP_MSG:
                mCallbackText.setText("Received from service: " + msg.arg1);
                break;
            default:
                super.handleMessage(msg);
        }
    }

};
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
