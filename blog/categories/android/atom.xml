<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Steven Chen]]></title>
  <link href="http://xuanxi.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-08-24T20:56:34+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/23/reading-android-manual/"/>
    <updated>2014-08-23T15:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/23/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出具有良好用户体验的产品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/ios-design-principles/">iOS Design Principles</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/bars/">iOS UI Framework</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style-1/">Android Style (1)</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/07/29/android-style-2/">Android Style (2)</a><br/>
设计风格，主要是视觉方面。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns-1/">Android Patterns (1)</a><br/>
设计模式，主要是交互方面。</p>

<p><em>注：由于最近找到了 Android Design 的较好的<a href="http://adchs.github.io/">翻译版本</a>，Design 的内容我就直接在那里学习了，这里不再重复翻译：）</em></p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
样式与主题</p>

<p><a href="http://blog.xuanxi.me/blog/2014/08/23/android-processes-and-threads/">Processes and Threads</a><br/>
进程与线程</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Processes and Threads]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/23/android-processes-and-threads/"/>
    <updated>2014-08-23T12:05:49+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/23/android-processes-and-threads</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://developer.android.com/guide/components/processes-and-threads.html">http://developer.android.com/guide/components/processes-and-threads.html</a></p>

<p>在一个应用组件启动的时候，如果当前这个应用没有其它组件在运行，Android 就会为该应用分配一个带有一条独立执行线程（称之为 main 线程）的 Linux 进程。默认情况下，这个应用后来启动的所有组件都会运行在相同的进程和线程中。当然，你也可以为不同的组件创建不同的进程，以及为同一个进程创建多条线程。</p>

<h2>1. Processes</h2>

<p>一般情况下，一个应用所有的组件都运行在同一个进程里，进程的名字是应用的根包名。如果你需要为某个组件提供独立的进程，可以在 manifest 文件中设置。</p>

<p>manifest 文件中的四大组件元素——<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code>、<code>&lt;provider&gt;</code>——都支持通过 <code>android:process</code> 属性来指定运行的进程，你可以为每个组件创建独立的进程，或者几个组件共享一个进程。也可以为不同应用的组件配置同一个进程，前提是这些应用使用相同的 <code>android:sharedUserId</code>和签名。</p>

<p>补充：通过为不同应用设置相同的 sharedUserId 和签名，可以共享各自沙盒内的数据文件，比如数据库和 SharedPreference。如果再给它们的组件设置同一个进程，那么就可以共享任何数据了（文件数据和内存数据）。</p>

<p>另外，<code>&lt;application&gt;</code> 元素也支持 <code>android:process</code>，可以为所有的组件设置同一个进程。</p>

<h3>Process lifecycle</h3>

<p>Android 会试图让进程运行尽可能长的时间，只有在内存不足时，才会终止那些旧的进程。Android 将所有进程放入一个“重要性等级树”中，这个“重要性等级树”基于组件的运行状态，低等级的进程会首先被终止，然后是等级高一点的进程，以此类推。</p>

<p>重要性等级分五个级别，按重要性降低排列如下：</p>

<h4>（1）前台进程</h4>

<p>前台进程是用户正在交互的进程，包括以下情况：<br/>
1）持有一个与用户交互的 Activity（onResume() 被调用）；<br/>
2）持有一个 Service，这个 Service 被绑定到一个正在与用户交互的 Activity 中；<br/>
3）持有一个 Service，它调用了 startForeground()，也叫前台 Service（如在通知栏显示的音乐播放服务）；<br/>
4）持有一个正在执行生命周期方法的 Service，如 onCreate()、onStart()、or onDestroy()；<br/>
5）持有一个正在执行 onReceive() 的 BroadcastReceiver。</p>

<p>通常，在任何时间内只会存在少数的前台进程，它们只会在内存空间紧张到不能保证全部前台进程都正常运行的情况下被杀掉。那时，设备处于内存分页状态（增加内存空间的机制，见下面的解释），只能通过杀掉一些前台进程来保持用户界面的响应。</p>

<p>Paging：In computer operating systems, paging is one of the memory-management schemes by which a computer can store and retrieve data from secondary storage for use in main memory.</p>

<h4>（2）可视进程</h4>

<p>可视进程不含有任何前台组件，但仍然对用户看见的界面有影响：<br/>
1）持有一个 Activity，它不处于前台与用户交互，但仍然可见（调用了 onPause()），比如打开一个对话框后，这个 Activity 位于对话框下面，处于可见状态；
2）持有一个 Service，它被绑定到一个可视或前台 Activity（这里官方说到前台 Activity，那不就是前台进程了么？？）；</p>

<h4>（3）服务进程</h4>

<p>服务进程中运行着一个通过 startService() 启动的 Service。虽然服务进程跟用户可见的界面没有关联，但它通常在处理用户关心的事情，比如后台音乐播放、文件下载等。</p>

<h4>（4）后台进程</h4>

<p>后台进程持有一个用户不可见的 Activity（调用了 onStop() 方法，注意并不是 onDestroy()），这些进程不会对用户体验产生影响，所以系统可以在任何时候将它们杀掉。一般会有许多后台进程在运行着，系统通过 LRU （最近使用）列表来管理这里进程，以确保最常使用的进程在最后才被杀掉。</p>

<h4>（4）空进程</h4>

<p>空进程中不包含任何处在生命周期中的组件，保留空进程的原因仅仅是作为缓存使用，当下次启动相关联的组件的时候，进程可以快速运行起来。</p>

<p>Android 会尽量将一个进程放在它能到达的最高的等级。比如，进程中持有一个 Service 和 一个可视的 Activity，这个进程将被视为可视进程，而不是服务进程。</p>

<p>另外，当一个进程为另一个进程提供服务时，这个进程不会比另一个进程的等级低。比如，进程 A 中的 Content Provider 为进程 B 提供服务，或者，进程 A 的 Service 被绑定到进程 B，这两个例子中的进程 A 的等级至少和进程 B 一样高。</p>

<p>（非常重要的总结）<br/>
因为服务进程比后台进程的重要性高，所以如果要在 Activity 中进行一些耗时操作，最好把这些操作放到 Service 中，尤其是这些操作会比 Activity 运行时间更长的情况下。比如，对于 Activity 中的图片上传操作，应该开启一个 Service 去执行，以便在退出 Activity 后上传操作可以继续在服务进程中进行，否则，进程在转为后台进程甚至空进程后，很有可能被杀死，上传操作也随之中断。所以说，使用 Service 可以保证某些操作至少运行在“服务进程”的级别，而不管 Activity 是否已经退出。同样地，BroadcastReceiver 中的耗时操作也应该放到 Service 中进行（Android 对 onReceive() 方法有时间限制，通常为5秒）。</p>

<h2>2. Threads</h2>

<p>当应用启动的时候，系统会为之创建一条主线程。主线程非常重要，它负责用户界面事件的分发和处理，包括绘图事件、UI 事件等，主线程通常也被叫做 UI 线程。所有同一个进程中的系统组件都运行在 UI 线程上，所以，系统回调方法（像 onKeyDown() 或者生命周期方法）都会在 UI 线程上执行。</p>

<p>例如，当用户点击按钮，应用的 UI 线程会将点击事件分发给控件，控件就会置当前状态为按下状态，同时发送 invalidate 请求到 UI 线程的事件队列，UI 线程取出请求消息并通知控件重绘。</p>

<p>当交互过程中要执行一些耗时操作时，比如请求网络或读取数据库，可能会阻塞 UI 线程，以致不能分发和处理其它事件，包括绘图事件。如果阻塞超过5秒，系统会弹出 ANR 对话框。这种糟糕的体验会令用户退出你的应用，甚至卸载。</p>

<p>另外，UI 组件不是线程安全的，你不能在工作线程上处理 UI。综上所述，有两种规则去处理 Android 的单线程模型：<br/>
（1）不要阻塞 UI 线程；<br/>
（2）不要在非 UI 线程上操作 UI。</p>

<h3>Worker threads</h3>

<p>Android 的单线程模型要求你不能阻塞 UI 线程，所以你应该将耗时操作放在新的线程上执行，称之为后台线程或工作线程。</p>

<p>例如，下面的代码是一个点击事件监听器，使用工作线程下载图片并显示在 ImageView 上：<br/>
```
public void onClick(View v) {</p>

<pre><code>new Thread(new Runnable() {
    public void run() {
        Bitmap b = loadImageFromNetwork("http://example.com/image.png");
        mImageView.setImageBitmap(b);
    }
}).start();
</code></pre>

<p>}
```
但上面的代码并没有遵守第二条规则：不要在非 UI 线程上操作 UI。</p>

<p>Android 提供了几种方法支持从工作线程中访问 UI 线程：<br/>
（1）Activity.runOnUiThread(Runnable)<br/>
（2）View.post(Runnable)<br/>
（3）View.postDelayed(Runnable, long)</p>

<p>于是，上面的代码可以修改为：
```
public void onClick(View v) {</p>

<pre><code>new Thread(new Runnable() {
    public void run() {
        final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png");
        mImageView.post(new Runnable() {
            public void run() {
                mImageView.setImageBitmap(bitmap);
            }
        });
    }
}).start();
</code></pre>

<p>}
```
修改之后的代码就保证线程安全了。</p>

<p>可是，随着这种跨线程 UI 操作的增多，代码会变得复杂和难于维护，为了在工作线程中能够处理更复杂的交互，你可以使用 Hanlder，将 UI 操作都放到 Handler 中执行。不过，AsyncTask 也许是更好的解决方案。</p>

<h3>Using AsyncTask</h3>

<p>AsyncTask 允许你在界面中执行异步工作，它将阻塞操作放在工作线程上运行，并将结果发送到 UI 线程上，这样就避免了你直接去使用线程和 Handler。</p>

<p>要使用 AsyncTask，你需要从 AsyncTask 类派生一个子类，并实现 doInBackground() 方法，这个方法运行在线程池中。如果要更新 UI，你还需要实现 onPostExecute() 方法，这个方法接收来自 doInBackground() 的返回，以及运行在 UI 线程上。</p>

<p>例如，你可以这样实现：
```
public void onClick(View v) {</p>

<pre><code>new DownloadImageTask().execute("http://example.com/image.png");
</code></pre>

<p>}</p>

<p>private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap> {</p>

<pre><code>/** The system calls this to perform work in a worker thread and
  * delivers it the parameters given to AsyncTask.execute() */
protected Bitmap doInBackground(String... urls) {
    return loadImageFromNetwork(urls[0]);
}

/** The system calls this to perform work in the UI thread and delivers
  * the result from doInBackground() */
protected void onPostExecute(Bitmap result) {
    mImageView.setImageBitmap(result);
}
</code></pre>

<p>}
```
现在，UI 操作安全了，代码也比较简洁，因为它将后台操作与前台 UI 操作分开了。</p>

<p>注意：在你使用工作线程的时候可能会遇到另一个问题，就是当前的 Activity 会因为配置的改变而重建（如改变屏幕方向），以致销毁了工作线程。要解决这个问题，可参考 Shelves 源码。</p>

<h3>Thread-safe methods</h3>

<p>某些情况下，你的方法需要被多个线程调用，因此要确保这些方法是线程安全的。</p>

<h2>3. Interprocess Communication</h2>

<p>Android 使用远程过程调用（RPC）来实现进程间通信（IPC），即在 Activity 或其它应用组件中调用方法，在远程（其它进程）执行方法，并将结果返回给调用者。这种过程的实现，需要将方法调用和附带的数据解析到系统可以识别的水平，将它们从本地进程和地址空间传输到远程目标进程和地址空间，然后重新组装并执行调用，返回值会按相反的方向传输回去。Android 已经提供了这种 RPC 通信过程的实现，你只需要定义和实现远程调用接口即可。</p>

<p>另外，要实现 IPC，你的应用必须使用 bindService() 绑定到一个（其它应用的） Service。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio vs Eclipse: What Are the Main Differences?]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences/"/>
    <updated>2014-08-07T14:09:55+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/">http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/</a></p>

<p><img src="/images/androidstudio.png" alt="androidstudio" /></p>

<!--more-->


<p>Most of Google’s 2013 I/O event was about Android. One specific announcement managed to attract a lot of hype and that was no other than Google’s own Android IDE, Android Studio. It has been just over a year now since the first public release and Android Studio has come a long way, despite still being in beta. The IDE itself is based off the very popular IntelliJ IDEA from JetBrains and is being offered by Google for free.</p>

<p>Google 2013 I/O 大会的大部分内容是与 Android 相关，其中，专为 Android 打造的开发环境——Android Studio 无疑最引人注目。Android Studio 从公开第一个版本至今已经走过一个年头，尽管仍然处于 beta 版本（公开测试版），但相比一年前，Google 已经对其做了相当多的改进。Android Studio 基于非常著名的 JetBrains 公司的产品——IntelliJ IDEA，并免费提供给开发者。</p>

<p>On the other hand, Eclipse is more mature than ever and Google’s ADT plugin which transforms the popular IDE into a fully featured Android developing environment has become very stable. Eclipse feels like home for many Java developers and is a natural starting point for Java developers who want to get into Android development.</p>

<p>另一方面，基于 Google ADT 插件的 Eclipse 现在已经成为 Android 开发的一个非常成熟稳定的环境，作为要进入 Android 开发领域的 Java 开发人员，Eclipse 是一个自然而然的选择。</p>

<p>While both solutions look promising, which one has the edge over the other? In this blog we will compare the two in 5 distinct areas in an effort to reveal the main differences in the Android Studio vs Eclipse battle.</p>

<p>两个开发环境看起来都有不错的前景，那么哪个更具优势呢？本文试图从5个方面分析它们的不同。</p>

<h3>Build Tools</h3>

<p>Android Studio utilizes the fast growing Gradle build system. It builds on top of the concepts of Apache Ant and Apache Maven but it also introduces a Groovy DSL (Domain-Specific Language) that allows for scripted builds which opens up many automation possibilities like uploading your beta .apk to TestFlight for testing. Eclipse on the other hand uses Apache Ant as its main build system which a very robust XML based build system that many Java developers may already be familiar with.</p>

<p>Android Studio 使用了当前发展迅猛的 Gradle 构建系统，它基于 Groovy 脚本语言，可以实现比 Ant 和 Maven 更灵活的构建过程，如自动上传测试包。而 Eclipse 使用成熟健壮的 Ant 作为构建系统。</p>

<h3>Advanced Code Completion/Refactoring</h3>

<p>Both IDEs feature the standard Java code auto completion but in the case of Android Studio, Google has baked in deeper support for specific Android code and refactoring. Android Studio can refactor your code in places where it’s just not possible using Eclipse and ADT. In addition, in my opinion IntelliJ’s Java auto completion seems more “intelligent” and predicts better what I want to do so there is definitely an improvement in this area over Eclipse.</p>

<p>两个 IDE 都提供了代码补全和重构功能，不过，Android Studio 在对 Android 代码的补全和重构方面做了更好的支持。另外，我认为 IntelliJ 的 Java 代码补全更加智能，预判准确率更高，这个相比 Eclipse 无疑是一个进步。</p>

<h3>User Interface Design</h3>

<p>One of the main selling point Google used to market Android Studio when it came out was its completely redesigned user interface design tool. After working with it for some time, it’s clear that the new tool is much better than the old. It literally crashes it. The new interface design tool in Android Studio is faster, responds to changes more rapidly and has more customization options that with Eclipse, you had to manually set in the XML.</p>

<p>用户界面设计工具是 Android Studio 的一个主要卖点。比起 ADT，Android Studio 上的设计工具更快、更灵活，比如在 Android Studio 的设计面板上可以直接设置元素属性，而在 Eclipse 上只能手动修改 XML 文件。</p>

<h3>Project Organization</h3>

<p>Both IDEs work differently in an effort to help you manage and organize your projects. If you’ve used Eclipse then you must be familiar with the concept of workspaces. When Eclipse starts, you select the workspace that contains your projects and you can load all project of that workspace in your tree navigation. If you want to switch to a project in a different workspace, then you have to restart the whole IDE. Android Studio treats this situation differently by introducing the concept of modules. Your app could be one module, a library that you just downloaded can be another and the Ad SDK you are currently integrating could be a third. Each of these modules can have their own Gradle build files and declare their own dependencies. To me, Android Studio seems more natural but it takes some time to get used to if you have been using Eclipse for a long time.</p>

<p>两个 IDE 在工程组织上各不相同。Eclipse 使用 workspace &ndash; project 的结构，Android Studio 使用 project &ndash; module 的结构，我更偏向 Android Studio 的组织方式。（从表面上看，貌似也没多大差别啊）</p>

<h3>IDE Performance/Stability</h3>

<p>Eclipse is a purely Java based software, and a big one. In order to run it reliably you need to have more than decent amount of RAM and good CPU power to back it up. Many user who do not strictly meet these criteria are reporting very bad experiences with it. It is not unusual for Eclipse to crash while exporting an apk or having to restart it after using it for a few hours straight. Having said that, Android Studio is still in beta so it comes with its own bugs that crash the IDE every now and then but in the meanwhile, the whole experience feels faster and more robust.</p>

<p>Eclipse 是一个使用纯 Java 语言编写的程序，由于它是基于可扩展的设计思想，即通过各种插件来提供特定开发环境，所以本身体积较大，运行时需要较多的内存和 CPU 资源，你可能会遇到这样的情况：打包 apk 时程序崩溃了，或者运行几个小时后因为响应太慢而不得不重启。对于 Android Studio ，上面已经提到它仍然处于 beta 阶段，会偶尔崩溃，不过，现时它的整体体验已经相对更快和更稳定。</p>

<h3>Conclusion</h3>

<p>Having used both Android Studio and Eclipse for a while now, I would personally say that Android Studio has the edge over the two. It might be a bit unstable yet and some updates require a complete re-installation of the software but when it eventually comes out of beta, it will blow Eclipse with ADT out of the water. I especially like the stability of the editor and not having to reboot every now and then, the new and improved UI designer and the sexy themes that make Android Studio a real eye candy. What side will you take in the Android Studio vs Eclipse battle?</p>

<p>我同时使用 Android Studio 和 Eclipse 已有一段时间，我个人认为 Android Studio 更具优势，虽然存在不稳定性，以及升级可能需要重装，但就在 beta 版发布之后，它完全可以击败 Eclipse。我尤其喜欢它的编辑器的稳定、无需重启、增强的界面设计和性感的外观。</p>

<h2>我的看法</h2>

<p>和本文作者一样，我也同时使用这两个 IDE 一段时间了（公司用 Eclipse，个人用 Android Studio），并同样感受到 Android Studio 的明显优势：<br/>
1. 快，无论是启动程序，还是打开 XML 文件，都可以明显看出两个 IDE 的速度差别；<br/>
2. 酷，那个 Darcula 的外观实在比 Eclipse 呆板的外观好看得多（Eclipse 中可使用 color theme 来美化外观，但个人觉得也比不上 Android Studio）。<br/>
对于重构和新的界面设计工具，我的使用经验还不多，这里就不作评论了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style (2)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/29/android-style-2/"/>
    <updated>2014-07-29T09:56:06+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/29/android-style-2</id>
    <content type="html"><![CDATA[<p>本篇包括以下内容：<br/>
6. Color<br/>
7. Iconography<br/>
8. Your Branding<br/>
9. Writing Style</p>

<!--more-->


<h2>6. Color</h2>

<h2>7. Iconography</h2>

<p><img src="/images/iconography_overview.png" alt="iconography_overview" /></p>

<p>图标就是⼀个直观的图形，占据屏幕一个小空间，用来代表⼀个操作、⼀种状态或者⼀个应用本身。</p>

<p>当你为应用设计图标时，需要紧记的是你的应用可能会被安装到多种分辨率的设备中。不过，你可以通过提供不同大小的图标来适配各种密度的设备。</p>

<p>因为你要提供多种规格图标来适配多种密度，下文中提到的图标尺寸都用 dp 为单位。dp 是以 MDPI 中的像素为基准的，即在 MDPI 中 1dp=1px，在 HDPI 中 1dp=1.5px，在 XHDPI 中 1dp=2px，如下图所示：</p>

<p><img src="/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<p>这样，当你设计图标的时候，应该按照  2:3:4:6:8（或者 1:1.5:2:3:4） 的比例去缩放。例如，一个应用启动图标的规格为 48x48 dp，意味着 MDPI 的大小是 48x48 px，HDPI 的大小是 72x72 px，以此类推。</p>

<p>注意：Android 也支持一种更小的屏幕密度 LDPI，不过通常不需要考虑这种密度，因为 Android 会将 HDPI 中的图标缩小一半来适配它。<br/>
补充：在要求不太严格的情况下，我们可以只为高密度屏幕设计一套图标，比如 XHDPI，Android 会自动缩小尺寸适配所有密度屏幕。</p>

<h3>Launcher</h3>

<p>启动图标</p>

<p>启动图标用在 Home 界面和 All Apps 界面。因为用户可以改变 Home 的背景，所以要考虑启动图标是否能够在任何类型的背景中都清晰可见。</p>

<p><img src="/images/iconography_launcher_size.png" alt="iconography_launcher_size" /></p>

<p>Sizes &amp; scale <br/>
1. 启动图标在移动设备中必须为 48x48 dp；<br/>
2. 启动图标在 Google Play 中必须为 512x512 pixels。</p>

<p><img src="/images/iconography_launcher_focal.png" alt="iconography_launcher_focal" /></p>

<p>Proportions<br/>
图标不要留白，要占满 48x48 dp 大小。</p>

<p><img src="/images/iconography_launcher_style.png" alt="iconography_launcher_style" /></p>

<p>Style<br/>
Use a distinct silhouette. Three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth.<br/>
使用清晰的轮廓。三维的正面视图，看起来稍微有点从上往下的俯视效果，使用户能看到⼀些景深。</p>

<p><img src="/images/iconography_launcher_example2.png" alt="iconography_launcher_example2" /></p>

<h3>Action Bar</h3>

<p>操作栏图标是⼀个图形按钮，用来表示用户在应用中可以执行的重要操作。使用简洁明了的图像代表将要执行的操作，让用户⼀目了然。</p>

<p>Android 内置了一些通用操作的图标供使用，例如“刷新”和“分享”。下面提供了图标包的下载链接，其中包括多种屏幕分辨率，以及对应 Holo Light和 Holo Dark 主题的图标。包中带有尚未样式化的图标，同时提供 Adobe® Illustrator® 源文件，你可以自由修改以搭配自⼰的主题。</p>

<p><a href="http://developer.android.com/downloads/design/Android_Design_Icons_20131106.zip">Download the Action Bar Icon Pack</a></p>

<p><img src="/images/iconography_actionbar_size.png" alt="iconography_actionbar_size" /></p>

<p>Sizes &amp; scale<br/>
Action bar icons for phones should be 32x32 dp.</p>

<p><img src="/images/iconography_actionbar_focal.png" alt="iconography_actionbar_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset 整体大小, 32x32 dp<br/>
Optical square 实际内容, 24x24 dp</p>

<p><img src="/images/iconography_actionbar_style.png" alt="iconography_actionbar_style" /></p>

<p>Style<br/>
Pictographic, flat, not too detailed, with smooth curves or sharp shapes. If the graphic is thin, rotate it 45° left or right to fill the focal space. The thickness of the strokes and negative spaces should be a minimum of 2 dp.<br/>
形象化，扁平，不要⼩细节，使用平滑曲线或尖锐的轮廓。如果是瘦长型的图形，将它转45度角再填满内容区。线的宽度不应低于2 dp。</p>

<p><img src="/images/iconography_actionbar_colors.png" alt="iconography_actionbar_colors" /></p>

<p>Colors for Light<br/>
Colors: #333333<br/>
Enabled: 60% opacity<br/>
Disabled: 30% opacity</p>

<p>Colors for Dark<br/>
Colors: #FFFFFF<br/>
Enabled: 80% opacity<br/>
Disabled: 30% opacity</p>

<h3>Small / Contextual Icons</h3>

<p>小图标与上下文图标</p>

<p>在应用的主体区域中，使用⼩图标表示操作或者特定对象的状态。例如在 Gmail 应用中，每条信息都有⼀个星型图标用来标记“重要”。</p>

<p><img src="/images/iconography_small_size.png" alt="iconography_small_size" /></p>

<p>Sizes &amp; scale<br/>
Small icons should be 16x16 dp.</p>

<p><img src="/images/iconography_small_focal.png" alt="iconography_small_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 16x16 dp<br/>
Optical square, 12x12 dp</p>

<p><img src="/images/iconography_small_style.png" alt="iconography_small_style" /></p>

<p>Style<br/>
Neutral, flat, and simple. Filled shapes are easier to see than thin strokes. Use a single visual metaphor so that a user can easily recognize and understand its purpose.<br/>
灰色为主、扁平和简单。最好使用填充图标而不是细线条勾勒。使用简单直观的图形，让用户容易理解图标的作用。</p>

<p><img src="/images/iconography_small_colors.png" alt="iconography_small_colors" /></p>

<p><img src="/images/iconography_small_example.png" alt="iconography_small_example" /></p>

<p>Colors<br/>
在特殊情况下使用非灰色的图标。例如在 Gmail 应用中，使用了黄色的星型图标表示重要的信息。如果图标是可点击的，使用和背景形成对比的颜色。</p>

<h3>Notification Icons</h3>

<p>通知图标</p>

<p><img src="/images/iconography_notification_size.png" alt="iconography_notification_size" /></p>

<p>Sizes &amp; scale<br/>
Notification icons must be 24x24 dp.</p>

<p><img src="/images/iconography_notification_focal.png" alt="iconography_notification_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 24x24 dp<br/>
Optical square, 22x22 dp</p>

<p><img src="/images/iconography_notification_style.png" alt="iconography_notification_style" /></p>

<p>Style<br/>
Keep the style flat and simple, using the same single, visual metaphor as your launcher icon.<br/>
扁平，简单，类似启动图标。</p>

<p><img src="/images/iconography_notification_example.png" alt="iconography_notification_example" /></p>

<p>Colors<br/>
Notification icons must be entirely white. Also, the system may scale down and/or darken the icons.<br/>
通知图标必须为纯白色，另外，系统会缩小图标或令图标变暗。</p>

<h3>Design Tips</h3>

<p>下面是一些图标设计建议，这些建议假设你使用 Photoshop 或者其它栅格或矢量图形工具。</p>

<h4>Use vector shapes where possible</h4>

<p>尽量使用矢量图</p>

<h4>Start with large artboards</h4>

<p>从大画板开始设计</p>

<h4>When scaling, redraw bitmap layers as needed</h4>

<p>？？</p>

<h4>Use common naming conventions for icon assets</h4>

<p> 使用统一的命名方法，使得所有图标在文件夹中会聚在一起并按字母顺序排列，如下图：</p>

<p><img src="/images/icon_common_naming.png" alt="icon_common_naming" /></p>

<h4>Set up a working space that organizes files by density</h4>

<p>为不同密度图标建立对应文件夹：
```
art/&hellip;</p>

<pre><code>mdpi/...
    _pre_production/...
        working_file.psd
    finished_asset.png
hdpi/...
    _pre_production/...
        working_file.psd
    finished_asset.png
xhdpi/...
    _pre_production/...
        working_file.psd
    finished_asset.png
</code></pre>

<p>```</p>

<h4>Remove unnecessary metadata from final assets</h4>

<p>尽管 Android 在打包时会自动压缩 png 图片，但图片中仍然包含着不必要的头部信息和 metadata，你应该把这些信息也删除掉。可以使用以下两个工具：<br/>
<a href="http://optipng.sourceforge.net/">OptiPNG</a><br/>
<a href="http://pmt.sourceforge.net/pngcrush/">Pngcrush</a>。</p>

<h2>8. Your Branding</h2>

<p>你的品牌</p>

<p>遵循 Android 的设计模式并不意味着你的应用和其它应用没什么区别，相反，你的应用可以表现出你的品牌的特点。</p>

<h3>Color</h3>

<p>品牌颜色</p>

<p>用你的品牌颜色取代 Android 默认的蓝色，新的颜色将会体现在复选框、进度条、单选按钮、滑动条、tab 按钮、滑动指示等常用控件上。</p>

<p>在合适的地方用高对比度的颜色来作强调，比如 action bar 的背景颜色或者一个主要的按钮。记住不要过度使用这种颜色，因为不是所有操作都同等重要，所以只能用在一到两个最重要的地方。</p>

<p>在自定义颜色的时候，记得对触摸反馈也做出轻微调整——比原始状态稍亮或稍暗，具体可参考 “3.Touch Feedback”。</p>

<p><img src="/images/branding_wallet.png" alt="branding_wallet" /></p>

<p>The four colors of the Google Wallet logo provide a playful accent to the four dots that appear as the user enters a PIN.</p>

<p><img src="/images/branding_googlemusic.png" alt="branding_googlemusic" /></p>

<p>The Google Play Music app has an orange theme color, which is used for emphasis in the action bar and for accent in the selected tab, scroll indicator, and hyperlinks.</p>

<h3>Logo</h3>

<p>品牌 logo</p>

<p>首先要明确的是，启动图标（launcher icon）不等于 logo，启动图标只是基于 logo 设计的图标。不过，启动图标是一个展示品牌 logo 的关键，因为用户要寻找它并通过它来启动应用。直接把启动图标放在 action bar 上就可以达到展示品牌的目的。</p>

<p>另一方法是将 logo 放在 action bar 上，而不是使用启动图标和应用名字。</p>

<p><img src="/images/branding_launcher_icon.png" alt="branding_launcher_icon" /></p>

<p><img src="/images/branding_logo_icon_action_bar.png" alt="branding_logo_icon_action_bar" /></p>

<p>Google+ 直接把启动图标放在 action bar 上。</p>

<p><img src="/images/yourbranding_app.png" alt="yourbranding_app" /></p>

<p>将 logo 放在 action bar 上的例子。</p>

<h3>Icons</h3>

<p>品牌图标</p>

<p>如果你在其它平台的 app 上有符合你的品牌要求的图标，也可以用到 Android 上来，但要确保品牌与这些图标的风格一致。</p>

<p><img src="/images/yourbranding_in-app-icons.png" alt="yourbranding_in-app-icons" /></p>

<p>One exception: For any icon in your existing set where the symbol is different from Android&rsquo;s, use Android&rsquo;s symbol but give it your brand&rsquo;s styling. That way, users will understand what the purpose of the icon is based on what they&rsquo;ve learned in other Android apps (Design principle: Give me tricks that work everywhere). But the icon will still look like it belongs with all of your other icons as a part of your brand.</p>

<p>Example:<br/>
The brand&rsquo;s normal icon for sharing on other platforms is a right arrow.</p>

<p><img src="/images/yourbranding_sharing.png" alt="yourbranding_sharing" /></p>

<p>如果你没有自己的图标，并且只创建 Android 应用，这样的话，可以使用 Android 提供的标准图标，而通过颜色和 logo 来展示你的品牌。（对设计能力不足的小团队可以这样做）</p>

<h2>9. Writing Style</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Styles and Themes]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/24/styles-and-themes/"/>
    <updated>2014-07-24T17:50:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/24/styles-and-themes</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/topics/ui/themes.html">http://developer.android.com/guide/topics/ui/themes.html</a></p>

<p>一个 style 是某些属性的集合，这些属性定义了 view 或 window 的外观和格式，比如 height、padding、font color、font size、background color 等。</p>

<!--more-->


<p>与 web 设计中的 CSS 相似，Android style 的目的是设计与内容分离。例如，使用 style 的话，你可以将以下代码：
```
&lt;TextView</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:textColor="#00FF00"
android:typeface="monospace"
android:text="@string/hello" /&gt;
</code></pre>

<p><code>
替换为：
</code>
&lt;TextView</p>

<pre><code>style="@style/CodeFont"
android:text="@string/hello" /&gt;    
</code></pre>

<p>```
theme 就是一个用于 Activity 和 Application 的 style，而普通的 style 只用于单独的 view。当 style 被当做 theme 使用之后，在 Activity 或 Application 中的所有 view 都会应用该 style 的属性。例如，你可以将一个字体 style 用作一个 Activity 的 theme，然后该 Activity 里的所有文本都会使用这个字体。</p>

<h2>1. 定义 Styles</h2>

<p>要创建一组 style，首先在 res/values/ 目录下创建一个 xml 文件，文件名可自定义，通常为 styles.xml。文件的根节点为 <code>&lt;resoueces&gt;</code>：
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt;
    &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt;
    &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt;
    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
    &lt;item name="android:typeface"&gt;monospace&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p></resources>
<code>``
每个</code><resources><code>元素的子节点在编译时都被转换为一个应用程序资源对象，其可以通过</code><style><code>元素的</code>name<code>属性的值来引用，如</code>style=&ldquo;@style/CodeFont&rdquo;`。</p>

<p><code>&lt;style&gt;</code> 中的 parent 属性是可选的，用来指定另外一个 style 的资源ID，前者继承后者的所有属性。你也可以覆写继承来的 style 属性。</p>

<p>用在 Activity 或应用程序上的 theme 的定义方式和 style 的定义方式是相同的。一个如同上面那样例子中定义的 style 既可以用作一个 View的 style，也可以用作一个 Activity 或应用程序的 theme。</p>

<h3>继承</h3>

<p>parent 属性让你可以继承一个 style，然后定义你想改变或添加的属性。你可以从自定义的 style 或者平台的 style 中继承：
```</p>

<pre><code>&lt;style name="GreenText" parent="@android:style/TextAppearance"&gt;
    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><code>
如果你要继承自定义的 style，不必用到 parent，仅需要把父 style 名字作为新 style 名字的前缀即可，中间用点分隔：
</code></p>

<pre><code>&lt;style name="CodeFont.Red"&gt;
    &lt;item name="android:textColor"&gt;#FF0000&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><code>
上面的 style 使用 `@style/CodeFont.Red` 来引用。也可以多次继承：
</code></p>

<pre><code>&lt;style name="CodeFont.Red.Big"&gt;
    &lt;item name="android:textSize"&gt;30sp&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>```</p>

<p>要注意的是，前缀加点间隔的方法仅使用与自定义的 style，并不适用于平台内建的 style。</p>

<h3>Style 属性</h3>

<p>接下来，你需要了解在 <code>&lt;style&gt;</code> 的 <code>&lt;item&gt;</code> 元素中可以定义哪些属性值。比如你可能已经知道的 layout_width 和 textColor 等等。</p>

<p>要知道某个 view 的所有属性，最好的地方就是它的官方参考文档（比如 TextView 的 &lt;<a href="http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8">http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8</a> XML Attributes 的地方就列出了所有支持的属性，这些属性都可以用在 style 里。</p>

<p>下面以 EditText 的 android:inputType 属性为例子，一般情况你可以在布局中直接使用：
```
&lt;EditText</p>

<pre><code>android:inputType="number"
... /&gt;
</code></pre>

<p><code>
你也可以定义一个 style：
</code></p>



<p><code>
然后你的布局变成这样：
</code>
&lt;EditText</p>

<pre><code>style="@style/Numbers"
... /&gt;
</code></pre>

<p>```
这个例子看起来是增加了工作量，但当你的 style 里包含了更多的属性，并且在多个布局中都使用到这个 style 的时候，style 的作用就会凸显。</p>

<p>要知道的是，不是所有的 View 都接受相同的 style 属性，所以你应该先查看所支持的属性。不过，如果一个 style 中包含了 View 不支持的属性，这些属性会被忽略。</p>

<p>有些属性不被任何 View 支持，只能用作 theme，比如隐藏应用标题栏，隐藏状态栏，改变窗口背景等。<a href="http://developer.android.com/reference/android/R.attr.html">R.attr</a> 中以 <code>windows</code> 起头的属性就是这样的属性。</p>

<p>注意，每一个属性要使用 <code>android:</code> 作为命名空间，比如: <code>&lt;item name="android:inputType"&gt;</code>。</p>

<h2>2. 使用自定义的 Styles 和 Themes</h2>

<p>有两种方式使用一个 style：<br/>
对一个独立的 View，添加 style 属性到你的布局的 View 元素中：
```
&lt;TextView</p>

<pre><code>style="@style/CodeFont"
android:text="@string/hello" /&gt;
</code></pre>

<p><code>
对一个 Activity 或应用，添加 `android:theme` 属性到 Android manifest 的 `&lt;activity&gt;` 或 `&lt;application&gt;` 元素中：
</code>
<application android:theme="@style/CustomTheme">
<activity android:theme="@style/CustomTheme">
```</p>

<h2>3. 使用系统自带的 Styles and Themes</h2>

<p>Android 平台提供了大量的 style 和 theme 供你使用。你可以在<a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 类中找到所有可用的 style，只需要用句号替换 style 名称中的下划线即可。例如，你可以通过 <code>@android:style/Theme.NoTitleBar</code> 使用 Theme_NoTitleBar theme。</p>

<p>由于 <a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 文档的不完善，你可以查看源码以更深入了解这些 style 的定义情况：<br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/styles.xml">Android Styles (styles.xml)</a><br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml">Android Themes (themes.xml)</a></p>
]]></content>
  </entry>
  
</feed>
