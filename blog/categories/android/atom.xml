<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Steven Chan]]></title>
  <link href="http://xuanxi.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-09-08T11:16:14+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/07/reading-android-manual/"/>
    <updated>2014-09-07T15:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/07/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出具有良好用户体验的产品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style-1/">Android Style (1)</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/07/29/android-style-2/">Android Style (2)</a><br/>
设计风格，主要是视觉方面。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns-1/">Android Patterns (1)</a><br/>
设计模式，主要是交互方面。</p>

<p><em>注：由于最近找到了 Android Design 的较好的<a href="http://adchs.github.io/">翻译版本</a>，Design 的内容我就直接在那里学习了，这里不再重复翻译：）</em></p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
样式与主题</p>

<p><a href="http://blog.xuanxi.me/blog/2014/08/23/android-processes-and-threads/">Processes and Threads</a><br/>
进程与线程</p>

<p>Service 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/08/26/android-services/">Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-bound-services/">Bound Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-aidl/">AIDL</a></p>

<p>Activity 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-fragments/">Fragments</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-loaders/">Loaders</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-tasks-and-back-stack/">Tasks and Back Stack</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Fragments]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-fragments/"/>
    <updated>2014-09-02T12:07:46+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-fragments</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/fragments.html">http://developer.android.com/guide/components/fragments.html</a></p>

<p>要点：<br/>
1. Design Philosophy（设计哲学）<br/>
2. Creating a Fragment（创建 Fragment） <br/>
3. Managing Fragments（管理 Fragment）<br/>
4. Performing Fragment Transactions（执行 Fragment 事务）<br/>
5. Communicating with the Activity（与 Activity 通信） <br/>
6. Handling the Fragment Lifecycle（维护 Fragment 生命周期）</p>

<p>关键类:<br/>
Fragment<br/>
FragmentManager<br/>
FragmentTransaction</p>

<!--more-->


<p>Fragment 是 Activity 界面的一部分，你可以在一个 Activity 中组合几个 Fragment 来构建 multi-pane 界面，并可以在其它 Activity 重用一个 Fragment。Fragment 有自己的生命周期，可以接收输入事件，可以在 Activity 运行期间被加入或移除（类似“子 Activity”）。</p>

<p>Fragment 必须内嵌到 Activity 里，它的生命周期受 Activity 生命周期的影响。例如 Activity paused，其中所有 Fragment 也 paused；Activity destroyed，其中所有 Fragment 也 destroyed。不过，当 Activity 在运行期间，你可以独立地操作 Fragment，比如加入或移除，而受 Activity 生命周期的影响。</p>

<p>你可以通过布局或代码加入一个 Fragment，也可以使用不带 UI 的 Fragment。</p>

<h2>1. Design Philosophy</h2>

<p>Android 在 3.0 版本引入 Fragment，主要为了支持在大屏幕（如平板）中创建动态和自适应的界面。通过将一个 Activity 布局划分为几个碎片（fragments），你就可以在应用运行期间动态改变界面，以及在一个 Activity 维护的返回栈（back stack）中保存这些变动。</p>

<p>下图展示了 Fragment 分别在平板和手机上的使用：
<img src="/images/fragments.png" alt="fragments" /></p>

<p>你应该将 Fragment 设计成一个标准化的可重用的组件，避免不同 Fragment 之间相互调用。当应用要同时支持手机和平板时，你可通过布局配置来重用 Fragment。</p>

<h2>2. Creating a Fragment</h2>

<p>要创建 Fragment，你必须创建一个 Fragment 类的子类（或者继承现成的 Fragment 子类）。Fragment 的代码看起来与 Activity 非常像，比如都包含以下生命周期方法：onCreate(), onStart(), onPause(), and onStop()。事实上，如果你将一个使用 Activity 的应用修改为使用 Fragment，你可能只需要将 Activity 生命周期方法中的代码复制到对应的 Fragment 生命周期方法中就行。</p>

<p><img src="/images/fragment_lifecycle.png" alt="fragment_lifecycle" /></p>

<p>一般地情况下，你至少需要实现以下生命周期方法：</p>

<p>（1）onCreate()<br/>
系统在创建 Fragment 的时候调用该方法。在这里初始化一些无论 paused 还是 stopped 状态都仍然要保留的数据。</p>

<p>（2）onCreateView()<br/>
系统在第一次绘制 Fragment 界面的时候调用该方法。为了绘制 Fragment 的 UI，此方法必须返回这个 Fragment 布局的根 View。如果不提供界面的话，也可以返回 null。</p>

<p>（3）onPause()<br/>
用户将要离开这个 Fragment 时，系统会首先调用该方法（然而它不总是意味着 Fragment 将被销毁）。通常你应该在这里保存用户的修改，因为用户有可能不会再回来。</p>

<p>大多数应用应当为每一个 Fragment 实现至少上述3个方法，你也可以使用其它的回调方法处理对应阶段的事情。全部的生命周期回调方法将会在后面的 Handlingthe Fragment Lifecycle 章节中讨论。</p>

<p>另外，Android 也提供了几个特定用途的 Fragment 供你继承使用：</p>

<p>DialogFragment<br/>
显示一个浮动对话框。相比普通的 AlertDialog，官方更推荐使用 DialogFragment，因为你可以将 DialogFragment 加入返回栈中，以便返回时再次显示它。</p>

<p>ListFragment<br/>
显示一个列表，与 ListActivity 类似，提供了相关的处理 ListView 的方法，如 onListItemClick()。</p>

<p>PreferenceFragment<br/>
显示列表形式的偏好设置，与 PreferenceActivity 类似，在创建“设置”界面的时候使用。</p>

<h3>Adding a user interface</h3>

<p>Fragment 通常被认为是 Activity 界面的一部分，它将自身布局加入到 Activity 中。要为 Fragment 提供布局，你必须实现 onCreateView() 回调方法，并返回布局的根。</p>

<p>注意：ListFragment 已经有默认的 onCreateView() 实现，并提供了 ListView，如下源码：
```
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,</p>

<pre><code>Bundle savedInstanceState) {
  return inflater.inflate(com.android.internal.R.layout.list_content,
            container, false);
</code></pre>

<p>}
```</p>

<p>onCreateView() 方法提供了 LayoutInflater 对象来加载布局。一个 Fragment 示例如下：
```
public static class ExampleFragment extends Fragment {</p>

<pre><code>@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
                         Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    return inflater.inflate(R.layout.example_fragment, container, false);
}
</code></pre>

<p>}
```
另外，onCreateView() 中的 container 参数是 Activity 布局中用来插入 Fragment 布局的 ViewGroup。savedInstanceState 参数是上一次保存的状态（如果作了保存的话）。</p>

<p>inflate (int resource, ViewGroup root, boolean attachToRoot) 方法的参数说明如下：</p>

<p>resource：布局的 id。</p>

<p>root：布局的参考父 View，如果 attachToRoot 为 true，就将它作为布局的新 root 一并返回；如果 attachToRoot 为 false，就将它的 LayoutParams 参数应用到布局本来的 root。这里必须将 onCreateView() 提供的 container 传进来，以获得 container 的 LayoutParams 参数，并应用到 Fragment 布局的 root 上，以便 Fragment 布局可以正确地插入到 Activity 布局中。</p>

<p>attachToRoot：介绍如 root 参数所述。在 onCreateView() 中的情况是 false，因为系统已经实现将布局插入到 container 中，没必要把 container 重复加入到 Fragment 布局。</p>

<p>现在，你已经知道怎样定义一个 Fragment，下一节将介绍怎样将这个 Fragment 加入 Activity 中。</p>

<h3>Adding a fragment to an activity</h3>

<p>有两种方式将 Fragment 加入到 Activity 中：</p>

<p>（1）通过 <code>&lt;fragment&gt;</code> 标签</p>

<p>```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:orientation="horizontal"
android:layout_width="match_parent"
android:layout_height="match_parent"&gt;
&lt;fragment android:name="com.example.news.ArticleListFragment"
        android:id="@+id/list"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="match_parent" /&gt;
&lt;fragment android:name="com.example.news.ArticleReaderFragment"
        android:id="@+id/viewer"
        android:layout_weight="2"
        android:layout_width="0dp"
        android:layout_height="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
<code>``
</code>android:name<code>属性指定了 Fragment 类。系统在创建这个 Activity 时，会依次调用 Fragment 的 onCreateView() 方法以获得 Fragment 的实际布局，然后将布局直接替换对应的</code><fragment>` 元素。</p>

<p>注意：需要为每个 Fragment 指定一个唯一标识，以便系统使用这个标识来做还原操作（在 Activity restarted 的时候），同时你也可能用这个标识来执行事务，比如删除 Fragment。有两种方式提供唯一标识：<br/>
android:id<br/>
android:tag</p>

<p>（2）通过代码</p>

<p>在 Activity 运行过程中，你随时可以加入一个 Fragment，仅需要指定一个父 ViewGroup。</p>

<p>要执行 Fragment 事务（比如加入、移除、替换），你必须使用 FragmentTransaction 中的接口：
<code>
FragmentManager fragmentManager = getFragmentManager()
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
</code>
然后你可以用 add() 方法加入一个 Fragment：
<code>
ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
</code></p>

<p>add() 的第一个参数是父 ViewGroup，第二个参数是要加入的 Fragment。</p>

<p>一旦对 FragmentTransaction 作了改动，你必须调用 commit() 来提交改动。</p>

<h3>Adding a fragment without a UI</h3>

<p>上面的例子介绍了如何加入带界面的 Fragment，不过，你也可以使用不带界面的 Fragment 来处理后台任务。</p>

<p>要加入不带界面的 Fragment，使用 add(Fragment, String) 方法，第二个参数使用 “tag” 而不是 “id”。因为不带界面，所以不用重写 onCreateView()。</p>

<h2>3. Managing Fragments</h2>

<p>管理 Fragment 使用 FragmentManager，在 Activity 中通过 getFragmentManager() 获得 FragmentManager 对象。</p>

<p>在 FragmentManager 中可以做的事情是：</p>

<p>（1）获得 Fragment 对象。findFragmentById() 方法获得带界面的 Fragment；findFragmentByTag() 方法获得不带界面的 Fragment。</p>

<p>（2）从返回栈里弹出 Fragment。使用 popBackStack() 方法，模拟返回命令。</p>

<p>（3）为返回栈变动注册监听器。使用 addOnBackStackChangedListener() 方法。</p>

<p>更多信息请看 <a href="http://developer.android.com/reference/android/app/FragmentManager.html">FragmentManager</a>。</p>

<h2>4. Performing Fragment Transactions</h2>

<p>Fragment 的一个重要功能是可以灵活地响应用户交互，比如加入、移除或替换界面。一组动作称之为一个事务，你可以使用 FragmentTransaction 的接口来运行一个事务。你也可以将事务保存到由 Activity 管理的返回栈中，以便让用户按顺序返回。</p>

<p>你可以通过 FragmentManager 对象来获得 FragmentTransaction 实例：
<code>
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
</code>
之后通过 add()、remove() 或 replace() 方法来响应交互，最后调用 commit() 来提交。</p>

<p>不过，在你调用 commit() 之前，你可能需要调用 addToBackStack() 来使用返回栈，这样，在点击虚拟返回按键时，会返回到上一次的 Fragment 状态。</p>

<p>例如，下面的代码展示了如何用一个 Fragment 替换现有的 Fragment，并将状态保存到返回栈中：
```
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();</p>

<p>// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);</p>

<p>// Commit the transaction
transaction.commit();
```</p>

<h2>5. Communicating with the Activity</h2>

<p>虽然 Fragment 的实现是独立于 Activity 的，但在任何时候，一个实例化的 Fragment 都会与当前绑定的 Activity 相关，这样就涉及到与 Activity 通信的问题。</p>

<p>比如 Fragment 里可以通过 getActivity() 方法来访问 Activity：
<code>
View listView = getActivity().findViewById(R.id.list);
</code>
同样，Activity 也可以在 Fragment 里调用 findFragmentById() 或 findFragmentByTag() 来获得 Fragment 实例：
<code>
ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
</code></p>

<h3>Creating event callbacks to the activity</h3>

<p>某些情况下，你可能需要让 Activity 响应 Fragment 中的事件，一个好方法是，在 Fragment 中声明一个回调接口，在 Activity 中实现这个接口。</p>

<p>比如，一个新闻应用的 Activity 中有两个 Fragment，一个展示列表（A），一个展示详情（B），当 A 的列表项被点击，A 必须告诉 Activity 这个点击事件，并由 Activity 去通知 B 加载详情数据。这个例子中，A 定义了一个 OnArticleSelectedListener 接口：
```
public static class FragmentA extends ListFragment {</p>

<pre><code>...
// Container Activity must implement this interface
public interface OnArticleSelectedListener {
    public void onArticleSelected(Uri articleUri);
}
...
</code></pre>

<p>}
<code>
为了确认 Activity 是否实现了接口，可以在 onAttach() 中做一个转换处理：
</code>
public static class FragmentA extends ListFragment {</p>

<pre><code>OnArticleSelectedListener mListener;
...
@Override
public void onAttach(Activity activity) {
    super.onAttach(activity);
    try {
        mListener = (OnArticleSelectedListener) activity;
    } catch (ClassCastException e) {
        throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
    }
}
...
</code></pre>

<p>}
```
如果没实现接口，就会抛出 ClassCastException 异常。</p>

<p>接着，就可以在触发事件的地方调用接口了：
```
public static class FragmentA extends ListFragment {</p>

<pre><code>OnArticleSelectedListener mListener;
...
@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    // Append the clicked item's row ID with the content provider Uri
    Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
    // Send the event and Uri to the host activity
    mListener.onArticleSelected(noteUri);
}
...
</code></pre>

<p>}
```</p>

<h3>Adding items to the Action Bar</h3>

<p>（略）</p>

<h2>6. Handling the Fragment Lifecycle</h2>

<p>管理 Fragment 的生命周期，在大多地方与管理 Activity 的生命周期相似。一个 Fragment 的生命状态有以下三种：</p>

<p>（1）Resumed<br/>
Fragment 可见。</p>

<p>（2）Paused<br/>
另一个 Activity 处于前台并拥有焦点，但 Fragment 所在的 Activity 仍然可见（比如前台 Activity 有部分透明）。</p>

<p>（3）Stopped<br/>
Fragment 不可见，要么是宿主 Activity 处于 stopped 状态，要么是这个 Fragment 被移除（如用户滑动到下一个 Fragment）并处于后台堆栈中。stopped 状态的 Fragment 仍然生存，所有的状态和成员信息都被系统保留着。如果宿主 Activity 被销毁，Fragment 也同时被销毁。</p>

<p>下图为 Activity 生命周期与 Fragment 生命周期的对应关系：
<img src="/images/activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle" /></p>

<p>跟 Activity 一样，你可以使用 Boundle 来保存 Fragment 的状态，万一 Activity 所在进程被杀掉了，你就可以在重建 Activity 的时候还原 Fragment 的状态。你可以在 onSaveInstanceState() 里保存状态，并在 onCreate() 、onCreateView() 或 onActivityCreated() 中恢复状态。</p>

<h3>Coordinating with the activity lifecycle</h3>

<p>onAttach()<br/>
当 Fragment 开始与 Activity 建立关联时被调用，Activity 实例被传进来。</p>

<p>onCreateView()<br/>
当 Fragment UI 与 Activity 布局建立关联时被调用。</p>

<p>onActivityCreated()<br/>
在 Activity 的 onCreate() 方法返回之后被调用。</p>

<p>onDestroyView()<br/>
Called when the view hierarchy associated with the fragment is being removed.</p>

<p>onDetach()<br/>
Called when the fragment is being disassociated from the activity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android AIDL]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/28/android-aidl/"/>
    <updated>2014-08-28T10:13:19+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/28/android-aidl</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/aidl.html">http://developer.android.com/guide/components/aidl.html</a></p>

<p>AIDL 与其它 IDLs（接口定义语言）类似，它允许你定义客户端和服务端都能够识别的编程接口，然后通过 IPC 就可以实现两端的通信。不过，在使用 AIDL 之前，你应该思考是否一定要采用 AIDL：如果你不需要跨进程通信，那么直接实现 Binder 即可；如果你需要跨进程通信，但不要求处理多线程任务，那么使用 Messenger 即可。</p>

<p>在你开始设计 AIDL 接口之前，要意识到接口调用就是函数调用，这涉及到执行线程的问题，你不能假设调用在什么线程上执行，而事实上，这取决于调用源自本地进程还是远程进程：<br/>
（1）在本地进程调用的话，接口在调用者所在线程上执行。比如，如果在 UI 线程调用，就在 UI 线程执行。不过，这样的话就没必要用到 AIDL 了，而应该直接用 Binder。（这样说来，AIDL 其实也可以用在非 IPC 场景？）<br/>
（2）从远程进程调用的话，系统会在本地进程中建立一个线程池，并在线程池中取出线程来执行。要注意处理线程安全。<br/>
（3）The oneway keyword modifies the behavior of remote calls. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the Binder thread pool as a normal remote call. If oneway is used with a local call, there is no impact and the call is still synchronous.</p>

<!--more-->


<h2>1. Defining an AIDL Interface</h2>

<h3>1.1 Create the .aidl file</h3>

<p>AIDL 使用 Java 语法来声明接口，接口可以是一个或多个带参数和返回值的方法，这些参数和返回值可以是任何类型，甚至是其他 AIDL 生成的接口。</p>

<p>AIDL 默认支持以下数据类型：<br/>
（1）所有 Java 基本类型（such as int, long, char, boolean, and so on）<br/>
（2）String<br/>
（3）CharSequence<br/>
（4）List<br/>
All elements in the List must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. A List may optionally be used as a &ldquo;generic&rdquo; class (for example, List<String>). The actual concrete class that the other side receives is always an ArrayList, although the method is generated to use the List interface.<br/>
（5）Map<br/>
All elements in the Map must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. Generic maps, (such as those of the form Map&lt;String,Integer> are not supported. The actual concrete class that the other side receives is always a HashMap, although the method is generated to use the Map interface.</p>

<p>如果不是上面所列举的类型，你就需要使用 import 声明。</p>

<p>下面是一个 .aidl 例子：
```
// IRemoteService.aidl
package com.example.android;</p>

<p>// Declare any non-default types here with import statements</p>

<p>/<em>* Example service interface </em>/
interface IRemoteService {</p>

<pre><code>/** Request the process ID of this service, to do evil things with it. */
int getPid();

/** Demonstrates some basic types that you can use as parameters
 * and return values in AIDL.
 */
void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
        double aDouble, String aString);
</code></pre>

<p>}
```
只要将定义好的 .aidl 文件放入 src/ directory 路径下，SDK 就会在构建工程时自动生成 IBinder 接口文件在 gen/ directory，生成的文件名与 .aidl 文件名一样，并以 .java 为扩展名。</p>

<p>如果你使用 Eclipse，并打开了自动构建选项，IBinder 接口文件会立即生成。</p>

<h3>1.2 Implement the interface</h3>

<p>在上一步生成的接口文件中包含了一个 Stub 子类，它是 .aidl 接口的抽象实现。Stub 同时定义了一些辅助方法，尤其是 asInterface()，这个方法在客户端会使用到，用于返回 IBinder 对象。</p>

<p>接下来是实现 Stub 类：
```
private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {</p>

<pre><code>public int getPid(){
    return Process.myPid();
}
public void basicTypes(int anInt, long aLong, boolean aBoolean,
    float aFloat, double aDouble, String aString) {
    // Does nothing
}
</code></pre>

<p>};
```
在实现 AIDL 接口时还有几点要注意的：<br/>
（1）接口不保证会在（Service 所在的本地进程的）主线程上执行，因此，你一开始就应该考虑多线程的问题，以确保线程安全。<br/>
（2）默认情况下，RPC（远程过程调用，是 IPC 的一种形式）是同步的，如果你确定调用是耗时的，就不应该在主线程上调用，而应该在工作线程上调用。<br/>
（3）远程接口上的异常不会传递到调用方法上。</p>

<h3>1.3 Expose the interface to clients</h3>

<p>一旦实现了 Stub，你就可以将它暴露给客户端了。在 Service 的 onBind() 方法返回 Stub 对象。
```
public class RemoteService extends Service {</p>

<pre><code>@Override
public void onCreate() {
    super.onCreate();
}

@Override
public IBinder onBind(Intent intent) {
    // Return the interface
    return mBinder;
}

private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
    public int getPid(){
        return Process.myPid();
    }
    public void basicTypes(int anInt, long aLong, boolean aBoolean,
        float aFloat, double aDouble, String aString) {
        // Does nothing
    }
};
</code></pre>

<p>}
```
同时，需要将 .aidl 文件放在客户端工程的 src/ directory 中，以便生成 Java 形式的接口文件。</p>

<p>现在，当客户端调用 bindService() 去连接 Service 时，客户端的 onServiceConnected() 回调方法里会得到 Service 在 onBind() 中返回的 mBinder 对象。</p>

<p>当客户端从 onServiceConnected() 中得到 IBinder 对象后，还需要用 YourServiceInterface.Stub.asInterface(service) 方法将 IBinder 转换为 YourServiceInterface 类型（也就是上面生成的 Java 类），这样才能调用定义的接口。如以下代码：</p>

<p>```
IRemoteService mIRemoteService;
private ServiceConnection mConnection = new ServiceConnection() {</p>

<pre><code>// Called when the connection with the service is established
public void onServiceConnected(ComponentName className, IBinder service) {
    // Following the example above for an AIDL interface,
    // this gets an instance of the IRemoteInterface, which we can use to call on the service
    mIRemoteService = IRemoteService.Stub.asInterface(service);
}

// Called when the connection with the service disconnects unexpectedly
public void onServiceDisconnected(ComponentName className) {
    Log.e(TAG, "Service has unexpectedly disconnected");
    mIRemoteService = null;
}
</code></pre>

<p>};
```</p>

<h2>2. Passing Objects over IPC</h2>

<p>通过 IPC，你可以将一个对象传输到另一个进程。Android 提供了 Parcelable 来实现这个传输过程：Parcelable 将对象拆解为有序的基本类型，装载到 Parcel 上，然后在其它进程重新组装为对象。</p>

<p>创建支持 Parcelable 协议的类，要做以下几点：</p>

<p>（1）实现 Parcelable 接口。<br/>
（2）实现 writeToParcel 方法，将数据写入 Parcel。<br/>
（3）增加一个静态字段——CREATOR，实现 Parcelable.Creator 接口。<br/>
（4）最后，创建 .aidl 文件，在其中声明这个 Parcelable 类。</p>

<p>下面的 Rect.aidl 文件中声明了一个 Parcelable 类：
```
package android.graphics;</p>

<p>// Declare Rect so AIDL can find it and knows that it implements
// the parcelable protocol.
parcelable Rect;
```</p>

<p>下面是一个实现 Parcelable 协议的例子：
```
import android.os.Parcel;
import android.os.Parcelable;</p>

<p>public final class Rect implements Parcelable {</p>

<pre><code>public int left;
public int top;
public int right;
public int bottom;

public static final Parcelable.Creator&lt;Rect&gt; CREATOR = new
</code></pre>

<p>Parcelable.Creator<Rect>() {</p>

<pre><code>    public Rect createFromParcel(Parcel in) {
        return new Rect(in);
    }

    public Rect[] newArray(int size) {
        return new Rect[size];
    }
};

public Rect() {
}

private Rect(Parcel in) {
    readFromParcel(in);
}

public void writeToParcel(Parcel out) {
    out.writeInt(left);
    out.writeInt(top);
    out.writeInt(right);
    out.writeInt(bottom);
}

public void readFromParcel(Parcel in) {
    left = in.readInt();
    top = in.readInt();
    right = in.readInt();
    bottom = in.readInt();
}
</code></pre>

<p>}
```
这个 Recent 类要处理的数据比较简单（都是整型），你可以查看 <a href="http://developer.android.com/reference/android/os/Parcel.html">Parcel</a> 支持的其它数据类型。</p>

<h2>3. Calling an IPC Method</h2>

<p>下面是调用远程接口的步骤：</p>

<p>（1）将 .aidl 文件放置到源码目录下。<br/>
（2）声明 IBinder 对象。<br/>
（3）实现 ServiceConnection。<br/>
（4）调用 Context.bindService()。<br/>
（5）在 onServiceConnected() 中调用 YourInterfaceName.Stub.asInterface((IBinder)service) 得到 IBinder 对象。<br/>
（6）到这步，你就可以使用接口方法了。注意，你应该捕获 DeadObjectException。<br/>
（7）要断开连接，调用 Context.unbindService()。</p>

<p>A few comments on calling an IPC service:<br/>
Objects are reference counted across processes.<br/>
You can send anonymous objects as method arguments.</p>

<p>下面是使用 AIDL 接口的例子：
```
public static class Binding extends Activity {</p>

<pre><code>/** The primary interface we will be calling on the service. */
IRemoteService mService = null;
/** Another interface we use on the service. */
ISecondary mSecondaryService = null;

Button mKillButton;
TextView mCallbackText;

private boolean mIsBound;

/**
 * Standard initialization of this activity.  Set up the UI, then wait
 * for the user to poke it before doing anything.
 */
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.remote_service_binding);

    // Watch for button clicks.
    Button button = (Button)findViewById(R.id.bind);
    button.setOnClickListener(mBindListener);
    button = (Button)findViewById(R.id.unbind);
    button.setOnClickListener(mUnbindListener);
    mKillButton = (Button)findViewById(R.id.kill);
    mKillButton.setOnClickListener(mKillListener);
    mKillButton.setEnabled(false);

    mCallbackText = (TextView)findViewById(R.id.callback);
    mCallbackText.setText("Not attached.");
}

/**
 * Class for interacting with the main interface of the service.
 */
private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // This is called when the connection with the service has been
        // established, giving us the service object we can use to
        // interact with the service.  We are communicating with our
        // service through an IDL interface, so get a client-side
        // representation of that from the raw service object.
        mService = IRemoteService.Stub.asInterface(service);
        mKillButton.setEnabled(true);
        mCallbackText.setText("Attached.");

        // We want to monitor the service for as long as we are
        // connected to it.
        try {
            mService.registerCallback(mCallback);
        } catch (RemoteException e) {
            // In this case the service has crashed before we could even
            // do anything with it; we can count on soon being
            // disconnected (and then reconnected if it can be restarted)
            // so there is no need to do anything here.
        }

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_connected,
                Toast.LENGTH_SHORT).show();
    }

    public void onServiceDisconnected(ComponentName className) {
        // This is called when the connection with the service has been
        // unexpectedly disconnected -- that is, its process crashed.
        mService = null;
        mKillButton.setEnabled(false);
        mCallbackText.setText("Disconnected.");

        // As part of the sample, tell the user what happened.
        Toast.makeText(Binding.this, R.string.remote_service_disconnected,
                Toast.LENGTH_SHORT).show();
    }
};

/**
 * Class for interacting with the secondary interface of the service.
 */
private ServiceConnection mSecondaryConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // Connecting to a secondary interface is the same as any
        // other interface.
        mSecondaryService = ISecondary.Stub.asInterface(service);
        mKillButton.setEnabled(true);
    }

    public void onServiceDisconnected(ComponentName className) {
        mSecondaryService = null;
        mKillButton.setEnabled(false);
    }
};

private OnClickListener mBindListener = new OnClickListener() {
    public void onClick(View v) {
        // Establish a couple connections with the service, binding
        // by interface names.  This allows other applications to be
        // installed that replace the remote service by implementing
        // the same interface.
        bindService(new Intent(IRemoteService.class.getName()),
                mConnection, Context.BIND_AUTO_CREATE);
        bindService(new Intent(ISecondary.class.getName()),
                mSecondaryConnection, Context.BIND_AUTO_CREATE);
        mIsBound = true;
        mCallbackText.setText("Binding.");
    }
};

private OnClickListener mUnbindListener = new OnClickListener() {
    public void onClick(View v) {
        if (mIsBound) {
            // If we have received the service, and hence registered with
            // it, then now is the time to unregister.
            if (mService != null) {
                try {
                    mService.unregisterCallback(mCallback);
                } catch (RemoteException e) {
                    // There is nothing special we need to do if the service
                    // has crashed.
                }
            }

            // Detach our existing connection.
            unbindService(mConnection);
            unbindService(mSecondaryConnection);
            mKillButton.setEnabled(false);
            mIsBound = false;
            mCallbackText.setText("Unbinding.");
        }
    }
};

private OnClickListener mKillListener = new OnClickListener() {
    public void onClick(View v) {
        // To kill the process hosting our service, we need to know its
        // PID.  Conveniently our service has a call that will return
        // to us that information.
        if (mSecondaryService != null) {
            try {
                int pid = mSecondaryService.getPid();
                // Note that, though this API allows us to request to
                // kill any process based on its PID, the kernel will
                // still impose standard restrictions on which PIDs you
                // are actually able to kill.  Typically this means only
                // the process running your application and any additional
                // processes created by that app as shown here; packages
                // sharing a common UID will also be able to kill each
                // other's processes.
                Process.killProcess(pid);
                mCallbackText.setText("Killed service process.");
            } catch (RemoteException ex) {
                // Recover gracefully from the process hosting the
                // server dying.
                // Just for purposes of the sample, put up a notification.
                Toast.makeText(Binding.this,
                        R.string.remote_call_failed,
                        Toast.LENGTH_SHORT).show();
            }
        }
    }
};

// ----------------------------------------------------------------------
// Code showing how to deal with callbacks.
// ----------------------------------------------------------------------

/**
 * This implementation is used to receive callbacks from the remote
 * service.
 */
private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {
    /**
     * This is called by the remote service regularly to tell us about
     * new values.  Note that IPC calls are dispatched through a thread
     * pool running in each process, so the code executing here will
     * NOT be running in our main thread like most other things -- so,
     * to update the UI, we need to use a Handler to hop over there.
     */
    public void valueChanged(int value) {
        mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));
    }
};

private static final int BUMP_MSG = 1;

private Handler mHandler = new Handler() {
    @Override public void handleMessage(Message msg) {
        switch (msg.what) {
            case BUMP_MSG:
                mCallbackText.setText("Received from service: " + msg.arg1);
                break;
            default:
                super.handleMessage(msg);
        }
    }

};
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Bound Services]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/28/android-bound-services/"/>
    <updated>2014-08-28T10:01:42+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/28/android-bound-services</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/bound-services.html">http://developer.android.com/guide/components/bound-services.html</a></p>

<p>Bound Service（绑定的服务）是“客户端-服务端”模型中的服务端部分（下文中提到的客户端和使用服务的其它组件是一个意思），它接收其它组件的服务请求并返回处理结果。它的典型使用场景是为其它组件提供有交互的服务，而并不是在后台（像 Started Service 那样）长期运行。另外一个重要作用是 IPC。</p>

<p>在深入 Bound Service 之前，最好先了解 <a href="http://blog.xuanxi.me/blog/2014/08/26/android-services/">Services</a> 的内容。</p>

<!--more-->


<h2>1. The Basics</h2>

<p>组件通过 bindService() 方法绑定 Service，同时需要实现一个 ServiceConnection，其中的 onServiceConnected() 方法用来传递 IBinder 对象，而 IBinder 对象就是“客户端-服务端”交互的接口对象。</p>

<p>Android 支持多个组件同时绑定一个 Service，不过，只在第一个组件绑定时系统会调用一次 onBind()，后面的绑定会直接获得 IBinder 对象而不需要再次调 onBind()。</p>

<p>注意： <br/>
Service 可以同时被 start 和 bind，如果这样，你需要同时实现 onBind() 和 onStartCommand()，并且只有在 unbind 和 stop 之后才会被销毁。常见的例子如音乐播放器，既需要在离开界面后在后台播放（start 方式），也需要在有界面的时候控制播放（bind 方式）。</p>

<h2>2. Creating a Bound Service</h2>

<p>Service 通过 IBinder 来提供对外接口，以下为三种接口定义方式：</p>

<p>（1）继承 Binder 类<br/>
适用于同应用同进程内绑定 Service 的情况。Binder 类实现了 IBinder 接口。</p>

<p>（2）使用 Messenger<br/>
适用于简单的 IPC，单线程执行任务。上层使用 Handler 和 Message 来运作，底层基于 AIDL。</p>

<p>（3）使用 AIDL<br/>
标准的 IPC。相比 Messenger，AIDL 支持多线程任务，但要注意处理线程安全问题。关于 AIDL 的详细介绍见 <a href="http://blog.xuanxi.me/blog/2014/08/28/android-aidl/">AIDL</a>。</p>

<h3>Extending the Binder class</h3>

<p>如果仅在同应用同进程内使用 Service，可以通过实现 Binder 来提供对外接口。</p>

<p>下面是具体的实现步骤：<br/>
（1）在 Service 内部定义一个 Binder 类，类内部提供公共方法供客户端访问，可以通过这个方法返回 Service 对象，或者 Service 所持有的其它对象。  <br/>
（2）使用上一步的 Binder 类创建一个 IBinder 对象，并在 onBind() 返回这个对象。<br/>
（3）在客户端中，通过 onServiceConnected() 方法得到 IBinder 对象，用这个 IBinder 对象就可以访问 Service 中的字段和方法了。</p>

<p>下面是一个 Bound Service 的实现：
```
public class LocalService extends Service {</p>

<pre><code>// Binder given to clients
private final IBinder mBinder = new LocalBinder();
// Random number generator
private final Random mGenerator = new Random();

/**
 * Class used for the client Binder.  Because we know this service always
 * runs in the same process as its clients, we don't need to deal with IPC.
 */
public class LocalBinder extends Binder {
    LocalService getService() {
        // Return this instance of LocalService so clients can call public methods
        return LocalService.this;
    }
}

@Override
public IBinder onBind(Intent intent) {
    return mBinder;
}

/** method for clients */
public int getRandomNumber() {
  return mGenerator.nextInt(100);
}
</code></pre>

<p>}
```
LocalBinder 提供了 getService() 方法让客户端得到 LocalService 对象，这样，客户端就可以使用 Service 的公共接口了。</p>

<p>下面的代码展示了一个 Activity 绑定 LocalService，并在点击按钮时调用 getRandomNumber() 接口方法：
```
public class BindingActivity extends Activity {</p>

<pre><code>LocalService mService;
boolean mBound = false;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
}

@Override
protected void onStart() {
    super.onStart();
    // Bind to LocalService
    Intent intent = new Intent(this, LocalService.class);
    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
}

@Override
protected void onStop() {
    super.onStop();
    // Unbind from the service
    if (mBound) {
        unbindService(mConnection);
        mBound = false;
    }
}

/** Called when a button is clicked (the button in the layout file attaches to
  * this method with the android:onClick attribute) */
public void onButtonClick(View v) {
    if (mBound) {
        // Call a method from the LocalService.
        // However, if this call were something that might hang, then this request should
        // occur in a separate thread to avoid slowing down the activity performance.
        int num = mService.getRandomNumber();
        Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show();
    }
}

/** Defines callbacks for service binding, passed to bindService() */
private ServiceConnection mConnection = new ServiceConnection() {

    @Override
    public void onServiceConnected(ComponentName className,
            IBinder service) {
        // We've bound to LocalService, cast the IBinder and get LocalService instance
        LocalBinder binder = (LocalBinder) service;
        mService = binder.getService();
        mBound = true;
    }

    @Override
    public void onServiceDisconnected(ComponentName arg0) {
        mBound = false;
    }
};
</code></pre>

<p>}
```</p>

<h3>Using a Messenger</h3>

<p>对于简单的 IPC 任务，使用 Messenger 比使用 AIDL 更简单，因为 Messenger 使用一个消息队列来处理所有服务请求，而纯粹的 AIDL 需要处理并发的服务请求。</p>

<p>以下是实现要点：<br/>
（1）Service 内部定义一个 Handler 类，用来接收并处理消息。<br/>
（2）创建一个 Messenger 对象，创建时还要使用上一步的 Handler 对象。<br/>
（3）在 onBind() 中由 Messenger 创建 IBinder 对象，返回给客户端。<br/>
（4）客户端使用 IBinder 实例化一个 Messenger，用来向 Service 发送消息。<br/>
（5）Service 接收消息，并在 Handler 中处理。</p>

<p>可见，使用 Messenger 的话，Service 不能提供方法给客户端直接调用，而只能通过消息来交互。</p>

<p>Service 示例：<br/>
```
public class MessengerService extends Service {</p>

<pre><code>/** Command to the service to display a message */
static final int MSG_SAY_HELLO = 1;

/**
 * Handler of incoming messages from clients.
 */
class IncomingHandler extends Handler {
    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_SAY_HELLO:
                Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show();
                break;
            default:
                super.handleMessage(msg);
        }
    }
}

/**
 * Target we publish for clients to send messages to IncomingHandler.
 */
final Messenger mMessenger = new Messenger(new IncomingHandler());

/**
 * When binding to the service, we return an interface to our messenger
 * for sending messages to the service.
 */
@Override
public IBinder onBind(Intent intent) {
    Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
    return mMessenger.getBinder();
}
</code></pre>

<p>}
```</p>

<p>客户端示例：<br/>
```
public class ActivityMessenger extends Activity {</p>

<pre><code>/** Messenger for communicating with the service. */
Messenger mService = null;

/** Flag indicating whether we have called bind on the service. */
boolean mBound;

/**
 * Class for interacting with the main interface of the service.
 */
private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className, IBinder service) {
        // This is called when the connection with the service has been
        // established, giving us the object we can use to
        // interact with the service.  We are communicating with the
        // service using a Messenger, so here we get a client-side
        // representation of that from the raw IBinder object.
        mService = new Messenger(service);
        mBound = true;
    }

    public void onServiceDisconnected(ComponentName className) {
        // This is called when the connection with the service has been
        // unexpectedly disconnected -- that is, its process crashed.
        mService = null;
        mBound = false;
    }
};

public void sayHello(View v) {
    if (!mBound) return;
    // Create and send a message to the service, using a supported 'what' value
    Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
    try {
        mService.send(msg);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
}

@Override
protected void onStart() {
    super.onStart();
    // Bind to the service
    bindService(new Intent(this, MessengerService.class), mConnection,
        Context.BIND_AUTO_CREATE);
}

@Override
protected void onStop() {
    super.onStop();
    // Unbind from the service
    if (mBound) {
        unbindService(mConnection);
        mBound = false;
    }
}
</code></pre>

<p>}
```
上面的例子没有展示 Service 如何向客户端做出响应，如果你要接收响应，可参考 <a href="http://developer.android.com/resources/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.html">MessengerService.java</a> 和 <a href="http://developer.android.com/resources/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.html">MessengerServiceActivities.java</a>。</p>

<h2>3. Binding to a Service</h2>

<p>组件调用 bindService() 绑定 Service，系统随后会调用 Service 的 onBind()，并返回 IBinder 对象用于与客户端交互。</p>

<p>绑定操作是异步的，bindService() 方法调用后会立即返回，而且不会带回 IBinder 对象。要得到 IBinder 对象，客户端必须实现 ServiceConnection 类，并在它的回调方法中得到 IBinder。</p>

<p>注意：<br/>
四大应用组件中，BroadcastReceiver 不能绑定 Service。</p>

<p>（bind 的具体实现略）</p>

<h3>补充说明</h3>

<p>（1）在客户端调用 Service 接口的时候，应该捕获 DeadObjectException 异常，以确认与 Service 的连接是否中断，这是唯一一个远程接口会抛出的异常。<br/>
（2）Objects are reference counted across processes.（Service 对象的引用计数是跨进程的？）  <br/>
（3）应该成对使用 bind 和 unbind 方法。可以 bind during onStart() and unbind during onStop()，或者 bind during onCreate() and unbind during onDestroy().<br/>
（4）你不应该 bind and unbind during your activity&rsquo;s onResume() and onPause()，因为 onResume() 和 onPause() 这两个方法在每次生命周期改变时都会被调用，你不得不控制后台处理的时间在最小范围，并且如果多个 Activity 切换（这些 Activity 都绑定了 Service），bind 和 unbind 就会频繁执行，这明显是不好的。</p>

<h2>4. Managing the Lifecycle of a Bound Service</h2>

<p><img src="/images/service_binding_tree_lifecycle.png" alt="service_binding_tree_lifecycle" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Services]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/26/android-services/"/>
    <updated>2014-08-26T17:14:33+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/26/android-services</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/services.html">http://developer.android.com/guide/components/services.html</a></p>

<p>推荐文章：<br/>
<a href="http://blog.csdn.net/guolin_blog/article/details/11952435">Android Service完全解析，关于服务你所需知道的一切</a></p>

<p>本文包括以下几个部分：<br/>
1. The Basics<br/>
2. Creating a Started Service<br/>
3. Creating a Bound Service<br/>
4. Sending Notifications to the User<br/>
5. Running a Service in the Foreground<br/>
6. Managing the Lifecycle of a Service</p>

<!--more-->


<p>Service 是 Android 提供的四大应用组件之一，它与界面无关，用在后台执行长时间的操作。无论同一个应用还是其它应用的组件都可以启动 Service。你可以通过绑定的方式来和 Service 进行交互，以及实现进程间通信（IPC）。比如，你可以使用 Service 来处理网络请求、播放音乐、读写文件等，所有这些操作都在后台进行，而无需界面支持。</p>

<p>有两种形式的 Service：</p>

<p>（1）Started<br/>
通过 startService() 启动。这种 Service 一旦被启动，就会一直在后台运行，即使启动它的组件已经销毁。通常，它被用来执行单一的不带返回的操作，比如下载或上传文件，当下载或上传成功后，它就自动退出了。</p>

<p>（2）Bound<br/>
通过 bindService() 启动。这种 Service 用来实现“客户端-服务端”的模型——客户端发出请求，服务端执行请求并返回结果。</p>

<p>值得注意的是，一个 Service 可以同时被 start 和 bind，分别对应 onStartCommand() 和 onBind() 方法。无论是 start 方式还是 bind 方式，任何组件都可以使用 Intent 来启动 Service，就像启动 Activity 一样。不过，你可以在 manifest 文件中将 Service 设置为私有（<code>android:exported="false"</code>），这样就可以阻止其它应用的访问了。</p>

<p>注意：Service 运行在 UI 线程上，你应该创建工作线程来执行耗时操作。</p>

<h2>1. The Basics</h2>

<p>要使用 Service，你应该派生 Service 的子类，并实现相关的方法：</p>

<h4>onStartCommand()</h4>

<p>startService() 方式对应的方法，使用 stopSelf()（内部调用） 或 stopService()（其它组件调用） 来停止 Service。</p>

<h4>onBind()</h4>

<p>bindService() 方式对应的方法。无论是否采用绑定的方式，你都必须实现该方法，如果不希望被绑定，这个方法要返回 null。</p>

<h4>onCreate()</h4>

<p>在 onStartCommand() or onBind() 之前调用的方法。在 Service 生命周期内只调用一次。</p>

<h4>onDestroy()</h4>

<p>销毁 Service 的时候被调用。</p>

<h3>（重要）Should you use a service or a thread?</h3>

<p>如果你只希望在界面交互过程中做一些异步操作（异步操作的时间不会长于当前界面的停留时间），就应该考虑使用线程而不是 Service。比如，你只想在一个 Activity 上播放音乐，就可以在 onCreate() 里创建播放线程，在 onStart() 里开始播放，在 onStop() 里停止播放。另外，你应该考虑使用 AsyncTask 或 HandlerThread 来代替传统的 Thread。</p>

<p>官方这里说得太简单，我作一下补充：<br/>
（1）很多人会笼统地去区别 Service 和 Thread，我认为这是不妥的。Service 和 Thread 不是同一个层次的概念，前者是 Android 的组件机制，后者是现代操作系统的执行机制（程序的调度单位），所有的 Service 都运行在线程上，当然，你也可以在 Service 里创建一个 Thread 来执行任务。之所以容易混淆它们，是因为它们都可以用来执行后台任务，即用法相似。<br/>
（2）我们应该从具体使用场景上去比较 Service 和 Thread。比如上面官方给出的只在前台播放音乐的例子，使用 Service 也可以实现（Bound Service + Thread），只不过直接使用 Thread 更轻量级，而使用 Service 明显更麻烦，开销更大。<br/>
（3）当我们需要执行一个长期的后台任务，比如即时通信中的消息接收、心跳检测，使用 “Service + Thread” 比使用 “Activity + Thread” 能获得更长的后台处理周期。因为离开 Activity 就意味着失去对 Thread 的控制，更坏的结果是，应用进入后台进程状态后有可能被杀掉，Thread 也就随之销毁了，而使用 Service 的服务进程不会轻易被杀掉。</p>

<h3>Declaring a service in the manifest</h3>

<p>```
<manifest ... >
  &hellip;
  <application ... ></p>

<pre><code>  &lt;service android:name=".ExampleService" /&gt;
  ...
</code></pre>

<p>  </application>
</manifest>
<code>``
</code>android:name<code>是必需属性，另外还有</code>android:exported<code>、</code>android:permission<code>和</code>android:process` 属性可选。要注意的是，一旦发布了应用，就不要改动 Service 的名字。</p>

<p>官方建议不要为 Service 设置 intent filters，而应该使用显式 Intent 去启动，说是为了应用安全（为什么不安全？？）。如果确实需要设置 intent filters，你必须为 Intent 设置 package。</p>

<p><code>android:exported</code> 属性设置 Service 是否对其它应用开放。</p>

<h2>2. Creating a Started Service</h2>

<p>其它组件通过 startService() 启动 Service，同时可以通过 Intent 带上数据，接着，Service 的 onStartCommand() 会被调用。Service 启动后，执行独立的生命周期，与启动它的组件的生命周期无关。要结束 Service ，可在内部调用 stopSelf()，或其它组件调用 stopService()。</p>

<p>要创建 Started Service，可以继承以下两个类：</p>

<p>（1）Service<br/>
Service 的基础类，运行在主线程上。</p>

<p>（2）IntentService<br/>
Service 的子类，整合了一条工作线程（单线程模型），任务放在 onHandleIntent() 方法里执行。</p>

<h3>Extending the IntentService class</h3>

<p>IntentService 适用于对并发要求不高的情况，它具体做了以下事情：<br/>
（1）创建一条工作线程来执行任务。<br/>
（2）创建一个工作队列，按顺序处理队列中的任务。<br/>
（3）当所有任务处理完后，自动关闭服务。<br/>
（4）提供了默认的 onBind() 实现。<br/>
（5）提供了默认的 onStartCommand() 实现。<br/>
由此可见，对于 IntentService 的使用，你需要做的仅仅是实现 onHandleIntent()，以及提供构造方法。</p>

<p>补充：<br/>
从源码可知，IntentService 只是简单地使用了 HandlerThread 来实现这种单线程模型，任务队列就是线程的消息队列。</p>

<p>（具体实现略）</p>

<h3>Extending the Service class</h3>

<p>如果对并发要求很高，就要用普通的 Service，你可以在 onStartCommand() 里为每个任务创建一条线程，一般情况下使用线程池会比较好。</p>

<p>onStartCommand() 中的返回值告诉系统怎样处理被杀掉的 Service（因内存不足被系统回收），这些返回值起作用的前提是 onStartCommand() 已经执行完毕并返回：</p>

<p>（1）START_NOT_STICKY<br/>
不重建 Service，直到有新的服务请求。</p>

<p>（2）START_STICKY<br/>
重建 Service，并调用 onStartCommand()，但不带有上一次的 intent。适用于长时间运行并等待执行动作的任务，如媒体播放服务。</p>

<p>（3）START_REDELIVER_INTENT<br/>
重建 Service，调用 onStartCommand()，并带有上一次的 intent。适用于立即执行的后台任务，如文件下载。</p>

<p>（具体实现略）</p>

<h3>Starting a Service</h3>

<p>（具体实现略）</p>

<p>要注意的是，多个任务请求会调用多次 onStartCommand()，而关闭只需要一次。</p>

<h3>Stopping a service</h3>

<p>Service 的生命周期需要开发者来管理，即系统不会主动去关闭一个 Service，除非是资源回收，或者使用 IntentService（IntentService 已经在内部调用了 stopSelf()，因此也不需要开发者去关闭）
，所以，需要显式调用 stopSelf() 或 stopService()。而一旦调用了 stopSelf() or stopService()，系统就会尽快销毁这个 Service。</p>

<p>关闭 Service 时要注意一个问题，如果这个 Service 用于处理并发任务（Service 内部使用多线程），不要在一个任务执行完后就关闭 Service（调用 stopSelf() 或 stopService()），因为关闭的时候，可能一个新的服务请求已经进来，可能这个新请求尚未执行完成，就随着关闭操作而被终止了（stopping at the end of the first request would terminate the second one）。除非你可以很好地保证服务请求的次序，保证所有任务都完成后才关闭，或者关闭之前不会有新的请求进来，但这样可能需要在业务流程上做更多的处理。<br/>
官方对这个问题给出了很好的解决办法，就是使用 stopSelf(int)。留意 onStartCommand(Intent intent, int flags, int startId) 中的第三个参数 startId，每次调用都会生成一个唯一的 startId，用于对应本次服务请求。我们在 Service 内部需要关闭 Service 的地方调用 stopSelf(int)，参数是最近一次已经执行完成的服务请求的 startId。如果调用 stopSelf(int) 的时候有新请求进来，那么 stopSelf 中的 startId 和 onStartCommand 中的startId 就会不一致，stopSelf 就不会调用成功。</p>

<h2>3. Creating a Bound Service</h2>

<p>见<a href="http://blog.xuanxi.me/blog/2014/08/28/android-bound-services/">Bound Services</a></p>

<h2>4. Sending Notifications to the User</h2>

<p>Service 一旦启动，可以通过 Toaste 或 Status Bar 来显示一些必要信息，比如告诉用户后台任务已经开始或者结束。</p>

<h2>5. Running a Service in the Foreground</h2>

<p>前台服务是用户希望关注其实时状态的服务。它必须使用通知，并处于 &ldquo;Ongoing&rdquo; heading 下，这样，除非服务被暂停或者退出前台服务，否则不会从通知栏消失（被划掉）。例如，音乐播放应用使用前台进程处理音乐播放，用户可以在通知栏看到播放状态，并提供一些播放操作。</p>

<p>（具体实现略）</p>

<h2>6. Managing the Lifecycle of a Service</h2>

<h3>Implementing the lifecycle callbacks</h3>

<p><img src="/images/service_lifecycle.png" alt="service_lifecycle" /></p>
]]></content>
  </entry>
  
</feed>
