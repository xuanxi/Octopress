<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Steven Chen]]></title>
  <link href="http://xuanxi.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-07-27T18:16:36+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/26/reading-android-manual/"/>
    <updated>2014-07-26T18:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/26/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出实用美观的作品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/ios-design-principles/">iOS Design Principles</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/bars/">iOS UI Framework</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style/">Android Style</a><br/>
Android 视觉设计要点。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns/">Android Patterns</a><br/>
Android 交互设计要点。</p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
风格与主题</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Styles and Themes]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/24/styles-and-themes/"/>
    <updated>2014-07-24T17:50:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/24/styles-and-themes</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/topics/ui/themes.html">http://developer.android.com/guide/topics/ui/themes.html</a></p>

<p>A style is a collection of properties that specify the look and format for a View or window. A style can specify properties such as height, padding, font color, font size, background color, and much more. A style is defined in an XML resource that is separate from the XML that specifies the layout.</p>

<p>一个 style 是某些属性的集合，这些属性定义了 view 或 window 的外观和格式，比如 height、padding、font color、font size、background color 等。</p>

<!--more-->


<p>Styles in Android share a similar philosophy to cascading stylesheets in web design—they allow you to separate the design from the content.</p>

<p>与 web 设计中的 CSS 相似，Android style 的目的是设计与内容分离。</p>

<p>例如，使用 style 的话，你可以将以下代码：
```
&lt;TextView</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="wrap_content"
android:textColor="#00FF00"
android:typeface="monospace"
android:text="@string/hello" /&gt;
</code></pre>

<p><code>
替换为：
</code>
&lt;TextView</p>

<pre><code>style="@style/CodeFont"
android:text="@string/hello" /&gt;    
</code></pre>

<p>```
A theme is a style applied to an entire Activity or application, rather than an individual View (as in the example above). When a style is applied as a theme, every View in the Activity or application will apply each style property that it supports. For example, you can apply the same CodeFont style as a theme for an Activity and then all text inside that Activity will have green monospace font.</p>

<p>theme 就是一个用于 Activity 和 application 的 style，而普通的 style 只用于单独的 view。当 style 被当做 theme 使用之后，在 Activity 或 application 中的所有 view 都会应用该 style 的属性。例如，你可以将一个字体 style 用作一个 Activity 的 theme，然后该 Activity 里的所有文本都会使用这个字体。</p>

<h2>Defining Styles</h2>

<p>To create a set of styles, save an XML file in the res/values/ directory of your project. The name of the XML file is arbitrary, but it must use the .xml extension and be saved in the res/values/ folder.<br/>
The root node of the XML file must be <code>&lt;resources&gt;</code>.</p>

<p>要创建一组 style，首先在 res/values/ 目录下创建一个 xml 文件，文件名可自定义，通常为 styles.xml。<br/>
文件的根节点为 <code>&lt;resoueces&gt;</code>。</p>

<p>以下为一个 style 示例：
```
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;utf-8&rdquo;?>
<resources></p>

<pre><code>&lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt;
    &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt;
    &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt;
    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
    &lt;item name="android:typeface"&gt;monospace&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p></resources>
<code>``
Each child of the</code><resources><code>element is converted into an application resource object at compile-time, which can be referenced by the value in the</code><style>` element&rsquo;s name attribute. This example style can be referenced from an XML layout as @style/CodeFont (as demonstrated in the introduction above).</p>

<p>每个 <code>&lt;resources&gt;</code> 元素的子节点在编译时都被转换为一个应用程序资源对象，其可以通过 <code>&lt;style&gt;</code> 元素的 <code>name</code> 属性的值来引用，如 <code>style="@style/CodeFont"</code>。</p>

<p>The parent attribute in the <code>&lt;style&gt;</code> element is optional and specifies the resource ID of another style from which this style should inherit properties. You can then override the inherited style properties if you want to.</p>

<p><code>&lt;style&gt;</code> 中的 parent 属性是可选的，用来指定另外一个 style 的资源ID，前者继承后者的所有属性。你也可以覆写继承来的 style 属性。</p>

<p>Remember, a style that you want to use as an Activity or application theme is defined in XML exactly the same as a style for a View. A style such as the one defined above can be applied as a style for a single View or as a theme for an entire Activity or application. How to apply a style for a single View or as an application theme is discussed later.</p>

<p>用在 Activity 或应用程序上的 theme 的定义方式和 style 的定义方式是相同的。一个如同上面那样例子中定义的 style 既可以用作一个 View的 style，也可以用作一个 Activity 或应用程序的 theme。</p>

<h3>Inheritance</h3>

<p>The parent attribute in the <code>&lt;style&gt;</code> element lets you specify a style from which your style should inherit properties. You can use this to inherit properties from an existing style and then define only the properties that you want to change or add. You can inherit from styles that you&rsquo;ve created yourself or from styles that are built into the platform. (See Using Platform Styles and Themes, below, for information about inheriting from styles defined by the Android platform.) For example, you can inherit the Android platform&rsquo;s default text appearance and then modify it:</p>

<p>parent 属性让你可以继承一个 style，然后定义你想改变或添加的属性。你可以从自定义的 style 或者平台的 style 中继承：
```</p>

<pre><code>&lt;style name="GreenText" parent="@android:style/TextAppearance"&gt;
    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>```
If you want to inherit from styles that you&rsquo;ve defined yourself, you do not have to use the parent attribute. Instead, just prefix the name of the style you want to inherit to the name of your new style, separated by a period. For example, to create a new style that inherits the CodeFont style defined above, but make the color red, you can author the new style like this:</p>

<p>如果你要继承自定义的 style，不必用到 parent，仅需要把父 style 名字作为新 style 名字的前缀即可，中间用点分隔：
```</p>

<pre><code>&lt;style name="CodeFont.Red"&gt;
    &lt;item name="android:textColor"&gt;#FF0000&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><code>``
Notice that there is no parent attribute in the</code><style>` tag, but because the name attribute begins with the CodeFont style name (which is a style that you have created), this style inherits all style properties from that style. This style then overrides the android:textColor property to make the text red. You can reference this new style as @style/CodeFont.Red.</p>

<p>上面的 style 使用 <code>@style/CodeFont.Red</code> 来引用。</p>

<p>You can continue inheriting like this as many times as you&rsquo;d like, by chaining names with periods. For example, you can extend CodeFont.Red to be bigger, with:</p>

<p>也可以多次继承：
```</p>

<pre><code>&lt;style name="CodeFont.Red.Big"&gt;
    &lt;item name="android:textSize"&gt;30sp&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>```
Note: This technique for inheritance by chaining together names only works for styles defined by your own resources. You can&rsquo;t inherit Android built-in styles this way. To reference a built-in style, such as TextAppearance, you must use the parent attribute.</p>

<p>要注意的是，前缀加点间隔的方法仅使用与自定义的 style，并不适用于平台内建的 style。</p>

<h3>Style Properties</h3>

<p>Now that you understand how a style is defined, you need to learn what kind of style properties—defined by the <item> element—are available. You&rsquo;re probably familiar with some already, such as layout_width and textColor. Of course, there are many more style properties you can use.</p>

<p>接下来，你需要了解在 <code>&lt;style&gt;</code> 的 <code>&lt;item&gt;</code> 元素中可以定义哪些属性值。比如你可能已经知道的 layout_width 和 textColor 等等。</p>

<p>The best place to find properties that apply to a specific View is the corresponding class reference, which lists all of the supported XML attributes. For example, all of the attributes listed in the table of TextView XML attributes can be used in a style definition for a TextView element (or one of its subclasses). One of the attributes listed in the reference is android:inputType, so where you might normally place the android:inputType attribute in an <EditText> element, like this:</p>

<p>要知道某个 view 的所有属性，最好的地方就是它的官方参考文档（比如 TextView 的 &lt;<a href="http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8">http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8</a> XML Attributes 的地方就列出了所有支持的属性，这些属性都可以用在 style 里。</p>

<p>下面以 EditText 的 android:inputType 属性为例子，一般情况你可以在布局中直接使用：
```
&lt;EditText</p>

<pre><code>android:inputType="number"
... /&gt;
</code></pre>

<p><code>
你也可以定义一个 style：
</code></p>



<p><code>
然后你的布局变成这样：
</code>
&lt;EditText</p>

<pre><code>style="@style/Numbers"
... /&gt;
</code></pre>

<p>```
This simple example may look like more work, but when you add more style properties and factor-in the ability to re-use the style in various places, the pay-off can be huge.</p>

<p>这个例子看起来是增加了工作量，但当你的 style 里包含了更多的属性，并且在多个布局中都使用到这个 style 的时候，style 的作用就会凸显。</p>

<p>For a reference of all available style properties, see the R.attr reference. Keep in mind that all View objects don&rsquo;t accept all the same style attributes, so you should normally refer to the specific View class for supported style properties. However, if you apply a style to a View that does not support all of the style properties, the View will apply only those properties that are supported and simply ignore the others.</p>

<p>要知道的是，不是所有的 View 都接受相同的 style 属性，所以你应该先查看所支持的属性。不过，如果一个 style 中包含了 View 不支持的属性，这些属性会被忽略。</p>

<p>Some style properties, however, are not supported by any View element and can only be applied as a theme. These style properties apply to the entire window and not to any type of View. For example, style properties for a theme can hide the application title, hide the status bar, or change the window&rsquo;s background. These kind of style properties do not belong to any View object. To discover these theme-only style properties, look at the R.attr reference for attributes that begin with window. For instance, windowNoTitle and windowBackground are style properties that are effective only when the style is applied as a theme to an Activity or application. See the next section for information about applying a style as a theme.</p>

<p>有些属性不被任何 View 支持，只能用作 theme，比如隐藏应用标题栏，隐藏状态栏，改变窗口背景等。<a href="http://developer.android.com/reference/android/R.attr.html">R.attr</a> 中以 <code>windows</code> 起头的属性就是这样的属性。</p>

<p>Note: Don&rsquo;t forget to prefix the property names in each <code>&lt;item&gt;</code> element with the android: namespace. For example: <code>&lt;item name="android:inputType"&gt;</code>.</p>

<p>注意，每一个属性要使用 <code>android:</code> 作为命名空间。</p>

<h2>Applying Styles and Themes to the UI</h2>

<p>应用 Styles 和 Themes</p>

<p>有两种方式设置一个 style：<br/>
对一个独立的 View，添加 style 属性到你的布局的 View 元素中：
```
&lt;TextView</p>

<pre><code>style="@style/CodeFont"
android:text="@string/hello" /&gt;
</code></pre>

<p><code>
对一个 Activity 或应用，添加 `android:theme` 属性到 Android manifest 的 `&lt;activity&gt;` 或 `&lt;application&gt;` 元素中：
</code>
<application android:theme="@style/CustomTheme">
<activity android:theme="@style/CustomTheme">
```</p>

<h2>Using Platform Styles and Themes</h2>

<p>The Android platform provides a large collection of styles and themes that you can use in your applications. You can find a reference of all available styles in the R.style class. To use the styles listed here, replace all underscores in the style name with a period. For example, you can apply the Theme_NoTitleBar theme with &ldquo;@android:style/Theme.NoTitleBar&rdquo;.</p>

<p>Android 平台提供了大量的 style 和 theme 供你使用。你可以在<a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 类中找到所有可用的 style，只需要用句号替换 style 名称中的下划线即可。例如，你可以通过 <code>@android:style/Theme.NoTitleBar</code> 使用 Theme_NoTitleBar theme。</p>

<p>The R.style reference, however, is not well documented and does not thoroughly describe the styles, so viewing the actual source code for these styles and themes will give you a better understanding of what style properties each one provides. For a better reference to the Android styles and themes, see the following source code:</p>

<p>由于 <a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 文档的不完善，你可以查看源码以更深入了解这些 style 的定义情况：<br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/styles.xml">Android Styles (styles.xml)</a><br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml">Android Themes (themes.xml)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing for Multiple Screens]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens/"/>
    <updated>2014-07-17T22:07:15+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/training/multiscreen/index.html">http://developer.android.com/training/multiscreen/index.html</a></p>

<p>Android powers hundreds of device types with several different screen sizes, ranging from small phones to large TV sets. Therefore, it’s important that you design your application to be compatible with all screen sizes so it’s available to as many users as possible.<br/>
But being compatible with different device types is not enough. Each screen size offers different possibilities and challenges for user interaction, so in order to truly satisfy and impress your users, your application must go beyond merely supporting multiple screens: it must optimize the user experience for each screen configuration.</p>

<p>Android 设备的多样性要求应用的显示要适配多种屏幕尺寸，但仅仅让应用正常显示在多种屏幕上并不足够，因为不同尺寸的屏幕提供不同的交互能力，设计者应该做出适当优化以更好的利用屏幕。</p>

<p>本篇包含以下三部分：<br/>
1. Supporting Different Screen Sizes；<br/>
2. Supporting Different Screen Densities；<br/>
3. Implementing Adaptative UI Flows。</p>

<!--more-->


<p>推荐文章：<br/>
<a href="http://stormzhang.github.io/android/2014/05/16/android-screen-adaptation/">Android 屏幕适配</a></p>

<h2>1. Supporting Different Screen Sizes</h2>

<p>本篇将告诉你如何让应用支持不同尺寸的屏幕，有以下几种办法：<br/>
让布局自适应屏幕<br/>
根据屏幕的配置来加载合适的UI布局<br/>
确保正确的布局应用在正确的设备屏幕上<br/>
提供可以根据屏幕大小自动伸缩的图片</p>

<h3>Use &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo;</h3>

<p>To ensure that your layout is flexible and adapts to different screen sizes, you should use &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo; for the width and height of some view components.</p>

<p>使用 wrap_content 和 match_parent 可以确保布局自适应到不同的屏幕。</p>

<p><img src="/images/layout-hvga.png" alt="layout-hvga" /><br/>
上图中的横竖两种状态时是自动适配屏幕的。</p>

<h3>Use RelativeLayout</h3>

<p>You can construct fairly complex layouts using nested instances of LinearLayout and combinations of &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo; sizes. However, LinearLayout does not allow you to precisely control the spacial relationships of child views; views in a LinearLayout simply line up side-by-side. If you need child views to be oriented in variations other than a straight line, a better solution is often to use a RelativeLayout, which allows you to specify your layout in terms of the spacial relationships between components. For instance, you can align one child view on the left side and another view on the right side of the screen.</p>

<p>LinearLayout 用于简单的线性布局，而 RelativeLayout 提供了更灵活的手段去布置子控件。</p>

<p><img src="/images/relativelayout1.png" alt="relativelayout1" /></p>

<h3>Use Size Qualifiers 使用size限定符</h3>

<p>While those layouts adapt to different screens by stretching the space within and around components, they may not provide the best user experience for each screen size. Therefore, your application should not only implement flexible layouts, but should also provide several alternative layouts to target different screen configurations.</p>

<p>一种布局自适应所有屏幕并不代表提供了最好的用户体验，还要考虑为不同大小的屏幕建立不同的布局，以充分发挥不同尺寸屏幕的各自的优势。</p>

<p>For example, many applications implement the &ldquo;two pane&rdquo; pattern for large screens (the app might show a list of items on one pane and the content on another pane). Tablets and TVs are large enough for both panes to fit simultaneously on screen, but phone screens have to show them separately. So, to implement these layouts, you could have the following files:</p>

<p>举个例子，很多应用都会有两个功能窗口，一个是列表，一个是列表项详情，对于平板或电视的大屏幕，一次就可以展示这两个窗口，而手机屏幕只能展示一个。以下示例使用了一个 layout 布局和一个 layout-large 布局，应用在运行时会根据屏幕大小读取对应的布局：</p>

<p>res/layout/main.xml, single-pane (default) layout:
```
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:orientation="vertical"
android:layout_width="match_parent"
android:layout_height="match_parent"&gt;

&lt;fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>res/layout-large/main.xml, two-pane layout:
```
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:orientation="horizontal"&gt;
&lt;fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/&gt;
&lt;fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<h3>Use the Smallest-width Qualifier 使用最小宽度限定符</h3>

<p>One of the difficulties developers had in pre-3.2 Android devices was the &ldquo;large&rdquo; screen size bin, which encompasses the Dell Streak, the original Galaxy Tab, and 7" tablets in general. However, many applications may want to show different layouts for different devices in this category (such as for 5" and 7" devices), even though they are all considered to be &ldquo;large&rdquo; screens. That&rsquo;s why Android introduced the &ldquo;Smallest-width&rdquo; qualifier (amongst others) in Android 3.2.</p>

<p>在 3.2 版本系统之前，使用 Size 限定符有一个问题会让很多程序员感到头疼，large 到底是指多大呢？很多时候5寸和7寸都被当做 large，但很多应用都希望能够更自由地为不同屏幕设备加载不同的布局，不管它们是不是被系统认定为"large"。这就是Android为什么在3.2以后引入了"Smallest-width"限定符。</p>

<p>The Smallest-width qualifier allows you to target screens that have a certain minimum width given in dp. For example, the typical 7" tablet has a minimum width of 600 dp, so if you want your UI to have two panes on those screens (but a single list on smaller screens), you can use the same two layouts from the previous section for single and two-pane layouts, but instead of the large size qualifier, use sw600dp to indicate the two-pane layout is for screens on which the smallest-width is 600 dp:</p>

<p>Smallest-width 限定符允许你设定一个具体的最小值(以dp为单位)来指定屏幕。例如，7寸的平板最小宽度是600dp，所以如果你想让你的UI在这种屏幕上显示 two pane，在更小的屏幕上显示 single pane，你可以使用sw600dp来表示你想在600dp以上宽度的屏幕上使用 two pane 模式：</p>

<p>res/layout/main.xml, single-pane (default) layout:
```
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:orientation="vertical"
android:layout_width="match_parent"
android:layout_height="match_parent"&gt;

&lt;fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="match_parent" /&gt;
</code></pre>

<p></LinearLayout>
```</p>

<p>res/layout-sw600dp/main.xml, two-pane layout:
```
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:orientation="horizontal"&gt;
&lt;fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/&gt;
&lt;fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" /&gt;
</code></pre>

<p></LinearLayout>
```
This means that devices whose smallest width is greater than or equal to 600dp will select the layout-sw600dp/main.xml (two-pane) layout, while smaller screens will select the layout/main.xml (single-pane) layout.</p>

<p>这意味着，那些最小屏幕宽度大于600dp的设备会选择 layout-sw600dp/main.xml(two-pane)布局，而更小屏幕的设备将会选择 layout/main.xml(single-pane)布局。</p>

<p>However, this won&rsquo;t work well on pre-3.2 devices, because they don&rsquo;t recognize sw600dp as a size qualifier, so you still have to use the large qualifier as well. So, you should have a file named res/layout-large/main.xml which is identical to res/layout-sw600dp/main.xml. In the next section you&rsquo;ll see a technique that allows you to avoid duplicating the layout files this way.</p>

<p>可是，3.2系统之前不支持 Smallest-width 限定符，你仍然需要 large 限定符去兼容那些老系统，即需要同时存在 layout-sw600dp 和 layout-large，并且里面的布局文件是一样的。可是，这样就造成重复定义布局的问题，下一节会介绍一种避免重复布局的技术。</p>

<h3>Use Layout Aliases 布局别名</h3>

<p>The smallest-width qualifier is available only on Android 3.2 and above. Therefore, you should also still use the abstract size bins (small, normal, large and xlarge) to be compatible with earlier versions. For example, if you want to design your UI so that it shows a single-pane UI on phones but a multi-pane UI on 7" tablets, TVs and other large devices, you&rsquo;d have to supply these files:<br/>
&hellip;</p>

<p>Smallest-width 限定符仅在 Android 3.2及之后的系统中有效。所以，你需要同时使用 Size 限定符(small, normal, large 和 xlarge)来兼容更早的系统。例如，你想手机上显示 single-pane 界面，而在7寸平板和更大屏的设备上显示 multi-pane 界面，你需要提供以下文件：<br/>
res/layout/main.xml: single-pane 布局<br/>
res/layout-large/main.xml: multi-pane 布局<br/>
res/layout-sw600dp/main.xml: multi-pane 布局</p>

<p>The last two files are identical, because one of them will be matched by Android 3.2 devices, and the other one is for the benefit of tablets and TVs with earlier versions of Android.</p>

<p>最后的两个文件是完全相同的，一个用于3.2及以上系统，一个用于3.2以下系统。</p>

<p>To avoid this duplication of the same file for tablets and TVs (and the maintenance headache resulting from it), you can use alias files. For example, you can define the following layouts:<br/>
&hellip;</p>

<p>使用别名来避免重复。例如，可以定义以下布局：<br/>
res/layout/main.xml, single-pane layout<br/>
res/layout/main_twopanes.xml, two-pane layout</p>

<p>加入以下两个 values 文件：</p>

<p>res/values-large/layout.xml:
```
<resources></p>

<pre><code>&lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</code></pre>

<p></resources>
```</p>

<p>res/values-sw600dp/layout.xml:
```
<resources></p>

<pre><code>&lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</code></pre>

<p></resources>
```</p>

<h3>Use Orientation Qualifiers 使用方向限定符</h3>

<p>Some layouts work well in both landscape and portrait orientations, but most of them can benefit from adjustments. In the News Reader sample app, here is how the layout behaves in each screen size and orientation:<br/>
&hellip;</p>

<p>有些布局在横竖屏时都显示正常，但大多数情况下可以做调整以显示更好。例如，在 News Reader 示例程序中，布局在不同屏幕尺寸和不同屏幕方向中是这样显示的：<br/>
小屏幕, 竖屏: 单面板, 显示logo<br/>
小屏幕, 横屏: 单面板, 显示logo<br/>
7寸平板, 竖屏: 单面板, 显示action bar<br/>
7寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
10寸平板, 竖屏: 双面板, 窄, 显示action bar<br/>
10寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
电视, 横屏: 双面板, 宽, 显示action bar</p>

<p>具体代码不再展示：）</p>

<h3>Use Nine-patch Bitmaps 使用点9图</h3>

<p>略：）</p>

<h2>2. Supporting Different Densities</h2>

<p>上一篇解决了怎样让布局适配屏幕的问题，本篇解决怎样让控件显示正确和让图片显示最佳的问题。</p>

<p>Android 提供两种方式支持不同的屏幕密度：<br/>
Use Density-independent Pixels<br/>
Provide Alternative Bitmaps</p>

<h3>Use Density-independent Pixels</h3>

<p>Android 设备屏幕有多种密度，在布局时要避免使用像素来定义尺寸，而应该使用 dp 或 sp。<br/>
dp 是密度无关单位，在 160dpi 屏幕下，1dp=1px；<br/>
sp 与 dp 类似，是缩放比例无关单位，用于文字。</p>

<h3>Provide Alternative Bitmaps</h3>

<p>不同密度对应不用的图片：<br/>
xhdpi: 2.0<br/>
hdpi: 1.5<br/>
mdpi: 1.0 (baseline)<br/>
ldpi: 0.75</p>

<h2>3. Implementing Adaptative UI Flows</h2>

<p>上两篇介绍了如何布局及配置图片资源，本篇介绍如何在代码里执行对应的界面流程。</p>

<p>Depending on the layout that your application is currently showing, the UI flow may be different. For example, if your application is in the dual-pane mode, clicking on an item on the left pane will simply display the content on the right pane; if it is in single-pane mode, the content should be displayed on its own (in a different activity).</p>

<p>根据设备屏幕的不同，Android 会调用对应的布局，同时也要求代码里执行与布局对应的界面流程。例如，如果此时应用是 dual-pane 模式布局，在左边点击 item 后，右边应该直接显示内容；如果是 single-pane 模式布局，内容应该通过打开另一个 activity 显示。</p>

<h3>Determine the Current Layout</h3>

<p>确定当前布局</p>

<p>Since your implementation of each layout will be a little different, one of the first things you will probably have to do is determine what layout the user is currently viewing. For example, you might want to know whether the user is in &ldquo;single pane&rdquo; mode or &ldquo;dual pane&rdquo; mode. You can do that by querying if a given view exists and is visible:</p>

<p>因为针对不同布局的具体实现会略有不同，所以你在处理界面之前应该首先确定当前使用的是哪个布局。例如，你需要知道当前是 dual-pane 还是 single-pane。你可以通过查询某个 view 是否存在来确定：
```
public class NewsReaderActivity extends FragmentActivity {</p>

<pre><code>boolean mIsDualPane;

@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main_layout);

    View articleView = findViewById(R.id.article);
    mIsDualPane = articleView != null &amp;&amp; 
                    articleView.getVisibility() == View.VISIBLE;
}
</code></pre>

<p>}
```
以上代码查询 article 是否存在，存在的话说明是 dual-pane 模式。这种方式比直接查询调用了哪个布局更灵活简单。</p>

<p>Another example of how you can adapt to the existence of different components is to check whether they are available before performing an operation on them. For example, in the News Reader sample app, there is a button that opens a menu, but that button only exists when running on versions older than Android 3.0 (because it&rsquo;s function is taken over by the ActionBar on API level 11+). So, to add the event listener for this button, you can do:</p>

<p>也可以在执行动作前检查 view 是否存在：
```
Button catButton = (Button) findViewById(R.id.categorybutton);
OnClickListener listener = /<em> create your listener here </em>/;
if (catButton != null) {</p>

<pre><code>catButton.setOnClickListener(listener);
</code></pre>

<p>}
```</p>

<h3>React According to Current Layout</h3>

<p>响应当前布局</p>

<p>Some actions may have a different result depending on the current layout. For example, in the News Reader sample, clicking on a headline from the headlines list opens the article in the right hand-side pane if the UI is in dual pane mode, but will launch a separate activity if the UI is in single-pane mode:</p>

<p>确定了当前布局后，就可以根据不同的布局做出不同的响应了：
```
@Override
public void onHeadlineSelected(int index) {</p>

<pre><code>mArtIndex = index;
if (mIsDualPane) {
    /* display article on the right pane */
    mArticleFragment.displayArticle(mCurrentCat.getArticle(index));
} else {
    /* start a separate activity */
    Intent intent = new Intent(this, ArticleActivity.class);
    intent.putExtra("catIndex", mCatIndex);
    intent.putExtra("artIndex", index);
    startActivity(intent);
}
</code></pre>

<p>}
```</p>

<h3>Reuse Fragments in Other Activities</h3>

<p>在其它 Activity 中重用 Fragment</p>

<p>A recurring pattern in designing for multiple screens is having a portion of your interface that&rsquo;s implemented as a pane on some screen configurations and as a separate activity on other configurations. For example, in the News Reader sample, the news article text is presented in the right side pane on large screens, but is a separate activity on smaller screens.</p>

<p>在支持多种屏幕的设计中有一种重用模式，就是把界面的一部分当做一个独立体，这个独立体在大屏幕中是一个 pane，在小屏幕中是一个 activity。这种模式可以使用 fragment 来实现。</p>

<p>例如，定义一个 ArticleFragment，大屏幕时用在 dual-pane 布局中：
```
&lt;LinearLayout xmlns:android=&ldquo;<a href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>&rdquo;</p>

<pre><code>android:layout_width="fill_parent"
android:layout_height="fill_parent"
android:orientation="horizontal"&gt;
&lt;fragment android:id="@+id/headlines"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.HeadlinesFragment"
          android:layout_width="400dp"
          android:layout_marginRight="10dp"/&gt;
&lt;fragment android:id="@+id/article"
          android:layout_height="fill_parent"
          android:name="com.example.android.newsreader.ArticleFragment"
          android:layout_width="fill_parent" /&gt;
</code></pre>

<p></LinearLayout>
<code>
小屏幕时用在 ArticleActivity 中（无需再针对 activity 布局）：
</code>
ArticleFragment frag = new ArticleFragment();
getSupportFragmentManager().beginTransaction().add(android.R.id.content, frag).commit();
```
One very important point to keep in mind when designing your fragments is to not create a strong coupling to a specific activity. You can usually do that by defining an interface that abstracts all the ways in which the fragment needs to interact with its host activity, and then the host activity implements that interface:</p>

<p>在设计 fragment 时我们需要注意的一点是：不要为特定的 activity 创建强耦合的 fragment。你可以在 Fragment 里创建接口，通过接口和 activity 进行交互：
例如，HeadlinesFragment 这样设计：
```
public class HeadlinesFragment extends ListFragment {</p>

<pre><code>...
OnHeadlineSelectedListener mHeadlineSelectedListener = null;

/* Must be implemented by host activity */
public interface OnHeadlineSelectedListener {
    public void onHeadlineSelected(int index);
}
...

public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener listener) {
    mHeadlineSelectedListener = listener;
}
</code></pre>

<p>}
```
activity 需要实现这个接口，这样，当用户点击左边 item 的时候，fragment 会通知 host activity 的 listener 进行操作，而 activity 在实现 listener 的 onHeadlineSelected 方法里面会进行当前布局的判断，从而选择合适的 UI（是显示在右边还是另起一个 activity）。下面是 fragment 响应点击事件，通知 activity 的 listener 进行实际操作的代码：</p>

<p>```
public class HeadlinesFragment extends ListFragment {</p>

<pre><code>...
@Override
public void onItemClick(AdapterView&lt;?&gt; parent, 
                        View view, int position, long id) {
    if (null != mHeadlineSelectedListener) {
        mHeadlineSelectedListener.onHeadlineSelected(position);
    }
}
...
</code></pre>

<p>}
```</p>

<h3>Handle Screen Configuration Changes</h3>

<p>略：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Patterns]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-patterns/"/>
    <updated>2014-07-16T22:43:39+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-patterns</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-style/"/>
    <updated>2014-07-16T22:30:21+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-style</id>
    <content type="html"><![CDATA[<blockquote><p>Build visually compelling apps that look great on any device.<br/>
构建在任何设备上都引人注目的应用。</p></blockquote>

<p>本篇分为以下几个部分：<br/>
1. Devices and Displays（重要）<br/>
2. Themes  <br/>
3. Touch Feedback<br/>
4. Metrics and Grids（重要）<br/>
5. Typography</p>

<!--more-->


<h2>1. Devices and Displays</h2>

<p>设备与显示</p>

<p>Android powers hundreds of millions of phones, tablets, and other devices in a wide variety of screen sizes and form factors. By taking advantage of Android&rsquo;s flexible layout system, you can create apps that gracefully scale from large tablets to smaller phones.</p>

<p>Android 作为一个开放的平台，支持种类繁多的设备和屏幕尺寸，因此，解决设备适配问题一直以来是应用开发中的重点工作。Android 为此提供了自适应布局的解决方案。</p>

<p><img src="/images/devices_displays_main.png" alt="devices_displays_main" /></p>

<h4>Be flexible 自适应</h4>

<p>Stretch and compress your layouts to accommodate various heights and widths.</p>

<p>Android 会根据不同的宽高值缩放布局。宽高值可以定义为 WRAP_CONTENT、MATCH_PARENT、FILL_PARENT（API-8以下）、dp值、px值等。</p>

<h4>Optimize layouts 布局优化</h4>

<p>On larger devices, take advantage of extra screen real estate. Create compound views that combine multiple views to reveal more content and ease navigation.</p>

<p>针对大屏幕设备，通过设计混合 view 来展示更多的内容（如平板中常利用 fragment 来实现左边显示列表右边显示内容），以此充分利用屏幕空间。</p>

<h4>Assets for all 资源集</h4>

<p>Provide resources for different screen densities (DPI) to ensure that your app looks great on any device.</p>

<p>为了让应用在所有屏幕上以最佳质量显示，需要根据不同密度屏幕提供不同尺规格的资源。目前主流手机的屏幕密度在 XHDPI（视网膜）左右的范围。</p>

<p><img src="/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<h4>Strategies 适配策略</h4>

<p>So where do you begin when designing for multiple screens? One approach is to work in the base standard (normal size and MDPI) and scale it up or down for the other buckets. Another approach is to start with the device with the largest screen size, and then scale down and figure out the UI compromises you&rsquo;ll need to make on smaller screens.</p>

<p>有两种方式开始屏幕适配工作：<br/>
1. 从 normal size 和 MDPI 开始；<br/>
2. 从应用要支持的最大屏幕以及对应的 DPI 开始。<br/>
我认为挑选一个主流或偏高的屏幕开始较好，比如 xhdpi，能够保证多数用户的体验。</p>

<p>For details about designing layouts for larger screens, see the <a href="http://developer.android.com/design/patterns/multi-pane-layouts.html">Multi-pane Layouts</a> guide.（Multi-pane Layouts 主要针对平板）</p>

<p>Developer Guide<br/>
For information about how to build flexible layouts for multiple screen sizes and densities, read <a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a> and <a href="http://developer.android.com/training/basics/fragments/index.html">Building a Dynamic UI with Fragments</a>.</p>

<h2>2. Themes</h2>

<p>主题</p>

<p>Themes are Android&rsquo;s mechanism for applying a consistent style to an app or activity. The style specifies the visual properties of the elements that make up your user interface, such as color, height, padding and font size. To promote greater cohesion between all apps on the platform, Android provides two system themes that you can choose from when building apps:</p>

<p>Theme 是让应用界面风格保持一致的机制，Theme 其实就是一个 style，而 style 是诸如 color、height、padding、front size 等属性值的集合。Android 官方提供了两种 theme，目的是让 Android 平台上的应用体验一致，你在创建应用的时候可选择其中之一，当然也可以定义自己的 theme。</p>

<p>Gmail in Holo Light：<br/>
<img src="/images/themes_holo_light.png" alt="themes_holo_light" /></p>

<p>Settings in Holo Dark：<br/>
<img src="/images/themes_holo_dark.png" alt="themes_holo_dark" /></p>

<p>Applying these themes will go a long way in helping you to build apps that fit right into the general visual language of Android.</p>

<p>使用以上两种 theme 可以让你的应用更好的符合 Android 设计规范。</p>

<p>Pick the system theme that best matches the needs and design aesthetics for your app. If your desire is to have a more distinct look for your app, using one of the system themes as a starting point for your customizations is a good idea. The system themes provide a solid foundation on top of which you can selectively implement your own visual stylings.</p>

<p>如果你希望设计一个与众不同的应用，一个好办法是在 Holo Light 或 Holo Dark 的基础上进行定制。</p>

<p>更多关于使用 theme 的信息请看 <a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a></p>

<h2>3. Touch Feedback</h2>

<p>触摸反馈</p>

<p>Use illumination and dimming to respond to touches, reinforce the resulting behaviors of gestures, and indicate what actions are enabled and disabled.</p>

<p>使用明暗效果来响应用户的触摸（如下文的 States），对手势做出结果导向的界面行为（如下文的 Communication），明确指出哪些操作可用哪些操作不可用。</p>

<p>Be responsive to touches in a gentle way. Whenever a user touches an actionable area in your app, let them know the app is &ldquo;listening&rdquo; by providing a visual response. Make it subtle —just slightly lighter or darker than the untouched color. This provides two benefits:<br/>
Sprinkles of encouragement are more pleasant than jolts.<br/>
Incorporating your branding is much easier because the default touch feedback works with whatever hue you choose.</p>

<p>用一种自然的方式来响应触摸动作。在用户触摸一个可操作区域的时候，通过界面的变化来让他们知道应用正在处理这个操作。</p>

<h3>States</h3>

<p><img src="/images/touch_feedback_states.png" alt="touch_feedback_states" /></p>

<p>Most of Android&rsquo;s UI elements have touch feedback built in, including states that indicate whether touching the element will have any effect.</p>

<p>大部分的 Android 界面元素都内置了触摸反馈效果，比如上图中的几种状态。</p>

<h3>Communication</h3>

<p>When your objects react to more complex gestures, help users understand what the outcome will be.<br/>
In Recents, when a user starts swiping a thumbnail left or right, it begins to dim. This helps the user understand that swiping will cause the item to be removed.</p>

<p>当你的界面能够响应更复杂的手势时，要让用户知道接下来会发生什么。<br/>
比如，在 Recents 界面，当用户向左或向右拖动一个应用缩略图时，缩略图会渐渐变暗，以此来告诉用户拖动操作会删除该应用。</p>

<p><img src="/images/touch_feedback_manipulation.png" alt="touch_feedback_manipulation" /></p>

<h3>Boundaries</h3>

<p>When users try to scroll past the beginning or end of a scrollable area, communicate the boundary with a visual cue. Many of Android&rsquo;s scrollable UI widgets, like lists and grid lists, have support for boundary feedback built in. If you’re building custom widgets, keep boundary feedback in mind and provide it from within your app.</p>

<p>当用户在一个可滚动的区域尝试越过起始或结尾位置时，应该给予一个边界提示。Android 提供的 ListView 和 GridView 都带有这种效果。</p>

<p><img src="/images/touch_feedback_communication.png" alt="touch_feedback_communication" /></p>

<h2>4. Metrics and Grids</h2>

<p>Devices vary not only in physical size, but also in screen density (DPI). To simplify the way you design for multiple screens, think of each device as falling into a particular size bucket and density bucket:<br/>
The size buckets are handset (smaller than 600dp) and tablet (larger than or equal 600dp).<br/>
The density buckets are LDPI, MDPI, HDPI, XHDPI, XXHDPI, and XXXHDPI.</p>

<p>设备之间除了屏幕尺寸不同，屏幕的像素密度 (DPI) 也不一样。为了简化为不同的屏幕设计 UI 的复杂度，可以将所有的设备按照大小和像素密度如下分类。<br/>
1. 按设备大小分有两类，分别是手持设备 (小于 600 dp) 和 平板 (大于等于 600dp)；<br/>
2. 按像素密度分有 LDPI、MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI。</p>

<p>Optimize your application&rsquo;s UI by designing alternative layouts for some of the different size buckets, and provide alternative bitmap images for different density buckets.</p>

<p>你应该为不同的设备使用不一样的布局文件来优化界面，以及为各种像素密度提供大小不同的位图。</p>

<p><img src="/images/metrics_diagram.png" alt="metrics_diagram" /></p>

<p>Devices vary in the amount of <code>density-independent pixels</code> (dp) they can display.</p>

<p>如上图所示，设备的种类可以体现在 dp 长度上。更多关于市面上设备分布的信息请看
<a href="http://developer.android.com/about/dashboards/index.html">Screen Sizes and Densities Device Dashboard</a></p>

<h3>48dp Rhythm</h3>

<p>Touchable UI components are generally laid out along 48dp units.</p>

<p>可触摸界面元素通常设置 48dp 左右的大小。</p>

<p><img src="/images/metrics_48.png" alt="metrics_48" /></p>

<h4>Why 48dp?</h4>

<p>On average, 48dp translate to a physical size of about 9mm (with some variability). This is comfortably in the range of recommended target sizes (7-10 mm) for touchscreen objects and users will be able to reliably and accurately target them with their fingers.</p>

<p>就平均而言，48dp 转化为物理长度是 9mm。这是用户手指可操作的比较适合的范围（7-10mm）。</p>

<p><img src="/images/metrics_closeup.png" alt="metrics_closeup" /></p>

<h4>Mind the gaps</h4>

<p>Spacing between each UI element is 8dp.</p>

<p>留意元素间的间隔，通常为 8dp。</p>

<h3>Examples</h3>

<p><img src="/images/metrics_forms.png" alt="metrics_forms" /></p>

<h2>5. Typography</h2>

<p>字体</p>

<p><img src="/images/typography_main.png" alt="typography_main" /></p>

<p>The Android design language relies on traditional typographic tools such as scale, space, rhythm, and alignment with an underlying grid. Successful deployment of these tools is essential to help users quickly understand a screen of information. To support such use of typography, Ice Cream Sandwich introduced a new type family named Roboto, created specifically for the requirements of UI and high-resolution screens.</p>

<p>Android 的英文字体设计基于传统的印刷排版技术，例如字体缩放、字间距规则和对齐网格。这些技术的成功运用，使用
户可以快速理解屏幕上的信息。为此，Ice Cream Sandwich 引⼊了全新的 Roboto 字体家族，它专为高分辨率屏幕而设计。</p>

<p>The current TextView framework offers Roboto in thin, light, regular and bold weights, along with an italic style for each weight. The framework also offers the Roboto Condensed variant in regular and bold weights, along with an italic style for each weight.</p>

<p>当前的 TextView 控件默认支持 thin、light、regular、bold，以及对应权重的斜体。也提供了叫 Condensed 的变种版本。</p>

<p><img src="/images/typography_variants@2x.png" alt="typography_variants@2x" /></p>

<h4>Default type colors</h4>

<p>The Android UI uses the following default color styles: textColorPrimary and textColorSecondary. For light themes use textColorPrimaryInverse and textColorSecondaryInverse. The framework text color styles also support variants for touch feedback states when used inside UI elements.</p>

<p>Android 使用 textColorPrimary 和 textColorSecondary 作为默认颜色值。在 light 主题中使用 textColorPrimaryInverse 和 textColorSecondaryInverse。
```</p>



<p>```
<img src="/images/typography_defaults.png" alt="typography_defaults" /></p>

<h4>Typographic Scale</h4>

<p>Contrast in type sizes can go a long way to create ordered, understandable layouts. However, too many different sizes in the same UI can be messy. The Android framework uses the following limited set of type sizes:</p>

<p>字体⼤⼩上的不同有利于创造出有序和容易理解的布局。不过，在同⼀个界面中使用过多的字体⼤⼩则会造成混乱。Android 设计框架建议使用以下⼏种字体⼤⼩：</p>

<p><img src="/images/typography_sizes.png" alt="typography_sizes" /></p>

<p>Users can select a system-wide scaling factor for text in the Settings app. In order to support these accessibility features, type should be specified in <code>scale-independent pixels</code> (sp) wherever possible. Layouts supporting scalable types should be tested against these settings.</p>

<p>用户可以在<code>设置</code>中调整整个系统的字体⼤⼩。为了支持这⼀特性，字体的⼤⼩应尽量使用可缩放的单位，我们称之为(sp)。另外，要针对支持 sp 缩放的布局做测试，即改变系统字体大小，看布局是否显示正常。</p>
]]></content>
  </entry>
  
</feed>
