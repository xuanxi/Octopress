<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Steven Chen]]></title>
  <link href="http://xuanxi.github.io/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-08-18T19:38:50+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[关于个人知识/兴趣的看法]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/18/about-personal-knowledge-and-interest/"/>
    <updated>2014-08-18T18:59:25+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/18/about-personal-knowledge-and-interest</id>
    <content type="html"><![CDATA[<p>今天读到国内知名 Android 开发者 Trinea 的一篇博客：
<a href="http://www.trinea.cn/plan-summary/self-blog-why-what-target/">写在前面, 自己搭博客why and target</a>。其中一张图可以了解到作者的知识/兴趣面：</p>

<p><img src="http://xuanxi.github.io/images/Trinea.jpg" alt="Trinea" /></p>

<p>这跟我的个人规划比较相似，于是也尝试总结一下：</p>

<!--more-->


<p>五年的工作经历，使我慢慢意识到不要把全部精力放在技术上。从一个产品的角度来说，包含前期调研（用户、市场）、需求、UI、开发测试、推广、运营等，如果只了解和参与技术工作的话就未免被局限住了，所以我会利用一定空余时间去了解技术之外的产品相关的知识和经验，事实证明是无比正确的选择：）。当然，也有人会说“我就只对技术感兴趣”、“我的职业规划就是开发”，这是个人发展方向的问题了，并无对错之分。</p>

<p>工作之余，经济学、心理学、文学绝对是好东西，可以提高素养和开发心智，而好的素养和成熟的心智对职业发展的好处我想不用多说了吧。我也会建议正在念大学的弟妹们多读这几方面的书以扩大视野。另外，我认为历史也非常值得学习，就我的感受而言，主要是两点：历史在团队建设、企业管理方面有很多值得借鉴的地方；让我对社会有更理性成熟的认识，有助于在社会上走好每一步。顺便提一句，关于中国近现代史，最好还是阅读墙外的资料吧，原因你懂的。</p>

<p>图中还提到作者喜欢旅行。我想，作为一个放松身心、体验生活的好事情，旅行是值得大家去做的，尤其对于我们这些长期跟计算机打交道，一坐10个小时的程序猿们。即使真腾不出时间出门，也应该在平时多找机会让自己可以放松精神和身体，比如做简单的体操动作，听听音乐，补充维生素等。前几天在微信朋友圈上总结自己工作五年最大的体会，毫不犹豫地写了“身体是革命的本钱”，希望大家不但有好的工作成绩，更有好的身体：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio vs Eclipse: What Are the Main Differences?]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences/"/>
    <updated>2014-08-07T14:09:55+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/">http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/</a></p>

<p><img src="http://xuanxi.github.io/images/androidstudio.png" alt="androidstudio" /></p>

<!--more-->


<p>Most of Google’s 2013 I/O event was about Android. One specific announcement managed to attract a lot of hype and that was no other than Google’s own Android IDE, Android Studio. It has been just over a year now since the first public release and Android Studio has come a long way, despite still being in beta. The IDE itself is based off the very popular IntelliJ IDEA from JetBrains and is being offered by Google for free.</p>

<p>Google 2013 I/O 大会的大部分内容是与 Android 相关，其中，专为 Android 打造的开发环境——Android Studio 无疑最引人注目。Android Studio 从公开第一个版本至今已经走过一个年头，尽管仍然处于 beta 版本（公开测试版），但相比一年前，Google 已经对其做了相当多的改进。Android Studio 基于非常著名的 JetBrains 公司的产品——IntelliJ IDEA，并免费提供给开发者。</p>

<p>On the other hand, Eclipse is more mature than ever and Google’s ADT plugin which transforms the popular IDE into a fully featured Android developing environment has become very stable. Eclipse feels like home for many Java developers and is a natural starting point for Java developers who want to get into Android development.</p>

<p>另一方面，基于 Google ADT 插件的 Eclipse 现在已经成为 Android 开发的一个非常成熟稳定的环境，作为要进入 Android 开发领域的 Java 开发人员，Eclipse 是一个自然而然的选择。</p>

<p>While both solutions look promising, which one has the edge over the other? In this blog we will compare the two in 5 distinct areas in an effort to reveal the main differences in the Android Studio vs Eclipse battle.</p>

<p>两个开发环境看起来都有不错的前景，那么哪个更具优势呢？本文试图从5个方面分析它们的不同。</p>

<h3>Build Tools</h3>

<p>Android Studio utilizes the fast growing Gradle build system. It builds on top of the concepts of Apache Ant and Apache Maven but it also introduces a Groovy DSL (Domain-Specific Language) that allows for scripted builds which opens up many automation possibilities like uploading your beta .apk to TestFlight for testing. Eclipse on the other hand uses Apache Ant as its main build system which a very robust XML based build system that many Java developers may already be familiar with.</p>

<p>Android Studio 使用了当前发展迅猛的 Gradle 构建系统，它基于 Groovy 脚本语言，可以实现比 Ant 和 Maven 更灵活的构建过程，如自动上传测试包。而 Eclipse 使用成熟健壮的 Ant 作为构建系统。</p>

<h3>Advanced Code Completion/Refactoring</h3>

<p>Both IDEs feature the standard Java code auto completion but in the case of Android Studio, Google has baked in deeper support for specific Android code and refactoring. Android Studio can refactor your code in places where it’s just not possible using Eclipse and ADT. In addition, in my opinion IntelliJ’s Java auto completion seems more “intelligent” and predicts better what I want to do so there is definitely an improvement in this area over Eclipse.</p>

<p>两个 IDE 都提供了代码补全和重构功能，不过，Android Studio 在对 Android 代码的补全和重构方面做了更好的支持。另外，我认为 IntelliJ 的 Java 代码补全更加智能，预判准确率更高，这个相比 Eclipse 无疑是一个进步。</p>

<h3>User Interface Design</h3>

<p>One of the main selling point Google used to market Android Studio when it came out was its completely redesigned user interface design tool. After working with it for some time, it’s clear that the new tool is much better than the old. It literally crashes it. The new interface design tool in Android Studio is faster, responds to changes more rapidly and has more customization options that with Eclipse, you had to manually set in the XML.</p>

<p>用户界面设计工具是 Android Studio 的一个主要卖点。比起 ADT，Android Studio 上的设计工具更快、更灵活，比如在 Android Studio 的设计面板上可以直接设置元素属性，而在 Eclipse 上只能手动修改 XML 文件。</p>

<h3>Project Organization</h3>

<p>Both IDEs work differently in an effort to help you manage and organize your projects. If you’ve used Eclipse then you must be familiar with the concept of workspaces. When Eclipse starts, you select the workspace that contains your projects and you can load all project of that workspace in your tree navigation. If you want to switch to a project in a different workspace, then you have to restart the whole IDE. Android Studio treats this situation differently by introducing the concept of modules. Your app could be one module, a library that you just downloaded can be another and the Ad SDK you are currently integrating could be a third. Each of these modules can have their own Gradle build files and declare their own dependencies. To me, Android Studio seems more natural but it takes some time to get used to if you have been using Eclipse for a long time.</p>

<p>两个 IDE 在工程组织上各不相同。Eclipse 使用 workspace &ndash; project 的结构，Android Studio 使用 project &ndash; module 的结构，我更偏向 Android Studio 的组织方式。（从表面上看，貌似也没多大差别啊）</p>

<h3>IDE Performance/Stability</h3>

<p>Eclipse is a purely Java based software, and a big one. In order to run it reliably you need to have more than decent amount of RAM and good CPU power to back it up. Many user who do not strictly meet these criteria are reporting very bad experiences with it. It is not unusual for Eclipse to crash while exporting an apk or having to restart it after using it for a few hours straight. Having said that, Android Studio is still in beta so it comes with its own bugs that crash the IDE every now and then but in the meanwhile, the whole experience feels faster and more robust.</p>

<p>Eclipse 是一个使用纯 Java 语言编写的程序，由于它是基于可扩展的设计思想，即通过各种插件来提供特定开发环境，所以本身体积较大，运行时需要较多的内存和 CPU 资源，你可能会遇到这样的情况：打包 apk 时程序崩溃了，或者运行几个小时后因为响应太慢而不得不重启。对于 Android Studio ，上面已经提到它仍然处于 beta 阶段，会偶尔崩溃，不过，现时它的整体体验已经相对更快和更稳定。</p>

<h3>Conclusion</h3>

<p>Having used both Android Studio and Eclipse for a while now, I would personally say that Android Studio has the edge over the two. It might be a bit unstable yet and some updates require a complete re-installation of the software but when it eventually comes out of beta, it will blow Eclipse with ADT out of the water. I especially like the stability of the editor and not having to reboot every now and then, the new and improved UI designer and the sexy themes that make Android Studio a real eye candy. What side will you take in the Android Studio vs Eclipse battle?</p>

<p>我同时使用 Android Studio 和 Eclipse 已有一段时间，我个人认为 Android Studio 更具优势，虽然存在不稳定性，以及升级可能需要重装，但就在 beta 版发布之后，它完全可以击败 Eclipse。我尤其喜欢它的编辑器的稳定、无需重启、增强的界面设计和性感的外观。</p>

<h2>我的看法</h2>

<p>和本文作者一样，我也同时使用这两个 IDE 一段时间了（公司用 Eclipse，个人用 Android Studio），并同样感受到 Android Studio 的明显优势：<br/>
1. 快，无论是启动程序，还是打开 XML 文件，都可以明显看出两个 IDE 的速度差别；<br/>
2. 酷，那个 Darcula 的外观实在比 Eclipse 呆板的外观好看得多（Eclipse 中可使用 color theme 来美化外观，但个人觉得也比不上 Android Studio）。<br/>
对于重构和新的界面设计工具，我的使用经验还不多，这里就不作评论了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/29/reading-android-manual/"/>
    <updated>2014-07-29T15:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/29/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出具有良好用户体验的产品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/ios-design-principles/">iOS Design Principles</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。<br/>
参考 <a href="http://blog.xuanxi.me/blog/2014/07/15/bars/">iOS UI Framework</a></p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style-1/">Android Style (1)</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/07/29/android-style-2/">Android Style (2)</a><br/>
设计风格，主要是视觉方面。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns-1/">Android Patterns (1)</a><br/>
设计模式，主要是交互方面。</p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
风格与主题</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style (2)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/29/android-style-2/"/>
    <updated>2014-07-29T09:56:06+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/29/android-style-2</id>
    <content type="html"><![CDATA[<p>本篇包括以下内容：<br/>
6. Color<br/>
7. Iconography<br/>
8. Your Branding<br/>
9. Writing Style</p>

<!--more-->


<h2>6. Color</h2>

<h2>7. Iconography</h2>

<p><img src="http://xuanxi.github.io/images/iconography_overview.png" alt="iconography_overview" /></p>

<p>图标就是⼀个直观的图形，占据屏幕一个小空间，用来代表⼀个操作、⼀种状态或者⼀个应用本身。</p>

<p>当你为应用设计图标时，需要紧记的是你的应用可能会被安装到多种分辨率的设备中。不过，你可以通过提供不同大小的图标来适配各种密度的设备。</p>

<p>因为你要提供多种规格图标来适配多种密度，下文中提到的图标尺寸都用 dp 为单位。dp 是以 MDPI 中的像素为基准的，即在 MDPI 中 1dp=1px，在 HDPI 中 1dp=1.5px，在 XHDPI 中 1dp=2px，如下图所示：</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<p>这样，当你设计图标的时候，应该按照  2:3:4:6:8（或者 1:1.5:2:3:4） 的比例去缩放。例如，一个应用启动图标的规格为 48x48 dp，意味着 MDPI 的大小是 48x48 px，HDPI 的大小是 72x72 px，以此类推。</p>

<p>注意：Android 也支持一种更小的屏幕密度 LDPI，不过通常不需要考虑这种密度，因为 Android 会将 HDPI 中的图标缩小一半来适配它。<br/>
补充：在要求不太严格的情况下，我们可以只为高密度屏幕设计一套图标，比如 XHDPI，Android 会自动缩小尺寸适配所有密度屏幕。</p>

<h3>Launcher</h3>

<p>启动图标</p>

<p>启动图标用在 Home 界面和 All Apps 界面。因为用户可以改变 Home 的背景，所以要考虑启动图标是否能够在任何类型的背景中都清晰可见。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_size.png" alt="iconography_launcher_size" /></p>

<p>Sizes &amp; scale <br/>
1. 启动图标在移动设备中必须为 48x48 dp；<br/>
2. 启动图标在 Google Play 中必须为 512x512 pixels。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_focal.png" alt="iconography_launcher_focal" /></p>

<p>Proportions<br/>
图标不要留白，要占满 48x48 dp 大小。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_style.png" alt="iconography_launcher_style" /></p>

<p>Style<br/>
Use a distinct silhouette. Three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth.<br/>
使用清晰的轮廓。三维的正面视图，看起来稍微有点从上往下的俯视效果，使用户能看到⼀些景深。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_example2.png" alt="iconography_launcher_example2" /></p>

<h3>Action Bar</h3>

<p>操作栏图标是⼀个图形按钮，用来表示用户在应用中可以执行的重要操作。使用简洁明了的图像代表将要执行的操作，让用户⼀目了然。</p>

<p>Android 内置了一些通用操作的图标供使用，例如“刷新”和“分享”。下面提供了图标包的下载链接，其中包括多种屏幕分辨率，以及对应 Holo Light和 Holo Dark 主题的图标。包中带有尚未样式化的图标，同时提供 Adobe® Illustrator® 源文件，你可以自由修改以搭配自⼰的主题。</p>

<p><a href="http://developer.android.com/downloads/design/Android_Design_Icons_20131106.zip">Download the Action Bar Icon Pack</a></p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_size.png" alt="iconography_actionbar_size" /></p>

<p>Sizes &amp; scale<br/>
Action bar icons for phones should be 32x32 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_focal.png" alt="iconography_actionbar_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset 整体大小, 32x32 dp<br/>
Optical square 实际内容, 24x24 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_style.png" alt="iconography_actionbar_style" /></p>

<p>Style<br/>
Pictographic, flat, not too detailed, with smooth curves or sharp shapes. If the graphic is thin, rotate it 45° left or right to fill the focal space. The thickness of the strokes and negative spaces should be a minimum of 2 dp.<br/>
形象化，扁平，不要⼩细节，使用平滑曲线或尖锐的轮廓。如果是瘦长型的图形，将它转45度角再填满内容区。线的宽度不应低于2 dp。</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_colors.png" alt="iconography_actionbar_colors" /></p>

<p>Colors for Light<br/>
Colors: #333333<br/>
Enabled: 60% opacity<br/>
Disabled: 30% opacity</p>

<p>Colors for Dark<br/>
Colors: #FFFFFF<br/>
Enabled: 80% opacity<br/>
Disabled: 30% opacity</p>

<h3>Small / Contextual Icons</h3>

<p>小图标与上下文图标</p>

<p>在应用的主体区域中，使用⼩图标表示操作或者特定对象的状态。例如在 Gmail 应用中，每条信息都有⼀个星型图标用来标记“重要”。</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_size.png" alt="iconography_small_size" /></p>

<p>Sizes &amp; scale<br/>
Small icons should be 16x16 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_focal.png" alt="iconography_small_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 16x16 dp<br/>
Optical square, 12x12 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_style.png" alt="iconography_small_style" /></p>

<p>Style<br/>
Neutral, flat, and simple. Filled shapes are easier to see than thin strokes. Use a single visual metaphor so that a user can easily recognize and understand its purpose.<br/>
灰色为主、扁平和简单。最好使用填充图标而不是细线条勾勒。使用简单直观的图形，让用户容易理解图标的作用。</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_colors.png" alt="iconography_small_colors" /></p>

<p><img src="http://xuanxi.github.io/images/iconography_small_example.png" alt="iconography_small_example" /></p>

<p>Colors<br/>
在特殊情况下使用非灰色的图标。例如在 Gmail 应用中，使用了黄色的星型图标表示重要的信息。如果图标是可点击的，使用和背景形成对比的颜色。</p>

<h3>Notification Icons</h3>

<p>通知图标</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_size.png" alt="iconography_notification_size" /></p>

<p>Sizes &amp; scale<br/>
Notification icons must be 24x24 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_focal.png" alt="iconography_notification_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 24x24 dp<br/>
Optical square, 22x22 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_style.png" alt="iconography_notification_style" /></p>

<p>Style<br/>
Keep the style flat and simple, using the same single, visual metaphor as your launcher icon.<br/>
扁平，简单，类似启动图标。</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_example.png" alt="iconography_notification_example" /></p>

<p>Colors<br/>
Notification icons must be entirely white. Also, the system may scale down and/or darken the icons.<br/>
通知图标必须为纯白色，另外，系统会缩小图标或令图标变暗。</p>

<h3>Design Tips</h3>

<p>下面是一些图标设计建议，这些建议假设你使用 Photoshop 或者其它栅格或矢量图形工具。</p>

<h4>Use vector shapes where possible</h4>

<p>尽量使用矢量图</p>

<h4>Start with large artboards</h4>

<p>从大画板开始设计</p>

<h4>When scaling, redraw bitmap layers as needed</h4>

<p>？？</p>

<h4>Use common naming conventions for icon assets</h4>

<p> 使用统一的命名方法，使得所有图标在文件夹中会聚在一起并按字母顺序排列，如下图：</p>

<p><img src="http://xuanxi.github.io/images/icon_common_naming.png" alt="icon_common_naming" /></p>

<h4>Set up a working space that organizes files by density</h4>

<p>为不同密度图标建立对应文件夹：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>art/...
</span><span class='line'>    mdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png
</span><span class='line'>    hdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png
</span><span class='line'>    xhdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png</span></code></pre></td></tr></table></div></figure>


<h4>Remove unnecessary metadata from final assets</h4>

<p>尽管 Android 在打包时会自动压缩 png 图片，但图片中仍然包含着不必要的头部信息和 metadata，你应该把这些信息也删除掉。可以使用以下两个工具：<br/>
<a href="http://optipng.sourceforge.net/">OptiPNG</a><br/>
<a href="http://pmt.sourceforge.net/pngcrush/">Pngcrush</a>。</p>

<h2>8. Your Branding</h2>

<p>你的品牌</p>

<p>遵循 Android 的设计模式并不意味着你的应用和其它应用没什么区别，相反，你的应用可以表现出你的品牌的特点。</p>

<h3>Color</h3>

<p>品牌颜色</p>

<p>用你的品牌颜色取代 Android 默认的蓝色，新的颜色将会体现在复选框、进度条、单选按钮、滑动条、tab 按钮、滑动指示等常用控件上。</p>

<p>在合适的地方用高对比度的颜色来作强调，比如 action bar 的背景颜色或者一个主要的按钮。记住不要过度使用这种颜色，因为不是所有操作都同等重要，所以只能用在一到两个最重要的地方。</p>

<p>在自定义颜色的时候，记得对触摸反馈也做出轻微调整——比原始状态稍亮或稍暗，具体可参考 “3.Touch Feedback”。</p>

<p><img src="http://xuanxi.github.io/images/branding_wallet.png" alt="branding_wallet" /></p>

<p>The four colors of the Google Wallet logo provide a playful accent to the four dots that appear as the user enters a PIN.</p>

<p><img src="http://xuanxi.github.io/images/branding_googlemusic.png" alt="branding_googlemusic" /></p>

<p>The Google Play Music app has an orange theme color, which is used for emphasis in the action bar and for accent in the selected tab, scroll indicator, and hyperlinks.</p>

<h3>Logo</h3>

<p>品牌 logo</p>

<p>首先要明确的是，启动图标（launcher icon）不等于 logo，启动图标只是基于 logo 设计的图标。不过，启动图标是一个展示品牌 logo 的关键，因为用户要寻找它并通过它来启动应用。直接把启动图标放在 action bar 上就可以达到展示品牌的目的。</p>

<p>另一方法是将 logo 放在 action bar 上，而不是使用启动图标和应用名字。</p>

<p><img src="http://xuanxi.github.io/images/branding_launcher_icon.png" alt="branding_launcher_icon" /></p>

<p><img src="http://xuanxi.github.io/images/branding_logo_icon_action_bar.png" alt="branding_logo_icon_action_bar" /></p>

<p>Google+ 直接把启动图标放在 action bar 上。</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_app.png" alt="yourbranding_app" /></p>

<p>将 logo 放在 action bar 上的例子。</p>

<h3>Icons</h3>

<p>品牌图标</p>

<p>如果你在其它平台的 app 上有符合你的品牌要求的图标，也可以用到 Android 上来，但要确保品牌与这些图标的风格一致。</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_in-app-icons.png" alt="yourbranding_in-app-icons" /></p>

<p>One exception: For any icon in your existing set where the symbol is different from Android&rsquo;s, use Android&rsquo;s symbol but give it your brand&rsquo;s styling. That way, users will understand what the purpose of the icon is based on what they&rsquo;ve learned in other Android apps (Design principle: Give me tricks that work everywhere). But the icon will still look like it belongs with all of your other icons as a part of your brand.</p>

<p>Example:<br/>
The brand&rsquo;s normal icon for sharing on other platforms is a right arrow.</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_sharing.png" alt="yourbranding_sharing" /></p>

<p>如果你没有自己的图标，并且只创建 Android 应用，这样的话，可以使用 Android 提供的标准图标，而通过颜色和 logo 来展示你的品牌。（对设计能力不足的小团队可以这样做）</p>

<h2>9. Writing Style</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不要因为学太多而压垮自己]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/25/dont-overwhelm-trying-learn-much/"/>
    <updated>2014-07-25T11:16:38+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/25/dont-overwhelm-trying-learn-much</id>
    <content type="html"><![CDATA[<p><a href="http://simpleprogrammer.com/2014/06/23/dont-overwhelm-trying-learn-much/"><em>Don’t Overwhelm Yourself Trying to Learn Too Much</em></a> 一文是作者 John Sonmez 对学习新技术的看法，我对此也深有体会，以下为摘录和笔记。</p>

<!--more-->


<p>参考译文：<br/>
<a href="http://blog.jobbole.com/73648/">http://blog.jobbole.com/73648/</a></p>

<h4>作者首先提出软件开发领域中遇到的困扰：</h4>

<p><em>But, in the software development field, sometimes there are so many new technologies, so many things to learn, that we can start to feel overwhelmed and like all we ever do is learn.<br/>
在软件开发领域，有如此多的新技术，有如此多要学习的东西，以致我们感觉快要崩溃。</em></p>

<p><em>You can start to feel like you are always playing catch-up, but never actually getting ahead–not even keeping up. The treadmill is going just a few paces faster than you can run, and you are slowly losing ground, threatening to drop off the end at any time.<br/>
你感觉你一直在扮演追赶的角色，却一直都赶不上，甚至无法坚持下去。就像是跑步机一直比你能跑的最快速度还要快几步，你一直受挫，还有在最后关头掉队的危险。</em></p>

<h4>然后结合自己的亲身经历指出问题所在——学习量太大：</h4>

<p><em>The problem is trying to learn too much. There are 100 different technologies you have to work with or want to work with at your job. You might feel that in order to be competent, in order to be the best you can be, you need to learn and master all of them. The problem though, is that you feel like you haven’t even mastered one of them.<br/>
问题就是尝试学太多导致的。有100种不同的技术，这些都是你必须或想要在工作中应用的。你感觉为了能够胜任，为了做到最好，你需要学习和精通所有的这些技术。然而问题是，你感觉你其实一个都不精通。</em></p>

<p><em>You spend your nights and weekends reading books, going through online training, and reading blog posts.But. is it really effective, or does it just stress you out more?Do you even remember half of what you read?<br/>
你把晚上和周末的时间都用来读书，进行在线训练并且读一些博客。<br/>
但是，这样是真的有效，还是让你承受了太大的压力？<br/>
你能记得你读的一半内容吗？</em></p>

<h4>解决办法：Just-in-time learning</h4>

<p><em>Instead, I think the best way to improve your skills and to learn what you need to do is to do the learning as close to the time you need the information as possible–just-in-time learning.<br/>
我认为提高技能的最好方法是：在你的确需要用到这方面知识的时候才去学习。</em></p>

<p><em>Now, this doesn’t mean that you should just start working with a technology before you know anything about it. You’ll waste a lot of time flopping around trying to get started if you just dive right in without any prior knowledge. But, I’ve found you only need to learn three things before you can dive in and start working with a technology:<br/>
How to get started<br/>
What you can do with the technology–how big it is.<br/>
The basics–the most common things you’ll do 90% of the time.<br/>
接下来，这不意味着在了解一门技术前就开始相关的工作。如果你对要使用的技术一无所知，你会在开始阶段就浪费大量时间。但是，我发现只要先了解关于这门技术的三件事，你就能够开始使用它去工作了。<br/>
1. 这门技术应该如何起步<br/>
2. 这门技术可以做什么<br/>
3. 这门技术最基础的知识，即90%的时间里都会用到的东西</em></p>

<p><em>It is no coincidence that I structure most of my online courses in that way. I try to tell you how to get started, show you what is possible and then give you the very basics. I try to avoid going into details about every little aspect of a technology, because you are better off learning that information when you need it. As long as you know what you can do, you can always find out how later.<br/>
这并非巧合，我大部分的在线课程都是这样的结构。我试着告诉你如何起步，展示它能做的，并且告诉你一些基础。我试着避免深入技术各个方面的细节，因为这些东西最好是你需要它们的时候再去学习比较好。只要你知道了如何做，具体的细节可以以后再学习。</em></p>

<p><em>Often the hardest part of learning a new technology is learning what is possible.<br/>
通常，学一门新技术最难的地方是学习它能实现什么。</em></p>

<p><em>I’ve found that the faster you start actually using a technology and trying to solve real problems with it the better. Once you’ve covered the three bases I’ve mentioned above, your time is much better spent actually working with the technology rather than learning about it further.<br/>
我发现，越快在实际中应用一项技术并且解决实际的问题，越能够有提高。只要你做到了以上我提到的三点，能让你的时间更好的花在用技术解决工作中的问题而不是仅仅学习技术本身。</em></p>

<h4>新问题：You can’t know everything</h4>

<p><em>Even if you had all the time in the world to learn, and even if you apply just-in-time learning techniques, you still won’t ever learn a fraction of what there is to learn in the software development field. New technologies are popping up every day and the depth of existing ones increases at an alarming rate.<br/>
即使你有足够的时间学习，即使你运用 just-in-time learning，你仍然只会学到软件开发领域的一点点。新技术每天都在出现，现有的技术也在不断发展。</em></p>

<h4>解决办法：Specializing and General Knowledge</h4>

<p><em>It is important to face the reality that you just can’t know it all. Not only can you not know it all, but what you can know is just a tiny fraction of what there is to know.<br/>
意识到你不可能把所有的东西都学会是很重要的。你不可能全部学会，而你知道的可能只是现有技术的一小部分。</em></p>

<p><em>This is one of the main reasons why I talk about specializing so much. You are much better off picking a single technology that you can focus on learning in-depth than spreading yourself too thin trying to be a master at everything.<br/>
这是我谈到专门钻研某一方面的原因之一。你最好能选一门技术，并且深入钻研它而不是所有的技术都想要精通。</em></p>

<p><em>That doesn’t mean you shouldn’t expand your skills in many different directions; you should definitely try to have a broad base. Just don’t expect to be an expert in more than one or two main areas of focus. <br/>
这不意味着你不应该在不同的方向上扩展你的技术，相反，你当然应该尝试不同的东西，但不要觉得你能在好几个领域内都能够精通。</em></p>

<p><em>A single specialty that you will master<br/>
General software development skills that will apply to more than one technology. (For example, a book like Code Complete falls in this category.)<br/>
尝试让你的学习集中在以下两个方面：<br/>
1. 一个你要精通的特长<br/>
2. 在软件开发领域里通用的技术（如《代码大全》）</em></p>

<p><em>Don’t try and spread yourself too thin. Rely on your ability to learn things as you need them. If you have a solid base, with time and experience, you’ll find that you can learn whatever you need to know when you need to know it. Trust yourself.<br/>
不要去让自己的精力太分散。在你需要的时候根据自己的能力进行学习。如果你基础很好，依靠时间和经验，你能学会任何你需要用到的技术。</em></p>

<h4>Super-programmer ??</h4>

<p><em>Sometimes it can seem like there are super-programmers out there who seem to know everything and can do everything, but it is only an illusion. Those super-programmers are usually programmers that have one or two areas of expertise and a large amount of general knowledge that they apply to a variety of different domains.<br/>
有时候，一些超级程序员看起来什么都知道，并且什么都能做，但这只是幻觉。这些超级程序员通常是在一两个领域内非常精通，并且了解大量在很多领域里通用的知识。</em></p>

<hr />

<h3>关于自己</h3>

<p>之所以对 John Sonmez 的看法深有体会，是因为我也曾经犯过 Learning Too Much 的错误。在大学以及刚开始工作的时候，因为兴趣和工作需要我接触过各类技术：<br/>
游戏开发相关的C/C++/Lua/DirectX/OpenGL/OpenSceneGraph/OGRE；<br/>
移动开发相关的Java/Objective-C/Android/iOS/Symbian；<br/>
服务端开发相关的Struts/Spring/Hibernate/MySQL/Orecal/JavaScript/VMware；<br/>
桌面开发相关的MFC/.NET；<br/>
等等。</p>

<p>现在看来，其实并没有对任何一种技术有深入一点的掌握，反而长时间不使用的话就会忘得一干二净，更严重的是浪费了不少资源，包括时间和金钱。</p>

<p>后悔之余，现在要做的就是为自己选定一个方向。就如 John Sonmez 所说的，要将精力放在特长和通用技术上：<br/>
1. 移动开发：Android 为主，iOS 为辅，并适量掌握一些后端技术；<br/>
2. 通用技术：操作系统、算法等。</p>

<p>最后推荐一个非常实用的站点：<br/>
<a href="http://www.bento.io/">http://www.bento.io/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Styles and Themes]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/24/styles-and-themes/"/>
    <updated>2014-07-24T17:50:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/24/styles-and-themes</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/topics/ui/themes.html">http://developer.android.com/guide/topics/ui/themes.html</a></p>

<p>A style is a collection of properties that specify the look and format for a View or window. A style can specify properties such as height, padding, font color, font size, background color, and much more. A style is defined in an XML resource that is separate from the XML that specifies the layout.</p>

<p>一个 style 是某些属性的集合，这些属性定义了 view 或 window 的外观和格式，比如 height、padding、font color、font size、background color 等。</p>

<!--more-->


<p>Styles in Android share a similar philosophy to cascading stylesheets in web design—they allow you to separate the design from the content.</p>

<p>与 web 设计中的 CSS 相似，Android style 的目的是设计与内容分离。</p>

<p>例如，使用 style 的话，你可以将以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="wrap_content"
</span><span class='line'>    android:textColor="#00FF00"
</span><span class='line'>    android:typeface="monospace"
</span><span class='line'>    android:text="@string/hello" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>替换为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    style="@style/CodeFont"
</span><span class='line'>    android:text="@string/hello" /&gt;    </span></code></pre></td></tr></table></div></figure>


<p>A theme is a style applied to an entire Activity or application, rather than an individual View (as in the example above). When a style is applied as a theme, every View in the Activity or application will apply each style property that it supports. For example, you can apply the same CodeFont style as a theme for an Activity and then all text inside that Activity will have green monospace font.</p>

<p>theme 就是一个用于 Activity 和 application 的 style，而普通的 style 只用于单独的 view。当 style 被当做 theme 使用之后，在 Activity 或 application 中的所有 view 都会应用该 style 的属性。例如，你可以将一个字体 style 用作一个 Activity 的 theme，然后该 Activity 里的所有文本都会使用这个字体。</p>

<h2>Defining Styles</h2>

<p>To create a set of styles, save an XML file in the res/values/ directory of your project. The name of the XML file is arbitrary, but it must use the .xml extension and be saved in the res/values/ folder.<br/>
The root node of the XML file must be <code>&lt;resources&gt;</code>.</p>

<p>要创建一组 style，首先在 res/values/ 目录下创建一个 xml 文件，文件名可自定义，通常为 styles.xml。<br/>
文件的根节点为 <code>&lt;resoueces&gt;</code>。</p>

<p>以下为一个 style 示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt;
</span><span class='line'>        &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:typeface"&gt;monospace&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<p>Each child of the <code>&lt;resources&gt;</code> element is converted into an application resource object at compile-time, which can be referenced by the value in the <code>&lt;style&gt;</code> element&rsquo;s name attribute. This example style can be referenced from an XML layout as @style/CodeFont (as demonstrated in the introduction above).</p>

<p>每个 <code>&lt;resources&gt;</code> 元素的子节点在编译时都被转换为一个应用程序资源对象，其可以通过 <code>&lt;style&gt;</code> 元素的 <code>name</code> 属性的值来引用，如 <code>style="@style/CodeFont"</code>。</p>

<p>The parent attribute in the <code>&lt;style&gt;</code> element is optional and specifies the resource ID of another style from which this style should inherit properties. You can then override the inherited style properties if you want to.</p>

<p><code>&lt;style&gt;</code> 中的 parent 属性是可选的，用来指定另外一个 style 的资源ID，前者继承后者的所有属性。你也可以覆写继承来的 style 属性。</p>

<p>Remember, a style that you want to use as an Activity or application theme is defined in XML exactly the same as a style for a View. A style such as the one defined above can be applied as a style for a single View or as a theme for an entire Activity or application. How to apply a style for a single View or as an application theme is discussed later.</p>

<p>用在 Activity 或应用程序上的 theme 的定义方式和 style 的定义方式是相同的。一个如同上面那样例子中定义的 style 既可以用作一个 View的 style，也可以用作一个 Activity 或应用程序的 theme。</p>

<h3>Inheritance</h3>

<p>The parent attribute in the <code>&lt;style&gt;</code> element lets you specify a style from which your style should inherit properties. You can use this to inherit properties from an existing style and then define only the properties that you want to change or add. You can inherit from styles that you&rsquo;ve created yourself or from styles that are built into the platform. (See Using Platform Styles and Themes, below, for information about inheriting from styles defined by the Android platform.) For example, you can inherit the Android platform&rsquo;s default text appearance and then modify it:</p>

<p>parent 属性让你可以继承一个 style，然后定义你想改变或添加的属性。你可以从自定义的 style 或者平台的 style 中继承：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="GreenText" parent="@android:style/TextAppearance"&gt;
</span><span class='line'>    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>If you want to inherit from styles that you&rsquo;ve defined yourself, you do not have to use the parent attribute. Instead, just prefix the name of the style you want to inherit to the name of your new style, separated by a period. For example, to create a new style that inherits the CodeFont style defined above, but make the color red, you can author the new style like this:</p>

<p>如果你要继承自定义的 style，不必用到 parent，仅需要把父 style 名字作为新 style 名字的前缀即可，中间用点分隔：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="CodeFont.Red"&gt;
</span><span class='line'>    &lt;item name="android:textColor"&gt;#FF0000&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>Notice that there is no parent attribute in the <code>&lt;style&gt;</code> tag, but because the name attribute begins with the CodeFont style name (which is a style that you have created), this style inherits all style properties from that style. This style then overrides the android:textColor property to make the text red. You can reference this new style as @style/CodeFont.Red.</p>

<p>上面的 style 使用 <code>@style/CodeFont.Red</code> 来引用。</p>

<p>You can continue inheriting like this as many times as you&rsquo;d like, by chaining names with periods. For example, you can extend CodeFont.Red to be bigger, with:</p>

<p>也可以多次继承：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="CodeFont.Red.Big"&gt;
</span><span class='line'>    &lt;item name="android:textSize"&gt;30sp&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>Note: This technique for inheritance by chaining together names only works for styles defined by your own resources. You can&rsquo;t inherit Android built-in styles this way. To reference a built-in style, such as TextAppearance, you must use the parent attribute.</p>

<p>要注意的是，前缀加点间隔的方法仅使用与自定义的 style，并不适用于平台内建的 style。</p>

<h3>Style Properties</h3>

<p>Now that you understand how a style is defined, you need to learn what kind of style properties—defined by the <item> element—are available. You&rsquo;re probably familiar with some already, such as layout_width and textColor. Of course, there are many more style properties you can use.</p>

<p>接下来，你需要了解在 <code>&lt;style&gt;</code> 的 <code>&lt;item&gt;</code> 元素中可以定义哪些属性值。比如你可能已经知道的 layout_width 和 textColor 等等。</p>

<p>The best place to find properties that apply to a specific View is the corresponding class reference, which lists all of the supported XML attributes. For example, all of the attributes listed in the table of TextView XML attributes can be used in a style definition for a TextView element (or one of its subclasses). One of the attributes listed in the reference is android:inputType, so where you might normally place the android:inputType attribute in an <EditText> element, like this:</p>

<p>要知道某个 view 的所有属性，最好的地方就是它的官方参考文档（比如 TextView 的 &lt;<a href="http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8">http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8</a> XML Attributes 的地方就列出了所有支持的属性，这些属性都可以用在 style 里。</p>

<p>下面以 EditText 的 android:inputType 属性为例子，一般情况你可以在布局中直接使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;EditText
</span><span class='line'>    android:inputType="number"
</span><span class='line'>    ... /&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以定义一个 style：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="Numbers"&gt;
</span><span class='line'>  &lt;item name="android:inputType"&gt;number&lt;/item&gt;
</span><span class='line'>  ...
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>然后你的布局变成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;EditText
</span><span class='line'>    style="@style/Numbers"
</span><span class='line'>    ... /&gt;</span></code></pre></td></tr></table></div></figure>


<p>This simple example may look like more work, but when you add more style properties and factor-in the ability to re-use the style in various places, the pay-off can be huge.</p>

<p>这个例子看起来是增加了工作量，但当你的 style 里包含了更多的属性，并且在多个布局中都使用到这个 style 的时候，style 的作用就会凸显。</p>

<p>For a reference of all available style properties, see the R.attr reference. Keep in mind that all View objects don&rsquo;t accept all the same style attributes, so you should normally refer to the specific View class for supported style properties. However, if you apply a style to a View that does not support all of the style properties, the View will apply only those properties that are supported and simply ignore the others.</p>

<p>要知道的是，不是所有的 View 都接受相同的 style 属性，所以你应该先查看所支持的属性。不过，如果一个 style 中包含了 View 不支持的属性，这些属性会被忽略。</p>

<p>Some style properties, however, are not supported by any View element and can only be applied as a theme. These style properties apply to the entire window and not to any type of View. For example, style properties for a theme can hide the application title, hide the status bar, or change the window&rsquo;s background. These kind of style properties do not belong to any View object. To discover these theme-only style properties, look at the R.attr reference for attributes that begin with window. For instance, windowNoTitle and windowBackground are style properties that are effective only when the style is applied as a theme to an Activity or application. See the next section for information about applying a style as a theme.</p>

<p>有些属性不被任何 View 支持，只能用作 theme，比如隐藏应用标题栏，隐藏状态栏，改变窗口背景等。<a href="http://developer.android.com/reference/android/R.attr.html">R.attr</a> 中以 <code>windows</code> 起头的属性就是这样的属性。</p>

<p>Note: Don&rsquo;t forget to prefix the property names in each <code>&lt;item&gt;</code> element with the android: namespace. For example: <code>&lt;item name="android:inputType"&gt;</code>.</p>

<p>注意，每一个属性要使用 <code>android:</code> 作为命名空间。</p>

<h2>Applying Styles and Themes to the UI</h2>

<p>应用 Styles 和 Themes</p>

<p>有两种方式设置一个 style：<br/>
对一个独立的 View，添加 style 属性到你的布局的 View 元素中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    style="@style/CodeFont"
</span><span class='line'>    android:text="@string/hello" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>对一个 Activity 或应用，添加 <code>android:theme</code> 属性到 Android manifest 的 <code>&lt;activity&gt;</code> 或 <code>&lt;application&gt;</code> 元素中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;application android:theme="@style/CustomTheme"&gt;
</span><span class='line'>&lt;activity android:theme="@style/CustomTheme"&gt;</span></code></pre></td></tr></table></div></figure>


<h2>Using Platform Styles and Themes</h2>

<p>The Android platform provides a large collection of styles and themes that you can use in your applications. You can find a reference of all available styles in the R.style class. To use the styles listed here, replace all underscores in the style name with a period. For example, you can apply the Theme_NoTitleBar theme with &ldquo;@android:style/Theme.NoTitleBar&rdquo;.</p>

<p>Android 平台提供了大量的 style 和 theme 供你使用。你可以在<a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 类中找到所有可用的 style，只需要用句号替换 style 名称中的下划线即可。例如，你可以通过 <code>@android:style/Theme.NoTitleBar</code> 使用 Theme_NoTitleBar theme。</p>

<p>The R.style reference, however, is not well documented and does not thoroughly describe the styles, so viewing the actual source code for these styles and themes will give you a better understanding of what style properties each one provides. For a better reference to the Android styles and themes, see the following source code:</p>

<p>由于 <a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 文档的不完善，你可以查看源码以更深入了解这些 style 的定义情况：<br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/styles.xml">Android Styles (styles.xml)</a><br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml">Android Themes (themes.xml)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing for Multiple Screens]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens/"/>
    <updated>2014-07-17T22:07:15+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/training/multiscreen/index.html">http://developer.android.com/training/multiscreen/index.html</a></p>

<p>Android powers hundreds of device types with several different screen sizes, ranging from small phones to large TV sets. Therefore, it’s important that you design your application to be compatible with all screen sizes so it’s available to as many users as possible.<br/>
But being compatible with different device types is not enough. Each screen size offers different possibilities and challenges for user interaction, so in order to truly satisfy and impress your users, your application must go beyond merely supporting multiple screens: it must optimize the user experience for each screen configuration.</p>

<p>Android 设备的多样性要求应用的显示要适配多种屏幕尺寸，但仅仅让应用正常显示在多种屏幕上并不足够，因为不同尺寸的屏幕提供不同的交互能力，设计者应该做出适当优化以更好的利用屏幕。</p>

<p>本篇包含以下三部分：<br/>
1. Supporting Different Screen Sizes；<br/>
2. Supporting Different Screen Densities；<br/>
3. Implementing Adaptative UI Flows。</p>

<!--more-->


<p>推荐文章：<br/>
<a href="http://stormzhang.github.io/android/2014/05/16/android-screen-adaptation/">Android 屏幕适配</a></p>

<h2>1. Supporting Different Screen Sizes</h2>

<p>本篇将告诉你如何让应用支持不同尺寸的屏幕，有以下几种办法：<br/>
让布局自适应屏幕<br/>
根据屏幕的配置来加载合适的UI布局<br/>
确保正确的布局应用在正确的设备屏幕上<br/>
提供可以根据屏幕大小自动伸缩的图片</p>

<h3>Use &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo;</h3>

<p>To ensure that your layout is flexible and adapts to different screen sizes, you should use &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo; for the width and height of some view components.</p>

<p>使用 wrap_content 和 match_parent 可以确保布局自适应到不同的屏幕。</p>

<p><img src="http://xuanxi.github.io/images/layout-hvga.png" alt="layout-hvga" /><br/>
上图中的横竖两种状态时是自动适配屏幕的。</p>

<h3>Use RelativeLayout</h3>

<p>You can construct fairly complex layouts using nested instances of LinearLayout and combinations of &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo; sizes. However, LinearLayout does not allow you to precisely control the spacial relationships of child views; views in a LinearLayout simply line up side-by-side. If you need child views to be oriented in variations other than a straight line, a better solution is often to use a RelativeLayout, which allows you to specify your layout in terms of the spacial relationships between components. For instance, you can align one child view on the left side and another view on the right side of the screen.</p>

<p>LinearLayout 用于简单的线性布局，而 RelativeLayout 提供了更灵活的手段去布置子控件。</p>

<p><img src="http://xuanxi.github.io/images/relativelayout1.png" alt="relativelayout1" /></p>

<h3>Use Size Qualifiers 使用size限定符</h3>

<p>While those layouts adapt to different screens by stretching the space within and around components, they may not provide the best user experience for each screen size. Therefore, your application should not only implement flexible layouts, but should also provide several alternative layouts to target different screen configurations.</p>

<p>一种布局自适应所有屏幕并不代表提供了最好的用户体验，还要考虑为不同大小的屏幕建立不同的布局，以充分发挥不同尺寸屏幕的各自的优势。</p>

<p>For example, many applications implement the &ldquo;two pane&rdquo; pattern for large screens (the app might show a list of items on one pane and the content on another pane). Tablets and TVs are large enough for both panes to fit simultaneously on screen, but phone screens have to show them separately. So, to implement these layouts, you could have the following files:</p>

<p>举个例子，很多应用都会有两个功能窗口，一个是列表，一个是列表项详情，对于平板或电视的大屏幕，一次就可以展示这两个窗口，而手机屏幕只能展示一个。以下示例使用了一个 layout 布局和一个 layout-large 布局，应用在运行时会根据屏幕大小读取对应的布局：</p>

<p>res/layout/main.xml, single-pane (default) layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:orientation="vertical"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"&gt;
</span><span class='line'>
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="match_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/layout-large/main.xml, two-pane layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Use the Smallest-width Qualifier 使用最小宽度限定符</h3>

<p>One of the difficulties developers had in pre-3.2 Android devices was the &ldquo;large&rdquo; screen size bin, which encompasses the Dell Streak, the original Galaxy Tab, and 7&#8221; tablets in general. However, many applications may want to show different layouts for different devices in this category (such as for 5&#8221; and 7&#8221; devices), even though they are all considered to be &ldquo;large&rdquo; screens. That&rsquo;s why Android introduced the &ldquo;Smallest-width&rdquo; qualifier (amongst others) in Android 3.2.</p>

<p>在 3.2 版本系统之前，使用 Size 限定符有一个问题会让很多程序员感到头疼，large 到底是指多大呢？很多时候5寸和7寸都被当做 large，但很多应用都希望能够更自由地为不同屏幕设备加载不同的布局，不管它们是不是被系统认定为&#8221;large&#8221;。这就是Android为什么在3.2以后引入了&#8221;Smallest-width&#8221;限定符。</p>

<p>The Smallest-width qualifier allows you to target screens that have a certain minimum width given in dp. For example, the typical 7&#8221; tablet has a minimum width of 600 dp, so if you want your UI to have two panes on those screens (but a single list on smaller screens), you can use the same two layouts from the previous section for single and two-pane layouts, but instead of the large size qualifier, use sw600dp to indicate the two-pane layout is for screens on which the smallest-width is 600 dp:</p>

<p>Smallest-width 限定符允许你设定一个具体的最小值(以dp为单位)来指定屏幕。例如，7寸的平板最小宽度是600dp，所以如果你想让你的UI在这种屏幕上显示 two pane，在更小的屏幕上显示 single pane，你可以使用sw600dp来表示你想在600dp以上宽度的屏幕上使用 two pane 模式：</p>

<p>res/layout/main.xml, single-pane (default) layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:orientation="vertical"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"&gt;
</span><span class='line'>
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="match_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/layout-sw600dp/main.xml, two-pane layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>This means that devices whose smallest width is greater than or equal to 600dp will select the layout-sw600dp/main.xml (two-pane) layout, while smaller screens will select the layout/main.xml (single-pane) layout.</p>

<p>这意味着，那些最小屏幕宽度大于600dp的设备会选择 layout-sw600dp/main.xml(two-pane)布局，而更小屏幕的设备将会选择 layout/main.xml(single-pane)布局。</p>

<p>However, this won&rsquo;t work well on pre-3.2 devices, because they don&rsquo;t recognize sw600dp as a size qualifier, so you still have to use the large qualifier as well. So, you should have a file named res/layout-large/main.xml which is identical to res/layout-sw600dp/main.xml. In the next section you&rsquo;ll see a technique that allows you to avoid duplicating the layout files this way.</p>

<p>可是，3.2系统之前不支持 Smallest-width 限定符，你仍然需要 large 限定符去兼容那些老系统，即需要同时存在 layout-sw600dp 和 layout-large，并且里面的布局文件是一样的。可是，这样就造成重复定义布局的问题，下一节会介绍一种避免重复布局的技术。</p>

<h3>Use Layout Aliases 布局别名</h3>

<p>The smallest-width qualifier is available only on Android 3.2 and above. Therefore, you should also still use the abstract size bins (small, normal, large and xlarge) to be compatible with earlier versions. For example, if you want to design your UI so that it shows a single-pane UI on phones but a multi-pane UI on 7&#8221; tablets, TVs and other large devices, you&rsquo;d have to supply these files:<br/>
&hellip;</p>

<p>Smallest-width 限定符仅在 Android 3.2及之后的系统中有效。所以，你需要同时使用 Size 限定符(small, normal, large 和 xlarge)来兼容更早的系统。例如，你想手机上显示 single-pane 界面，而在7寸平板和更大屏的设备上显示 multi-pane 界面，你需要提供以下文件：<br/>
res/layout/main.xml: single-pane 布局<br/>
res/layout-large/main.xml: multi-pane 布局<br/>
res/layout-sw600dp/main.xml: multi-pane 布局</p>

<p>The last two files are identical, because one of them will be matched by Android 3.2 devices, and the other one is for the benefit of tablets and TVs with earlier versions of Android.</p>

<p>最后的两个文件是完全相同的，一个用于3.2及以上系统，一个用于3.2以下系统。</p>

<p>To avoid this duplication of the same file for tablets and TVs (and the maintenance headache resulting from it), you can use alias files. For example, you can define the following layouts:<br/>
&hellip;</p>

<p>使用别名来避免重复。例如，可以定义以下布局：<br/>
res/layout/main.xml, single-pane layout<br/>
res/layout/main_twopanes.xml, two-pane layout</p>

<p>加入以下两个 values 文件：</p>

<p>res/values-large/layout.xml:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/values-sw600dp/layout.xml:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Use Orientation Qualifiers 使用方向限定符</h3>

<p>Some layouts work well in both landscape and portrait orientations, but most of them can benefit from adjustments. In the News Reader sample app, here is how the layout behaves in each screen size and orientation:<br/>
&hellip;</p>

<p>有些布局在横竖屏时都显示正常，但大多数情况下可以做调整以显示更好。例如，在 News Reader 示例程序中，布局在不同屏幕尺寸和不同屏幕方向中是这样显示的：<br/>
小屏幕, 竖屏: 单面板, 显示logo<br/>
小屏幕, 横屏: 单面板, 显示logo<br/>
7寸平板, 竖屏: 单面板, 显示action bar<br/>
7寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
10寸平板, 竖屏: 双面板, 窄, 显示action bar<br/>
10寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
电视, 横屏: 双面板, 宽, 显示action bar</p>

<p>具体代码不再展示：）</p>

<h3>Use Nine-patch Bitmaps 使用点9图</h3>

<p>略：）</p>

<h2>2. Supporting Different Densities</h2>

<p>上一篇解决了怎样让布局适配屏幕的问题，本篇解决怎样让控件显示正确和让图片显示最佳的问题。</p>

<p>Android 提供两种方式支持不同的屏幕密度：<br/>
Use Density-independent Pixels<br/>
Provide Alternative Bitmaps</p>

<h3>Use Density-independent Pixels</h3>

<p>Android 设备屏幕有多种密度，在布局时要避免使用像素来定义尺寸，而应该使用 dp 或 sp。<br/>
dp 是密度无关单位，在 160dpi 屏幕下，1dp=1px；<br/>
sp 与 dp 类似，是缩放比例无关单位，用于文字。</p>

<h3>Provide Alternative Bitmaps</h3>

<p>不同密度对应不用的图片：<br/>
xhdpi: 2.0<br/>
hdpi: 1.5<br/>
mdpi: 1.0 (baseline)<br/>
ldpi: 0.75</p>

<h2>3. Implementing Adaptative UI Flows</h2>

<p>上两篇介绍了如何布局及配置图片资源，本篇介绍如何在代码里执行对应的界面流程。</p>

<p>Depending on the layout that your application is currently showing, the UI flow may be different. For example, if your application is in the dual-pane mode, clicking on an item on the left pane will simply display the content on the right pane; if it is in single-pane mode, the content should be displayed on its own (in a different activity).</p>

<p>根据设备屏幕的不同，Android 会调用对应的布局，同时也要求代码里执行与布局对应的界面流程。例如，如果此时应用是 dual-pane 模式布局，在左边点击 item 后，右边应该直接显示内容；如果是 single-pane 模式布局，内容应该通过打开另一个 activity 显示。</p>

<h3>Determine the Current Layout</h3>

<p>确定当前布局</p>

<p>Since your implementation of each layout will be a little different, one of the first things you will probably have to do is determine what layout the user is currently viewing. For example, you might want to know whether the user is in &ldquo;single pane&rdquo; mode or &ldquo;dual pane&rdquo; mode. You can do that by querying if a given view exists and is visible:</p>

<p>因为针对不同布局的具体实现会略有不同，所以你在处理界面之前应该首先确定当前使用的是哪个布局。例如，你需要知道当前是 dual-pane 还是 single-pane。你可以通过查询某个 view 是否存在来确定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class NewsReaderActivity extends FragmentActivity {
</span><span class='line'>    boolean mIsDualPane;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void onCreate(Bundle savedInstanceState) {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.main_layout);
</span><span class='line'>
</span><span class='line'>        View articleView = findViewById(R.id.article);
</span><span class='line'>        mIsDualPane = articleView != null && 
</span><span class='line'>                        articleView.getVisibility() == View.VISIBLE;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以上代码查询 article 是否存在，存在的话说明是 dual-pane 模式。这种方式比直接查询调用了哪个布局更灵活简单。</p>

<p>Another example of how you can adapt to the existence of different components is to check whether they are available before performing an operation on them. For example, in the News Reader sample app, there is a button that opens a menu, but that button only exists when running on versions older than Android 3.0 (because it&rsquo;s function is taken over by the ActionBar on API level 11+). So, to add the event listener for this button, you can do:</p>

<p>也可以在执行动作前检查 view 是否存在：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Button catButton = (Button) findViewById(R.id.categorybutton);
</span><span class='line'>OnClickListener listener = /* create your listener here */;
</span><span class='line'>if (catButton != null) {
</span><span class='line'>    catButton.setOnClickListener(listener);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>React According to Current Layout</h3>

<p>响应当前布局</p>

<p>Some actions may have a different result depending on the current layout. For example, in the News Reader sample, clicking on a headline from the headlines list opens the article in the right hand-side pane if the UI is in dual pane mode, but will launch a separate activity if the UI is in single-pane mode:</p>

<p>确定了当前布局后，就可以根据不同的布局做出不同的响应了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public void onHeadlineSelected(int index) {
</span><span class='line'>    mArtIndex = index;
</span><span class='line'>    if (mIsDualPane) {
</span><span class='line'>        /* display article on the right pane */
</span><span class='line'>        mArticleFragment.displayArticle(mCurrentCat.getArticle(index));
</span><span class='line'>    } else {
</span><span class='line'>        /* start a separate activity */
</span><span class='line'>        Intent intent = new Intent(this, ArticleActivity.class);
</span><span class='line'>        intent.putExtra("catIndex", mCatIndex);
</span><span class='line'>        intent.putExtra("artIndex", index);
</span><span class='line'>        startActivity(intent);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Reuse Fragments in Other Activities</h3>

<p>在其它 Activity 中重用 Fragment</p>

<p>A recurring pattern in designing for multiple screens is having a portion of your interface that&rsquo;s implemented as a pane on some screen configurations and as a separate activity on other configurations. For example, in the News Reader sample, the news article text is presented in the right side pane on large screens, but is a separate activity on smaller screens.</p>

<p>在支持多种屏幕的设计中有一种重用模式，就是把界面的一部分当做一个独立体，这个独立体在大屏幕中是一个 pane，在小屏幕中是一个 activity。这种模式可以使用 fragment 来实现。</p>

<p>例如，定义一个 ArticleFragment，大屏幕时用在 dual-pane 布局中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>小屏幕时用在 ArticleActivity 中（无需再针对 activity 布局）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ArticleFragment frag = new ArticleFragment();
</span><span class='line'>getSupportFragmentManager().beginTransaction().add(android.R.id.content, frag).commit();</span></code></pre></td></tr></table></div></figure>


<p>One very important point to keep in mind when designing your fragments is to not create a strong coupling to a specific activity. You can usually do that by defining an interface that abstracts all the ways in which the fragment needs to interact with its host activity, and then the host activity implements that interface:</p>

<p>在设计 fragment 时我们需要注意的一点是：不要为特定的 activity 创建强耦合的 fragment。你可以在 Fragment 里创建接口，通过接口和 activity 进行交互：
例如，HeadlinesFragment 这样设计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class HeadlinesFragment extends ListFragment {
</span><span class='line'>    ...
</span><span class='line'>    OnHeadlineSelectedListener mHeadlineSelectedListener = null;
</span><span class='line'>
</span><span class='line'>    /* Must be implemented by host activity */
</span><span class='line'>    public interface OnHeadlineSelectedListener {
</span><span class='line'>        public void onHeadlineSelected(int index);
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>    public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener listener) {
</span><span class='line'>        mHeadlineSelectedListener = listener;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>activity 需要实现这个接口，这样，当用户点击左边 item 的时候，fragment 会通知 host activity 的 listener 进行操作，而 activity 在实现 listener 的 onHeadlineSelected 方法里面会进行当前布局的判断，从而选择合适的 UI（是显示在右边还是另起一个 activity）。下面是 fragment 响应点击事件，通知 activity 的 listener 进行实际操作的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class HeadlinesFragment extends ListFragment {
</span><span class='line'>    ...
</span><span class='line'>    @Override
</span><span class='line'>    public void onItemClick(AdapterView&lt;?&gt; parent, 
</span><span class='line'>                            View view, int position, long id) {
</span><span class='line'>        if (null != mHeadlineSelectedListener) {
</span><span class='line'>            mHeadlineSelectedListener.onHeadlineSelected(position);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Handle Screen Configuration Changes</h3>

<p>略：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Patterns (1)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-patterns-1/"/>
    <updated>2014-07-16T22:43:39+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-patterns-1</id>
    <content type="html"><![CDATA[<blockquote><p>Design apps that behave in a consistent, predictable fashion.</p></blockquote>

<p>原文：<br/>
<a href="http://developer.android.com/design/patterns/index.html">http://developer.android.com/design/patterns/index.html</a></p>

<p>本篇包括以下内容：<br/>
1. New in Android<br/>
2. Gestures<br/>
3. App Structure<br/>
4. Navigation with Back and Up<br/>
5. Action Bar</p>

<!--more-->


<h2>1. New in Android</h2>

<p>新版本系统中更新的设计风格和设计模式介绍。</p>

<h3>Android 4.4 KitKat</h3>

<h4>Your branding</h4>

<p>你的品牌</p>

<p><img src="http://xuanxi.github.io/images/branding_googlemusic.png" alt="branding_googlemusic" /></p>

<p>KitKat 更加强调应用的品牌，提供了展示品牌 logo 和品牌颜色的建议。（似乎也不是什么新特性，因为大部分应用早就这么做了）</p>

<h4>Touch feedback</h4>

<p>新的触摸反馈风格</p>

<p>在 kitKat 之前，Android 的触摸反馈颜色是明亮的蓝色。每次触摸都以高对比的颜色来响应，这可能与你的品牌颜色不搭配。</p>

<p>KitKat 之后，有了细微调整：触摸之后，默认情况下背景颜色轻微变亮或变暗。这样有两个好处：（1）sprinkles of encouragement are more pleasant than jolts；（2）更容易与品牌颜色搭配。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_reaction_response.png" alt="touch_feedback_reaction_response" /></p>

<h4>Full screen</h4>

<p>为全屏提供了更好的支持。</p>

<p><img src="http://xuanxi.github.io/images/fullscreen_landing.png" alt="fullscreen_landing" /></p>

<h4>Gestures</h4>

<p>更新两种手势：double touch drag 和 double touch。</p>

<h3>Android 4.1 Jelly Bean</h3>

<h4>Notifications</h4>

<p>4.1 版本的通知有较大增强：<br/>
1. &hellip;<br/>
2. 在大小和布局上更灵活<br/>
3. 提供优先排序<br/>
4. 可以折叠和展开<br/>
通知的基本布局不变，兼容老版本。</p>

<h4>Resizable Application Widgets</h4>

<h4>Accessibility</h4>

<h3>Android 4.0 Ice Cream Sandwich</h3>

<h4>Navigation bar</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_nav_bar.png" alt="whats_new_nav_bar" /></p>

<h4>Action bar</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_action_bar.png" alt="whats_new_action_bar" /></p>

<h4>Multi-pane layouts</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_multipanel.png" alt="whats_new_multipanel" /></p>

<h4>Selection</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_multiselect.png" alt="whats_new_multiselect" /></p>

<h2>2. Gestures</h2>

<p>8种手势</p>

<p>Touch 点击<br/>
Long press 长按<br/>
Swipe or drag 轻触快速滑动或慢速拖动<br/>
Long press drag 长按拖动（Home 界面的拖动应用图标）</p>

<p><img src="http://xuanxi.github.io/images/gesture_touch.png" alt="gesture_touch" />  <img src="http://xuanxi.github.io/images/gesture_longtouch.png" alt="gesture_longtouch" />  <img src="http://xuanxi.github.io/images/gesture_swipe.png" alt="gesture_swipe" />  <img src="http://xuanxi.github.io/images/gesture_drag.png" alt="gesture_drag" /></p>

<p>Double touch 双击<br/>
Double touch drag 双击拖动（地图的缩放）<br/>
Pinch open 张指放大<br/>
Pinch close 并指缩小</p>

<p><img src="http://xuanxi.github.io/images/gesture_doubletouch.png" alt="gesture_doubletouch" />  <img src="http://xuanxi.github.io/images/gesture_doubletouchdrag.png" alt="gesture_doubletouchdrag" />  <img src="http://xuanxi.github.io/images/gesture_pinchopen.png" alt="gesture_pinchopen" />  <img src="http://xuanxi.github.io/images/gesture_pinchclose.png" alt="gesture_pinchclose" /></p>

<h2>3. App Structure</h2>

<p>应用结构</p>

<p>针对不同需求的应用有不同的界面表现形式，如 Android 官方的日历或摄像使用一个窗口即可完成大部分操作，而 Gamil 使用导航抽屉区域来切换不同的功能窗口。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style (1)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-style-1/"/>
    <updated>2014-07-16T22:30:21+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-style-1</id>
    <content type="html"><![CDATA[<blockquote><p>Build visually compelling apps that look great on any device.<br/>
构建在任何设备上都引人注目的应用。</p></blockquote>

<p>原文：<br/>
<a href="http://developer.android.com/design/style/index.html">http://developer.android.com/design/style/index.html</a></p>

<p>本篇包括以下内容：<br/>
1. Devices and Displays  <br/>
2. Themes  <br/>
3. Touch Feedback<br/>
4. Metrics and Grids<br/>
5. Typography</p>

<!--more-->


<h2>1. Devices and Displays</h2>

<p>设备与显示</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_main.png" alt="devices_displays_main" /></p>

<p>Android 作为一个开放的平台，支持种类繁多的设备和屏幕尺寸，因此，解决设备适配问题一直以来是应用开发中的重点工作。Android 为此提供了以下三种基本方式来实现屏幕适配。</p>

<h4>Be flexible 自适应</h4>

<p>Android 会根据不同屏幕的宽高值缩放布局。宽高值可以定义为 WRAP_CONTENT、MATCH_PARENT、FILL_PARENT（API-8以下）、dp值、px值等。</p>

<h4>Optimize layouts 布局优化</h4>

<p>针对大屏幕设备，通过设计混合 view 来展示更多的内容（如平板的一屏使用两个 fragment 来实现左边显示列表右边显示内容），以此充分利用屏幕空间。</p>

<h4>Assets for all 资源集</h4>

<p>为了让应用界面在所有屏幕上以最佳质量显示，需要根据不同密度屏幕提供不同尺寸的图片资源。目前主流手机的屏幕密度在 XHDPI左右的范围（即通常说的视网膜）。下图是屏幕密度分布：</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<h4>Strategies 适配策略</h4>

<p>有两种方式开始屏幕适配工作：<br/>
1. 从 normal size 和 MDPI 开始；<br/>
2. 从应用要支持的最大屏幕以及对应的 DPI 开始。<br/>
通常采用方法2，或者挑选一个主流或偏高的屏幕开始，比如 1280x768 及对应的 XHDPI，这样才能够保证多数用户的体验。MDPI 和 HDPI 设备已逐渐退出市场。</p>

<p>Developer Guide<br/>
更多关于屏幕适配的内容, read <a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a> and <a href="http://developer.android.com/training/basics/fragments/index.html">Building a Dynamic UI with Fragments</a>.</p>

<h2>2. Themes</h2>

<p>主题</p>

<p>theme 是让应用界面风格保持一致的机制，theme 其实就是一个 style，而 style 是诸如 color、height、padding、front size 等属性值的集合。在 4.0 系统之后，Android 提供了两种 theme（Hole Light 和 Holo Dark），使用官方的 theme 可以让你的应用更好的符合 Android 设计规范。这两种 theme 如下图所示：</p>

<p>Gmail in Holo Light：<br/>
<img src="http://xuanxi.github.io/images/themes_holo_light.png" alt="themes_holo_light" /></p>

<p>Settings in Holo Dark：<br/>
<img src="http://xuanxi.github.io/images/themes_holo_dark.png" alt="themes_holo_dark" /></p>

<p>如果你希望设计一个与众不同的应用，一个好办法是在 Holo Light 或 Holo Dark 的基础上进行定制。</p>

<p>更多关于使用 theme 的信息请看 <a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a></p>

<h2>3. Touch Feedback</h2>

<p>触摸反馈</p>

<p>使用明暗效果来响应用户的触摸（如下文的 States），对手势做出结果导向的界面行为（如下文的 Communication）。</p>

<h3>States</h3>

<p>大部分的 Android 界面元素都内置了触摸反馈效果，比如 Button。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_states.png" alt="touch_feedback_states" /></p>

<h3>Communication</h3>

<p>当你的界面能够响应更复杂的手势时，要让用户知道接下来会发生什么。<br/>
比如，在 Recents 界面，当用户向左或向右拖动一个应用缩略图时，缩略图会渐渐变暗，以此来告诉用户拖动操作会删除该应用。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_manipulation.png" alt="touch_feedback_manipulation" /></p>

<h3>Boundaries</h3>

<p>当用户在一个可滚动的区域尝试越过起始或结尾位置时，应该给予一个边界提示。Android 提供的 ListView 和 GridView 都带有这种效果。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_communication.png" alt="touch_feedback_communication" /></p>

<h2>4. Metrics and Grids</h2>

<p>设备之间除了屏幕尺寸不同，屏幕的像素密度 (DPI) 也不一样。为了简化为不同的屏幕设计 UI 的复杂度，可以将所有的设备按照大小和像素密度如下分类。<br/>
1. 按设备大小分有两类，分别是手持设备 (小于 600 dp) 和 平板 (大于等于 600dp)；<br/>
2. 按像素密度分有 LDPI、MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI。</p>

<p><img src="http://xuanxi.github.io/images/metrics_diagram.png" alt="metrics_diagram" /></p>

<p>dp: <code>density-independent pixels</code> 密度无关像素单位，意思是相同 dp 值在不同密度屏幕上的显示效果一样。Android 提供 dp 的目的是为了自适应屏幕。</p>

<p>更多关于市面上设备分布的信息请看
<a href="http://developer.android.com/about/dashboards/index.html">Screen Sizes and Densities Device Dashboard</a></p>

<h3>48dp Rhythm</h3>

<p>可触摸元素的尺寸通常设置在 48dp 左右的范围。</p>

<p><img src="http://xuanxi.github.io/images/metrics_48.png" alt="metrics_48" /></p>

<h4>Why 48dp?</h4>

<p>就平均而言，48dp 转化为物理上的长度是 9mm，这是手指可操作的比较适合的范围（7-10mm）。</p>

<p><img src="http://xuanxi.github.io/images/metrics_closeup.png" alt="metrics_closeup" /></p>

<h4>Mind the gaps</h4>

<p>元素间的间隔通常为 8dp。</p>

<h3>Examples</h3>

<p><img src="http://xuanxi.github.io/images/metrics_forms.png" alt="metrics_forms" /></p>

<h2>5. Typography</h2>

<p>字体</p>

<p><img src="http://xuanxi.github.io/images/typography_main.png" alt="typography_main" /></p>

<p>Android 的英文字体设计基于传统的印刷排版技术，例如字体缩放、字间距规则和对齐网格。这些技术的成功运用，让用
户可以快速理解屏幕上的信息。为此，Ice Cream Sandwich 系统引⼊了全新的 Roboto 字体，它专为高分辨率屏幕而设计。</p>

<p>TextView 控件默认支持 thin、light、regular、bold，以及对应权重的斜体。也提供了叫 Condensed 的变种版本。</p>

<p><img src="http://xuanxi.github.io/images/typography_variants@2x.png" alt="typography_variants@2x" /></p>

<h4>Default type colors</h4>

<p>Android 使用 textColorPrimary 和 textColorSecondary 作为默认颜色值。在 light 主题中使用 textColorPrimaryInverse 和 textColorSecondaryInverse。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="Theme.Light"&gt;
</span><span class='line'>  &lt;item name="textColorPrimary"&gt;@android:color/primary_text_light&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorSecondary"&gt;@android:color/secondary_text_light&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorPrimaryInverse"&gt;@android:color/primary_text_dark&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorSecondaryInverse"&gt;@android:color/secondary_text_dark&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xuanxi.github.io/images/typography_defaults.png" alt="typography_defaults" /></p>

<h4>Typographic Scale</h4>

<p>字体⼤⼩上的不同有利于创造出有序和容易理解的布局。不过，在同⼀个界面中使用过多的字体⼤⼩则会造成混乱。Android 设计框架建议使用以下⼏种字体⼤⼩：</p>

<p><img src="http://xuanxi.github.io/images/typography_sizes.png" alt="typography_sizes" /></p>

<p>sp: <code>scale-independent pixels</code> 缩放无关像素单位。</p>

<p>用户可以在<code>设置</code>中调整整个系统的字体⼤⼩。为了支持这⼀特性，字体的⼤⼩应尽量使用sp。另外，要针对支持 sp 缩放的布局做测试，即改变系统字体大小，看布局是否显示正常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android UI Framework]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/15/android-ui-framework/"/>
    <updated>2014-07-15T21:21:41+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/15/android-ui-framework</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/design/handhelds/index.html">http://developer.android.com/design/handhelds/index.html</a></p>

<p>本文针对手机和平板，其它设备点击以下链接：<br/>
1. 可穿戴设备 <a href="http://developer.android.com/design/wear/index.html">Wear</a>;<br/>
2. 电视 <a href="http://developer.android.com/design/tv/index.html">TV</a>;<br/>
3. 汽车 <a href="http://developer.android.com/design/auto/index.html">Auto</a>.</p>

<p>Android 界面框架主要分为四大部分：<br/>
1. 应用集合：Home、All Apps、and Recents；<br/>
2. System Bar：Status Bar、Navigation Bar；<br/>
3. Notifications；<br/>
4. 应用框架：Action Bar、Navigation Drawer、Content Area。</p>

<!--more-->


<h2>Home, All Apps, and Recents</h2>

<h3>Home screen</h3>

<p>Home is a customizable space that houses app shortcuts, folders and widgets. Navigate between different home screen panels by swiping left and right.<br/>
The Favorites Tray at the bottom always keeps your most important shortcuts and folders in view regardless of which panel is currently showing.<br/>
Access the entire collection of apps and widgets by touching the All Apps button at the center of the Favorites Tray.</p>

<p>Home 作为 Android 系统的主界面，用来放置应用快捷方式、文件夹和 Widgets（窗口部件），通过左右滑动来切换多个 Home 页面。<br/>
Home 的底部是一个特殊的托盘，固定放置最常用的应用快捷方式或文件夹。托盘中间的按钮可以打开全部应用列表。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_home_screen.png" alt="ui_overview_home_screen" /></p>

<h3>All apps screen</h3>

<p>The All Apps screen lets you browse the entire set of apps and widgets that are installed on your device.<br/>
Users can drag an app or widget icon from the All Apps screen and place it in any empty location on any Home screen.</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_all_apps.png" alt="ui_overview_all_apps" /></p>

<h3>Recents screen</h3>

<p>Recents provides an efficient way of switching between recently used applications. It provides a clear navigation path between multiple ongoing tasks.<br/>
The Recents button at the right side of the navigation bar displays the apps that the user has interacted with most recently. They are organized in reverse chronological order with the most recently used app at the bottom.<br/>
Switch to an app by touching it. Remove an item by swiping left or right.</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_recents.png" alt="ui_overview_recents" /></p>

<h2>System Bars</h2>

<p>System Bars 包含 Status Bar 和 Navigation Bar 两部分。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_system_ui.png" alt="ui_overview_system_ui" /></p>

<h4>1. Status Bar</h4>

<p>Displays pending notifications on the left and status, such as time, battery level, or signal strength, on the right. Swipe down from the status bar to show notification details.</p>

<p>Status Bar 用来展示通知信息和设备信息。下拉展示通知详情。</p>

<h4>2. Navigation Bar</h4>

<p>New for phones in Android 4.0, the navigation bar is present only on devices that don&rsquo;t have the traditional hardware keys. It houses the device navigation controls Back, Home, and Recents, and also displays a menu for apps written for Android 2.3 or earlier.</p>

<p>Navigation Bar 出现在4.0之后的版本，用来取代设备的物理按钮，同时提供菜单按钮以兼容2.3及以下的版本。<br/>
从目前市面上的设备来看，大多依然具备物理导航键如三星，有的就虚拟导航和物理按键相结合如魅族MX2。</p>

<h2>Notifications</h2>

<p>Notifications are brief messages that users can access at any time from the status bar. They provide updates, reminders, or information that&rsquo;s important, but not critical enough to warrant interrupting the user. Open the notifications drawer by swiping down on the status bar. Touching a notification opens the associated app.</p>

<p>通知用于随时提醒用户一些简单而重要信息并且不会打断当前的用户操作。点击一个通知应该进入相关的应用。</p>

<p>Notifications can be expanded to uncover more details and relevant actions. When collapsed, notifications have a one-line title and a one-line message.The recommended layout for a notification includes two lines. If necessary, you can add a third line.</p>

<p>典型的通知布局包含一行标题和一行消息。需要的话也可以加入第三行。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_notifications.png" alt="ui_overview_notifications" /></p>

<p>Swiping a notification right or left removes it from the notification drawer.</p>

<p><img src="http://xuanxi.github.io/images/notifications_dismiss.png" alt="notifications_dismiss" /></p>

<h2>Common App UI</h2>

<p>A typical Android app uses action bars, and many apps will include a navigation drawer.</p>

<p>一个典型的 Android 应用包含 Action Bar 和 Content Area 两部分。如果应用的结构较复杂，可以使用 Navigation Drawer 来切换主要页面。</p>

<p><img src="http://xuanxi.github.io/images/app_structure_drawer.png" alt="app_structure_drawer" /></p>

<h4>Action Bar</h4>

<p>The command and control center for your app. The action bar surfaces the most important actions for the current view, and may include simple controls for switching between views.</p>

<p>Action Bar 用来承载与当前页面相关的主要操作，也可用于页面的切换。</p>

<h4>Navigation Drawer</h4>

<p>If your app&rsquo;s structure is more complex, the navigation drawer can display the main navigation options. The navigation drawer expands from the left edge of the screen, overlaying the content area but not the action bar.</p>

<p>Navigation Drawer 的弹出不覆盖 Action Bar，展示方式与目前流行在iOS应用中的侧边栏有所不同。</p>

<h4>Content Area</h4>

<p>The space where the content of your app is displayed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Design Principles]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/15/ios-design-principles/"/>
    <updated>2014-07-15T21:12:37+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/15/ios-design-principles</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Objective-C和Swift]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/14/something-about-objective-c-and-swift/"/>
    <updated>2014-07-14T10:47:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/14/something-about-objective-c-and-swift</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design Principles]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/13/android-design-principles/"/>
    <updated>2014-07-13T22:13:04+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/13/android-design-principles</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://developer.android.com/design/get-started/principles.html">http://developer.android.com/design/get-started/principles.html</a></p>

<p>推荐应用：<br/>
<a href="http://www.any.do/">Any.do</a></p>

<p>These design principles were developed by and for the Android User Experience Team to keep user&rsquo;s best interests in mind.For Android developers and designers,they continue to underline the more detailed design guidelines for different types of devices.<br/>
Consider these principles as you apply your own creativity and design thinking.Deviate with purpose.<br/>
以下设计准则由Android用户体验团队秉承用户利益至上的原则开发。当你发挥自己的创造力和思考的时候，请将它们纳入考虑之中，并有意识地加以实践。</p>

<!--more-->


<h2><em>Enchant ME</em></h2>

<p><em>迷住我</em></p>

<h3>Delight me in surprising ways</h3>

<p>以意想不到的方式取悦我</p>

<p>A beautiful surface,a carefully-places animation,or a well-timed sound effect is a joy to experience. Subtle effects contribute to a feeling of effortlessness and a sense that a powerful force is at hand.<br/>
一个漂亮的界面，一个悉心摆放的动画，或者一个适时的声音效果，都是一种快乐的体验。精细的效果能产生一种轻松的氛围，感觉手中有一股强大可控的力量。</p>

<p><img src="http://xuanxi.github.io/images/principles_delight.png" alt="principles_delight" /></p>

<h3>Real objects are more fun than buttons and menus</h3>

<p>真实对象比按钮和菜单更加有趣</p>

<p>Allow people to directly touch and manipulate objects in your app. It reduces the cognitive effort needed to perform a task while making it more emotionally satisfying.<br/>
允许人们直接触摸和操作你应用中的对象。它减少了执行一项任务所需的认识上的力量，并使之更加令人舒心。</p>

<p><img src="http://xuanxi.github.io/images/principles_real_objects.png" alt="principles_real_objects" /></p>

<h3>Let me make it mine</h3>

<p>让我把它变成我的</p>

<p>People love to add personal touches because it helps them feel at home and in control. Provide sensible, beautiful defaults, but also consider fun, optional customizations that don&rsquo;t hinder primary tasks.<br/>
人们喜欢加入个人手势，因为这让他们感觉自在与可控。提供可感的、漂亮的默认手势，但同时又考虑好玩、可选又不影响主要任务的定制项。</p>

<p><img src="http://xuanxi.github.io/images/principles_make_it_mine.png" alt="principles_make_it_mine" /></p>

<h3>Get to know me</h3>

<p>学会了解我</p>

<p>Learn peoples&#8217; preferences over time. Rather than asking them to make the same choices over and over, place previous choices within easy reach.<br/>
随着时间的推移，学习用户的偏好。不要反复地问用户同样的问题，将用户先前的选择列出来以供快捷选择。</p>

<p><img src="http://xuanxi.github.io/images/principles_get_to_know_me.png" alt="principles_get_to_know_me" /></p>

<h2><em>Simplify My Life</em></h2>

<p><em>简化我的生活</em></p>

<h3>Keep it brief</h3>

<p>用语简洁</p>

<p>Use short phrases with simple words. People are likely to skip sentences if they&rsquo;re long.<br/>
使用由简单词汇构成的短句。人们更倾向于跳过过长的句子。</p>

<p><img src="http://xuanxi.github.io/images/principles_keep_it_brief.png" alt="principles_keep_it_brief" /></p>

<h3>Pictures are faster than words</h3>

<p>图像比文字更能直达理解</p>

<p>Consider using pictures to explain ideas. They get people&rsquo;s attention and can be much more efficient than words.<br/>
考虑使用图像来解释观点。图像能捕获人们的注意力，往往比文字更有效率。</p>

<p><img src="http://xuanxi.github.io/images/principles_pictures.png" alt="principles_pictures" /></p>

<h3>Decide for me but let me have the final say</h3>

<p>为我决定，但最终由我说了算</p>

<p>Take your best guess and act rather than asking first. Too many choices and decisions make people unhappy. Just in case you get it wrong, allow for &lsquo;undo&rsquo;.<br/>
做最好的猜测，先做而非先问。太多的选择和决定会令人不愉。只当你可能会犯错时，才提供个‘撤消’，然后仍然先做后问。</p>

<p><img src="http://xuanxi.github.io/images/principles_decide_for_me.png" alt="principles_decide_for_me" /></p>

<h3>Only show what I need when I need it</h3>

<p>只在我需要的时候显示我所要的</p>

<p>People get overwhelmed when they see too much at once. Break tasks and information into small, digestible chunks. Hide options that aren&rsquo;t essential at the moment, and teach people as they go.<br/>
当一下子看到太多东西时，人们容易受打击。将任务和信息分解成小的、可消化的片段。隐藏当前非必须的选项，并指导人们如何走下去。</p>

<p><img src="http://xuanxi.github.io/images/principles_information_when_need_it.png" alt="principles_information_when_need_it" /></p>

<h3>I should always know where I am</h3>

<p>我应该总能知道我在哪里</p>

<p>Give people confidence that they know their way around. Make places in your app look distinct and use transitions to show relationships among screens. Provide feedback on tasks in progress.<br/>
给人们以清楚自己在哪的信心。把你应用中的不同场景设计得可区分，并使用变换效果来显示不同场景（窗口）之间的关系。提供任务进度反馈。</p>

<p><img src="http://xuanxi.github.io/images/principles_navigation.png" alt="principles_navigation" /></p>

<h3>Never lose my stuff</h3>

<p>决不能丢失我的东西</p>

<p>Save what people took time to create and let them access it from anywhere. Remember settings, personal touches, and creations across phones, tablets, and computers. It makes upgrading the easiest thing in the world.<br/>
保存用户花时间创建的东西，使得他们能随处访问。跨手机、平板电脑及计算机等平台，记住设置、个人手势以及作品。这将使得软件升级成为世界上最简单的事。</p>

<p><img src="http://xuanxi.github.io/images/principles_never_lose_stuff.png" alt="principles_never_lose_stuff" /></p>

<h3>If it looks the same, it should act the same</h3>

<p>如果看起来一样，所做的事就该一样</p>

<p>Help people discern functional differences by making them visually distinct rather than subtle. Avoid modes, which are places that look similar but act differently on the same input.<br/>
通过在视觉上加以区别，来帮助人们区分出功能的差异来。避免出现雷同场景，即看上去一样，但对于同一输入结果不同的场景。</p>

<p><img src="http://xuanxi.github.io/images/principles_looks_same.png" alt="principles_looks_same" /></p>

<h3>Only interrupt me if it&rsquo;s important</h3>

<p>只在十分重要时打断我</p>

<p>Like a good personal assistant, shield people from unimportant minutiae. People want to stay focused, and unless it&rsquo;s critical and time-sensitive, an interruption can be taxing and frustrating.<br/>
尤如一个好的个人助理，应该保护上司不被不重要的小事打扰。人们需要专注，除非情况十分严重并且紧急，打扰会是十分令人不悦的。</p>

<p><img src="http://xuanxi.github.io/images/principles_important_interruption.png" alt="principles_important_interruption" /></p>

<h2><em>Make Me Amazing</em></h2>

<p><em>让我惊讶</em></p>

<h3>Give me tricks that work everywhere</h3>

<p>给我点处处可行的诀窍</p>

<p>People feel great when they figure things out for themselves. Make your app easier to learn by leveraging visual patterns and muscle memory from other Android apps. For example, the swipe gesture may be a good navigational shortcut.<br/>
人们如果能够自己探索出东西来，将会兴奋不已。通过使用可视的模式和习惯操作，使你的应用更加易于学习。比如，猛击操作会是一个很好的导航快捷手势。</p>

<p><img src="http://xuanxi.github.io/images/principles_tricks.png" alt="principles_tricks" /></p>

<h3>It&rsquo;s not my fault</h3>

<p>这不是我的错</p>

<p>Be gentle in how you prompt people to make corrections. They want to feel smart when they use your app. If something goes wrong, give clear recovery instructions but spare them the technical details. If you can fix it behind the scenes, even better.<br/>
在提示用户改正错误时，应该礼貌。他们在用你应用的时候，需要被认为是聪明的。如果出错了，给出明确的恢复指令，而不是将技术细节留给他们。如果你可以在后台修复错误，那当然最好。</p>

<p><img src="http://xuanxi.github.io/images/principles_error.png" alt="principles_error" /></p>

<h3>Sprinkle encouragement</h3>

<p>挥洒鼓励</p>

<p>Break complex tasks into smaller steps that can be easily accomplished. Give feedback on actions, even if it&rsquo;s just a subtle glow.<br/>
将复杂的任务分解成小的容易被完成的步骤。对用户的操作给出反馈，即使只是一小步的成功。</p>

<p><img src="http://xuanxi.github.io/images/principles_sprinkle_encouragement.png" alt="principles_sprinkle_encouragement" /></p>

<h3>Do the heavy lifting for me</h3>

<p>为我担负重任</p>

<p>Make novices feel like experts by enabling them to do things they never thought they could. For example, shortcuts that combine multiple photo effects can make amateur photographs look amazing in only a few steps.<br/>
通过使他们做成他们认为自己不可能做到的事，让新手感觉自己像专家一样。比如，综合多个照片效果的快捷操作可使得外行简单几步做出惊人的照片效果来。</p>

<p><img src="http://xuanxi.github.io/images/principles_heavy_lifting.png" alt="principles_heavy_lifting" /></p>

<h3>Make important things fast</h3>

<p>让重要的事情能更快地完成</p>

<p>Not all actions are equal. Decide what&rsquo;s most important in your app and make it easy to find and fast to use, like the shutter button in a camera, or the pause button in a music player.<br/>
并非所有的操作都是平等的。确定你应用中最重要的操作，使它能很容易地被发现与使用，比如相机上的快门，又如音乐播放器上的暂停按钮。</p>

<p><img src="http://xuanxi.github.io/images/principles_make_important_fast.png" alt="principles_make_important_fast" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Blog!]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/13/hello-blog/"/>
    <updated>2014-07-13T15:05:19+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/13/hello-blog</id>
    <content type="html"><![CDATA[<blockquote><p>总结与分享是一种优秀的习惯。</p></blockquote>

<!--more-->


<p>在搭建博客之前，印象笔记一直是我记录工作、学习、生活的工具，但印象笔记仅适合作为个人知识库，缺少与外界的互动沟通功能，而我很希望可以将自己的一些想法和总结分享出去，也希望得到大家的批评指正，于是，我的博客诞生了：）</p>

<p>分享两篇关于写博客的文章：<br/>
<a href="http://www.cnblogs.com/jhzhu/p/3893297.html">我为什么写博客</a>（原因：我通过写博客来让自己更擅长归纳和抽象, 也通过写博客来让别人知道我能胜任某份工作。）<br/>
<a href="http://ryantang.me/blog/2013/08/02/how-to-write-blog/">博客写作之我说</a></p>
]]></content>
  </entry>
  
</feed>
