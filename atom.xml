<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Steven Chan]]></title>
  <link href="http://xuanxi.github.io/atom.xml" rel="self"/>
  <link href="http://xuanxi.github.io/"/>
  <updated>2014-09-26T15:16:51+08:00</updated>
  <id>http://xuanxi.github.io/</id>
  <author>
    <name><![CDATA[Steven Chan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[置顶]Android官方文档阅读笔记]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/07/reading-android-manual/"/>
    <updated>2014-09-07T15:10:22+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/07/reading-android-manual</id>
    <content type="html"><![CDATA[<p>理解官方指南是每一位 Android 工程师技术进阶的必经之路，可惜很多人（包括我）并没有真正重视起来。随着开发工作的深入，我决定开始认真研读，以下为所读文章的摘录、翻译和笔记，若有理解偏差的地方，欢迎大家批评指正。</p>

<!--more-->


<h2>设计指南-Design</h2>

<p>也许有人会说 Design 只是设计师的工作，对此我并不反对，但我认为作为一位合格的 Android 工程师必须首先理解 Android Design，这样才能更好地配合设计师开发出具有良好用户体验的产品。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/13/android-design-principles/">Android Design Principles</a><br/>
Android 设计准则。每一个新的 Android 应用都应该尽量基于这些准则去设计。另外，平时使用各种应用的时候也应该关注其设计的好坏，结合Android 设计准则进行分析，逐渐加深自己对用户体验的理解。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/15/android-ui-framework/">Android UI Framework</a><br/>
理解 Android 的界面框架，让应用与 Android 的用户体验保持一致。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-style-1/">Android Style (1)</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/07/29/android-style-2/">Android Style (2)</a><br/>
设计风格，主要是视觉方面。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/16/android-patterns-1/">Android Patterns (1)</a><br/>
设计模式，主要是交互方面。</p>

<p><em>注：由于最近找到了 Android Design 的较好的<a href="http://adchs.github.io/">翻译版本</a>，Design 的内容我就直接在那里学习了，这里不再重复翻译：）</em></p>

<h2>开发指南-Develop</h2>

<p><a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a><br/>
屏幕适配。</p>

<p><a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a><br/>
样式与主题</p>

<p><a href="http://blog.xuanxi.me/blog/2014/08/23/android-processes-and-threads/">Processes and Threads</a><br/>
进程与线程</p>

<p>Service 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/08/26/android-services/">Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-bound-services/">Bound Services</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/08/28/android-aidl/">AIDL</a></p>

<p>Activity 组件，分为以下三篇：<br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-fragments/">Fragments</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-loaders/">Loaders</a><br/>
<a href="http://blog.xuanxi.me/blog/2014/09/02/android-tasks-and-back-stack/">Tasks and Back Stack</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Tasks and Back Stack]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-tasks-and-back-stack/"/>
    <updated>2014-09-02T12:10:18+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-tasks-and-back-stack</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">http://developer.android.com/guide/components/tasks-and-back-stack.html</a></p>

<p>一个应用通常会包含多个 Activity，每个 Activity 完成特定的工作，并可以启动其它 Activity。比如，邮件应用使用一个 Activity 来展示邮件列表，点击一封邮件将会打开一个新的 Activity 来展示邮件内容。</p>

<p>一个 Activity 甚至可以打开其它应用的 Activity。比如，你的应用要发送邮件，你可以定义一个 Intent 来启动设备中支持这个 Intent 的邮件应用，并进入到该应用的邮件编辑页面（如果设备中有多个邮件应用，系统会以列表形式让你选择启动哪一个），当邮件发送成功后，会退回到你的应用界面，整个流程看起来，发送邮件的界面就像是你的应用界面的一部分。由此可见，尽管打开的 Activity 可能来自不同的应用，但系统会将所有 Activity 放到同一个 Task 里，以实现无缝的用户体验。本文介绍 Android 如何通过 Task 和 Back Stack 来管理 Activity。</p>

<!--more-->


<p>一个 Task 是许多 Activity 的集合，这些 Activity 连在一起表示用户对某项事务的一个完整的交互过程，这些 Activity 同时受 Back Stack 的管理，所有 Activity 以打开的顺序排列在 Back Stack 中。一个 Task 对应一个 Back Stack。（准确来说，应该是用户的整个交互对应一个 Back Stack，因为交互过程中可能会产生新的 Task，下文会讲到。）</p>

<p>大多数 Task 由 Home 界面开始，当用户在 Launcher（应用启动器）或 Home 点击应用图标，该应用的 Task 将会进入前台。在启动应用时，如果该应用的 Task 不存在（即最近没有使用过，因为如果最近使用过，通常会存在后台 Task），系统会为应用创建一个新的 Task，并以起始 Activity（通常是 main Activity）作为 Back Stack 的第一个 Activity。</p>

<p>如果从当前 Activity 启动另一个 Activity，新的 Activity 将被置于 Task 栈顶，同时获得界面焦点，而前一个 Activity 仍会保留在栈里，并处于 stopped 状态。当用户点击返回按键，新的 Activity 会出栈（被销毁），而前一个 Activity 恢复。由此可见，Back stack 其实就是一个“后进先出”的结构。</p>

<p><img src="http://xuanxi.github.io/images/diagram_backstack.png" alt="diagram_backstack" /></p>

<p>如果用户继续点击返回按键，栈中的所有 Activity 都被弹出，直到返回 Home（或者 Task 启动前正在运行的 Activity），同时，这个 Task 不再存在。</p>

<p>每个 Task 都是独立的单元，当一个新的 Task 被启动，或者用户按 Home 键返回 Home 界面，前一个 Task 将会退到后台（看不见了），Task 中的所有 Activity 都会处于 stopped 的状态，不过，Task 的 Back Stack 仍然保持不变，当它重新回到前台时，界面将会显示 Task 中最顶端的 Activity。</p>

<p><img src="http://xuanxi.github.io/images/diagram_multitasking.png" alt="diagram_multitasking" /></p>

<p>注意：<br/>
后台可以存在多个 Task，不过，如果后台 Task 过多，系统可能会销毁一些以腾出内存空间，被销毁 Task 中的 Activity 的状态都会丢失。</p>

<p>如果一个 Activity 可以被应用中的多个 Activity 启动，默认情况下，每次启动都会创建一个该 Activity 的实例，并新实例放在栈顶。如下图所示：</p>

<p><img src="http://xuanxi.github.io/images/diagram_multiple_instances.png" alt="diagram_multiple_instances" /></p>

<p>这里做一下总结：</p>

<p>（1）当 Activity A 启动 Activity B，A stopped，但系统会保存 A 的状态（比如滑动的位置和输入的信息）。当用户按返回按键从 B 返回，A 就会以上一次的状态复原。</p>

<p>（2）当用户通过 Home 键离开一个 Task（离开应用），当前的 Activity stopped，Task 也随之进入后台，但系统会保存 Task 中所有 Activity 的状态。当用户稍后通过 Launcher 图标再次打开应用时，Task 就回到前台，并显示栈顶的 Activity 及复原离开时的状态。</p>

<p>（3）如果用户点击返回按键，当前 Activity 弹出栈并被销毁，上一个 Activity 恢复显示。系统不会保存被销毁的 Activity 的状态。</p>

<p>（4）Activity 可以被多次实例化，甚至从其它的 Task 实例化。</p>

<h2>Saving Activity State</h2>

<p>就如上面所讨论的，在 Activity stopped 的时候，系统会保存 Activity 的状态，这样，当用户返回时，界面显示会跟离开时一样。但是，在 Activity destroyed 的时候，你可以，或者说应该使用  Activity 提供回调方法 onSaveInstanceState() 保存当前状态。</p>

<p>补充：开发者用 onSaveInstanceState() 保存的状态通常是业务相关的，比如视频或音乐的播放进度。</p>

<h2>Managing Tasks</h2>

<p>上面讨论的 Android 管理 Task 和 Back Stack 的方式适合大多数使用场景，你不需要关心一个 Activity 的入栈出栈。可是，如果你希望打破常规，比如你希望在一个新的 Task 中打开 Activity，而不是放到当前 Task 的栈顶；或者希望可以重用 Task 中已经存在的 Activity 实例，而不是再次创建新的实例；又或者希望在离开 Task 时可以保留 root Activity 等等。你可以通过设置 manifest 文件中的  <code>&lt;activity&gt;</code> 元素，或者为 startActivity() 方法的参数 Intent 设置 flag，来实现多种 Task 管理。</p>

<p>例如，<code>&lt;activity&gt;</code> 元素可设置的属性有：<br/>
taskAffinity<br/>
launchMode<br/>
allowTaskReparenting<br/>
clearTaskOnLaunch<br/>
alwaysRetainTaskState<br/>
finishOnTaskLaunch</p>

<p>以及可以设置的 intent flags 值有：<br/>
FLAG_ACTIVITY_NEW_TASK<br/>
FLAG_ACTIVITY_CLEAR_TOP<br/>
FLAG_ACTIVITY_SINGLE_TOP</p>

<p>下面的内容将会详细讲解如何使用这些设置。</p>

<h3>Defining launch modes</h3>

<p>launch modes（运行模式）用来描述一个新的 Activity 实例和当前 Task 的关系，有两种方式定义 launch modes：</p>

<p>使用 manifest 文件<br/>
使用 Intent flags</p>

<p>比如 Activity A starts Activity B，B 可以在 manifest 中设置 launch mode 的同时，A 也可以设置 Intent flag。在 A 和 B 都设置的情况下，A 的设置会覆盖 B 的设置。</p>

<p>注意：某些 launch modes 可以用在 manifest 上但不能用在 Intent flag 上；同样，某些 launch modes 可以用在 Intent flag 上但不能用在 manifest 上。</p>

<h4>（1）Using the manifest file</h4>

<p>设置 <code>&lt;activity&gt;</code> 元素的 launchMode 属性，有四种 launchMode：</p>

<p>&ldquo;standard&rdquo; (默认模式)<br/>
系统会在当前的 Task 中创建 Activity 的新实例。Activity 可以被多次实例化，这些实例可以存在于一个 Task 中，或者分布在不同的 Task 中（Android 的组件机制，其它的应用可以使用你的 Activity）。</p>

<p>&ldquo;singleTop&rdquo;  <br/>
当一个 Activity 实例位于栈顶的时候，再通过 Intent 跳转到本身这个 Activity，将不会创建一个新的实例压入栈中（不会调用 onCreate()，而调用 onNewIntent()）。例如：现在栈的情况为：A B C D。D 的 Launch mode 设置成了 singleTop，那么在 D 中启动 Intent 跳转到 D，那么将不会新创建一个 D 的实例压入栈中，此时栈的情况依然为：A B C D。但是如果此时  B 的模式也是 singleTop，D 跳转到 B，则会新建一个 B 的实例压入栈，因为此时 B 不位于栈顶，此时栈的情况就变成了：A B C D B。</p>

<p>&ldquo;singleTask&#8221;<br/>
系统所有 Task 中只会存在一个该 Activity 实例（不管当前 Task 还是其它 Task）。另外，singleTask 模式的 Activity 不管是位于栈顶还是栈底，再次运行这个 Activity 时，都会 destory 掉它上面的 Activity 来保证整个栈中只有一个自己。<br/>
注意：即使在新的 Task 中打开 Activity，当返回的时候，仍然会回到前一个 Task 的栈顶 Activity，这里是 Back Stack 所起的作用。</p>

<p>如果 singleTask 的 Activity 存在于一个已有的后台 Task 中，打开这个 Activity 时会将整个后台 Task 装入当前的 Back Task 中。<br/>
<img src="http://xuanxi.github.io/images/diagram_backstack_singletask_multiactivity.png" alt="diagram_backstack_singletask_multiactivity" /></p>

<p>&ldquo;singleInstance&#8221;<br/>
与 singleTask 相似，不过，该模式的 Activity 所在的栈中只有它自己一个 Activity。</p>

<h4>（2）Using Intent flags</h4>

<p>FLAG_ACTIVITY_NEW_TASK<br/>
同&#8221;singleTask&#8221;，注意如果要打开的 Activity 已存在，会调用 onNewIntent() 方法而不是 onCreate().</p>

<p>FLAG_ACTIVITY_SINGLE_TOP<br/>
同&#8221;singleTop&#8221;</p>

<p>FLAG_ACTIVITY_CLEAR_TOP<br/>
如果要打开的 Activity 已存在于当前 Task，就会销毁该 Activity 之上的 Activity。该标识通常和 FLAG_ACTIVITY_NEW_TASK 一起使用，
launchMode 属性中无此功能选项。</p>

<h3>Handling affinities</h3>

<h3>Clearing the back stack</h3>

<h3>Starting a task</h3>

<p>将一个 Activity 配置为 Task 的起始 Activity：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;activity ... &gt;
</span><span class='line'>    &lt;intent-filter ... &gt;
</span><span class='line'>        &lt;action android:name="android.intent.action.MAIN" /&gt;
</span><span class='line'>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
</span><span class='line'>    &lt;/intent-filter&gt;
</span><span class='line'>    ...
</span><span class='line'>&lt;/activity&gt;</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Loaders]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-loaders/"/>
    <updated>2014-09-02T12:09:14+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-loaders</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/loaders.html">http://developer.android.com/guide/components/loaders.html</a></p>

<p>Loader 在 Android 3.0 版本被引入，它使得在 Activity 或 Fragment 中异步加载数据变得简单。Loader 有以下特性：<br/>
1. 在所有 Activity 和 Fragment 中都可用；<br/>
2. 异步加载数据；<br/>
3. 它会监控数据的变动，并在变动时传送新的数据；
4. 当由于配置改变而被重新创建后，它们自动重连到上一个 Loader 的游标，所以不必重新查询数据。</p>

<p>关键类：<br/>
LoaderManager<br/>
Loader</p>

<!--more-->


<h2>1. Loader API Summary</h2>

<p>使用 Loader 会涉及到几个类和接口，下面做一下介绍：</p>

<p>（1）LoaderManager</p>

<p>抽象类，用在 Activity 或 Fragment 里管理 Loader 实例。通常与 CursorLoader 结合使用，也可以定义自己的 Loader。每个 Activity 或 Fragment 只能有一个 LoaderManager 实例，但一个 LoaderManager 可以持有多个 Loader。</p>

<p>（2）LoaderManager.LoaderCallbacks</p>

<p>一个用于客户端（即用户界面）与 LoaderManager 交互的回调接口。例如，你使用回调方法 onCreateLoader() 来创建一个新的 Loader。</p>

<p>（3）Loader</p>

<p>抽象类，用来执行异步数据加载操作。它是具体 Loader 的基类。一般情况下使用 CursorLoader，但是你也可以实现你自己的子类。一旦 Loader 被激活，它们将监视它们的数据源并且在数据改变时发送新的结果。</p>

<p>（4）AsyncTaskLoader</p>

<p>抽象类，类似 AsyncTask。</p>

<p>（5）CursorLoader
AsyncTaskLoader 的子类，它查询 ContentResolver 然后返回一个 Cursor。它实现了 Loader 协议，可以在后台查询 Cursor 而不阻塞 UI。</p>

<p>上面所列的类和接口是实现 Loader 的基础组件，你的每个 Loader 实现并不一定需要所有的组件，但至少要有一个 LoaderManager 和一个具体的 Loader（如 CursorLoader）。</p>

<h2>2. Using Loaders in an Application</h2>

<p>This section describes how to use loaders in an Android application. An application that uses loaders typically includes the following:</p>

<p>使用 Loader 通常要包含以下内容：</p>

<p>（1）一个 Activity 或 Fragment；<br/>
（2）一个 LoaderManager 实例；<br/>
（3）一个 CursorLoader 实例，对应 ContentProvider 数据源；<br/>
（4）实现 LoaderManager.LoaderCallbacks；<br/>
（5）实现显示数据的方式，如 SimpleCursorAdapter；<br/>
（6）数据源，如 ContentProvider。</p>

<h3>Starting a Loader</h3>

<p>在 Activity 的 onCreate() 方法或 Fragment 的 onActivityCreated() 方法中初始化一个 Loader：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Prepare the loader.  Either re-connect with an existing one,
</span><span class='line'>// or start a new one.
</span><span class='line'>getLoaderManager().initLoader(0, null, this);</span></code></pre></td></tr></table></div></figure>


<p>initLoader() 方法有以下参数：</p>

<p>（1）代表这个 Loader 的唯一 ID。<br/>
（2）Optional arguments to supply to the loader at construction (null in this example).<br/>
（3）LoaderManager.LoaderCallbacks 的实现。</p>

<p>对 initLoader() 的调用可以确保一个 Loadder 实例被初始化并处于活动状态。它可能有两种结果：</p>

<p>（1）如果该 ID 的 Loader 实例已经存在，则重用最后一个创建的 Loader。（不是对应 ID 的 Loader 哦）<br/>
（2）如果不存在，就响应 LoaderManager.LoaderCallbacks 接口中的 onCreateLoader() 方法。</p>

<p>initLoader() 方法会返回被创建好的 Loader 的实例，但我们不需要获取它，因为 LoaderManager 会管理好它的生命周期，你基本上不用直接和 Loader 打交道，你的主要工作是处理好 LoaderManager.LoaderCallbacks 的接口。</p>

<h3>Restarting a Loader</h3>

<h3>Using the LoaderManager Callbacks</h3>

<h2>3. Example</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class CursorLoaderListFragment extends ListFragment
</span><span class='line'>        implements OnQueryTextListener, LoaderManager.LoaderCallbacks&lt;Cursor&gt; {
</span><span class='line'>
</span><span class='line'>    // This is the Adapter being used to display the list's data.
</span><span class='line'>    SimpleCursorAdapter mAdapter;
</span><span class='line'>
</span><span class='line'>    // If non-null, this is the current filter the user has provided.
</span><span class='line'>    String mCurFilter;
</span><span class='line'>
</span><span class='line'>    @Override public void onActivityCreated(Bundle savedInstanceState) {
</span><span class='line'>        super.onActivityCreated(savedInstanceState);
</span><span class='line'>
</span><span class='line'>        // Give some text to display if there is no data.  In a real
</span><span class='line'>        // application this would come from a resource.
</span><span class='line'>        setEmptyText("No phone numbers");
</span><span class='line'>
</span><span class='line'>        // We have a menu item to show in action bar.
</span><span class='line'>        setHasOptionsMenu(true);
</span><span class='line'>
</span><span class='line'>        // Create an empty adapter we will use to display the loaded data.
</span><span class='line'>        mAdapter = new SimpleCursorAdapter(getActivity(),
</span><span class='line'>                android.R.layout.simple_list_item_2, null,
</span><span class='line'>                new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS },
</span><span class='line'>                new int[] { android.R.id.text1, android.R.id.text2 }, 0);
</span><span class='line'>        setListAdapter(mAdapter);
</span><span class='line'>
</span><span class='line'>        // Prepare the loader.  Either re-connect with an existing one,
</span><span class='line'>        // or start a new one.
</span><span class='line'>        getLoaderManager().initLoader(0, null, this);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
</span><span class='line'>        // Place an action bar item for searching.
</span><span class='line'>        MenuItem item = menu.add("Search");
</span><span class='line'>        item.setIcon(android.R.drawable.ic_menu_search);
</span><span class='line'>        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
</span><span class='line'>        SearchView sv = new SearchView(getActivity());
</span><span class='line'>        sv.setOnQueryTextListener(this);
</span><span class='line'>        item.setActionView(sv);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public boolean onQueryTextChange(String newText) {
</span><span class='line'>        // Called when the action bar search text has changed.  Update
</span><span class='line'>        // the search filter, and restart the loader to do a new query
</span><span class='line'>        // with this filter.
</span><span class='line'>        mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
</span><span class='line'>        getLoaderManager().restartLoader(0, null, this);
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override public boolean onQueryTextSubmit(String query) {
</span><span class='line'>        // Don't care about this.
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override public void onListItemClick(ListView l, View v, int position, long id) {
</span><span class='line'>        // Insert desired behavior here.
</span><span class='line'>        Log.i("FragmentComplexList", "Item clicked: " + id);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // These are the Contacts rows that we will retrieve.
</span><span class='line'>    static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
</span><span class='line'>        Contacts._ID,
</span><span class='line'>        Contacts.DISPLAY_NAME,
</span><span class='line'>        Contacts.CONTACT_STATUS,
</span><span class='line'>        Contacts.CONTACT_PRESENCE,
</span><span class='line'>        Contacts.PHOTO_ID,
</span><span class='line'>        Contacts.LOOKUP_KEY,
</span><span class='line'>    };
</span><span class='line'>    public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle args) {
</span><span class='line'>        // This is called when a new Loader needs to be created.  This
</span><span class='line'>        // sample only has one Loader, so we don't care about the ID.
</span><span class='line'>        // First, pick the base URI to use depending on whether we are
</span><span class='line'>        // currently filtering.
</span><span class='line'>        Uri baseUri;
</span><span class='line'>        if (mCurFilter != null) {
</span><span class='line'>            baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
</span><span class='line'>                    Uri.encode(mCurFilter));
</span><span class='line'>        } else {
</span><span class='line'>            baseUri = Contacts.CONTENT_URI;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // Now create and return a CursorLoader that will take care of
</span><span class='line'>        // creating a Cursor for the data being displayed.
</span><span class='line'>        String select = "((" + Contacts.DISPLAY_NAME + " NOTNULL) AND ("
</span><span class='line'>                + Contacts.HAS_PHONE_NUMBER + "=1) AND ("
</span><span class='line'>                + Contacts.DISPLAY_NAME + " != '' ))";
</span><span class='line'>        return new CursorLoader(getActivity(), baseUri,
</span><span class='line'>                CONTACTS_SUMMARY_PROJECTION, select, null,
</span><span class='line'>                Contacts.DISPLAY_NAME + " COLLATE LOCALIZED ASC");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) {
</span><span class='line'>        // Swap the new cursor in.  (The framework will take care of closing the
</span><span class='line'>        // old cursor once we return.)
</span><span class='line'>        mAdapter.swapCursor(data);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void onLoaderReset(Loader&lt;Cursor&gt; loader) {
</span><span class='line'>        // This is called when the last Cursor provided to onLoadFinished()
</span><span class='line'>        // above is about to be closed.  We need to make sure we are no
</span><span class='line'>        // longer using it.
</span><span class='line'>        mAdapter.swapCursor(null);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Fragments]]></title>
    <link href="http://xuanxi.github.io/blog/2014/09/02/android-fragments/"/>
    <updated>2014-09-02T12:07:46+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/09/02/android-fragments</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/fragments.html">http://developer.android.com/guide/components/fragments.html</a></p>

<p>要点：<br/>
1. Design Philosophy（设计哲学）<br/>
2. Creating a Fragment（创建 Fragment） <br/>
3. Managing Fragments（管理 Fragment）<br/>
4. Performing Fragment Transactions（执行 Fragment 事务）<br/>
5. Communicating with the Activity（与 Activity 通信） <br/>
6. Handling the Fragment Lifecycle（维护 Fragment 生命周期）</p>

<p>关键类:<br/>
Fragment<br/>
FragmentManager<br/>
FragmentTransaction</p>

<!--more-->


<p>Fragment 是 Activity 界面的一部分，你可以在一个 Activity 中组合几个 Fragment 来构建 multi-pane 界面，并可以在其它 Activity 重用一个 Fragment。Fragment 有自己的生命周期，可以接收输入事件，可以在 Activity 运行期间被加入或移除（类似“子 Activity”）。</p>

<p>Fragment 必须内嵌到 Activity 里，它的生命周期受 Activity 生命周期的影响。例如 Activity paused，其中所有 Fragment 也 paused；Activity destroyed，其中所有 Fragment 也 destroyed。不过，当 Activity 在运行期间，你可以独立地操作 Fragment，比如加入或移除，而受 Activity 生命周期的影响。</p>

<p>你可以通过布局或代码加入一个 Fragment，也可以使用不带 UI 的 Fragment。</p>

<h2>1. Design Philosophy</h2>

<p>Android 在 3.0 版本引入 Fragment，主要为了支持在大屏幕（如平板）中创建动态和自适应的界面。通过将一个 Activity 布局划分为几个碎片（fragments），你就可以在应用运行期间动态改变界面，以及在一个 Activity 维护的返回栈（back stack）中保存这些变动。</p>

<p>下图展示了 Fragment 分别在平板和手机上的使用：
<img src="http://xuanxi.github.io/images/fragments.png" alt="fragments" /></p>

<p>你应该将 Fragment 设计成一个标准化的可重用的组件，避免不同 Fragment 之间相互调用。当应用要同时支持手机和平板时，你可通过布局配置来重用 Fragment。</p>

<h2>2. Creating a Fragment</h2>

<p>要创建 Fragment，你必须创建一个 Fragment 类的子类（或者继承现成的 Fragment 子类）。Fragment 的代码看起来与 Activity 非常像，比如都包含以下生命周期方法：onCreate(), onStart(), onPause(), and onStop()。事实上，如果你将一个使用 Activity 的应用修改为使用 Fragment，你可能只需要将 Activity 生命周期方法中的代码复制到对应的 Fragment 生命周期方法中就行。</p>

<p><img src="http://xuanxi.github.io/images/fragment_lifecycle.png" alt="fragment_lifecycle" /></p>

<p>一般地情况下，你至少需要实现以下生命周期方法：</p>

<p>（1）onCreate()<br/>
系统在创建 Fragment 的时候调用该方法。在这里初始化一些无论 paused 还是 stopped 状态都仍然要保留的数据。</p>

<p>（2）onCreateView()<br/>
系统在第一次绘制 Fragment 界面的时候调用该方法。为了绘制 Fragment 的 UI，此方法必须返回这个 Fragment 布局的根 View。如果不提供界面的话，也可以返回 null。</p>

<p>（3）onPause()<br/>
用户将要离开这个 Fragment 时，系统会首先调用该方法（然而它不总是意味着 Fragment 将被销毁）。通常你应该在这里保存用户的修改，因为用户有可能不会再回来。</p>

<p>大多数应用应当为每一个 Fragment 实现至少上述3个方法，你也可以使用其它的回调方法处理对应阶段的事情。全部的生命周期回调方法将会在后面的 Handlingthe Fragment Lifecycle 章节中讨论。</p>

<p>另外，Android 也提供了几个特定用途的 Fragment 供你继承使用：</p>

<p>DialogFragment<br/>
显示一个浮动对话框。相比普通的 AlertDialog，官方更推荐使用 DialogFragment，因为你可以将 DialogFragment 加入返回栈中，以便返回时再次显示它。</p>

<p>ListFragment<br/>
显示一个列表，与 ListActivity 类似，提供了相关的处理 ListView 的方法，如 onListItemClick()。</p>

<p>PreferenceFragment<br/>
显示列表形式的偏好设置，与 PreferenceActivity 类似，在创建“设置”界面的时候使用。</p>

<h3>Adding a user interface</h3>

<p>Fragment 通常被认为是 Activity 界面的一部分，它将自身布局加入到 Activity 中。要为 Fragment 提供布局，你必须实现 onCreateView() 回调方法，并返回布局的根。</p>

<p>注意：ListFragment 已经有默认的 onCreateView() 实现，并提供了 ListView，如下源码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public View onCreateView(LayoutInflater inflater, ViewGroup container,
</span><span class='line'>    Bundle savedInstanceState) {
</span><span class='line'>      return inflater.inflate(com.android.internal.R.layout.list_content,
</span><span class='line'>                container, false);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>onCreateView() 方法提供了 LayoutInflater 对象来加载布局。一个 Fragment 示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class ExampleFragment extends Fragment {
</span><span class='line'>    @Override
</span><span class='line'>    public View onCreateView(LayoutInflater inflater, ViewGroup container,
</span><span class='line'>                             Bundle savedInstanceState) {
</span><span class='line'>        // Inflate the layout for this fragment
</span><span class='line'>        return inflater.inflate(R.layout.example_fragment, container, false);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>另外，onCreateView() 中的 container 参数是 Activity 布局中用来插入 Fragment 布局的 ViewGroup。savedInstanceState 参数是上一次保存的状态（如果作了保存的话）。</p>

<p>inflate (int resource, ViewGroup root, boolean attachToRoot) 方法的参数说明如下：</p>

<p>resource：布局的 id。</p>

<p>root：布局的参考父 View，如果 attachToRoot 为 true，就将它作为布局的新 root 一并返回；如果 attachToRoot 为 false，就将它的 LayoutParams 参数应用到布局本来的 root。这里必须将 onCreateView() 提供的 container 传进来，以获得 container 的 LayoutParams 参数，并应用到 Fragment 布局的 root 上，以便 Fragment 布局可以正确地插入到 Activity 布局中。</p>

<p>attachToRoot：介绍如 root 参数所述。在 onCreateView() 中的情况是 false，因为系统已经实现将布局插入到 container 中，没必要把 container 重复加入到 Fragment 布局。</p>

<p>现在，你已经知道怎样定义一个 Fragment，下一节将介绍怎样将这个 Fragment 加入 Activity 中。</p>

<h3>Adding a fragment to an activity</h3>

<p>有两种方式将 Fragment 加入到 Activity 中：</p>

<p>（1）通过 <code>&lt;fragment&gt;</code> 标签</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:orientation="horizontal"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"&gt;
</span><span class='line'>    &lt;fragment android:name="com.example.news.ArticleListFragment"
</span><span class='line'>            android:id="@+id/list"
</span><span class='line'>            android:layout_weight="1"
</span><span class='line'>            android:layout_width="0dp"
</span><span class='line'>            android:layout_height="match_parent" /&gt;
</span><span class='line'>    &lt;fragment android:name="com.example.news.ArticleReaderFragment"
</span><span class='line'>            android:id="@+id/viewer"
</span><span class='line'>            android:layout_weight="2"
</span><span class='line'>            android:layout_width="0dp"
</span><span class='line'>            android:layout_height="match_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>android:name</code> 属性指定了 Fragment 类。系统在创建这个 Activity 时，会依次调用 Fragment 的 onCreateView() 方法以获得 Fragment 的实际布局，然后将布局直接替换对应的 <code>&lt;fragment&gt;</code> 元素。</p>

<p>注意：需要为每个 Fragment 指定一个唯一标识，以便系统使用这个标识来做还原操作（在 Activity restarted 的时候），同时你也可能用这个标识来执行事务，比如删除 Fragment。有两种方式提供唯一标识：<br/>
android:id<br/>
android:tag</p>

<p>（2）通过代码</p>

<p>在 Activity 运行过程中，你随时可以加入一个 Fragment，仅需要指定一个父 ViewGroup。</p>

<p>要执行 Fragment 事务（比如加入、移除、替换），你必须使用 FragmentTransaction 中的接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FragmentManager fragmentManager = getFragmentManager()
</span><span class='line'>FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span></code></pre></td></tr></table></div></figure>


<p>然后你可以用 add() 方法加入一个 Fragment：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ExampleFragment fragment = new ExampleFragment();
</span><span class='line'>fragmentTransaction.add(R.id.fragment_container, fragment);
</span><span class='line'>fragmentTransaction.commit();</span></code></pre></td></tr></table></div></figure>


<p>add() 的第一个参数是父 ViewGroup，第二个参数是要加入的 Fragment。</p>

<p>一旦对 FragmentTransaction 作了改动，你必须调用 commit() 来提交改动。</p>

<h3>Adding a fragment without a UI</h3>

<p>上面的例子介绍了如何加入带界面的 Fragment，不过，你也可以使用不带界面的 Fragment 来处理后台任务。</p>

<p>要加入不带界面的 Fragment，使用 add(Fragment, String) 方法，第二个参数使用 “tag” 而不是 “id”。因为不带界面，所以不用重写 onCreateView()。</p>

<h2>3. Managing Fragments</h2>

<p>管理 Fragment 使用 FragmentManager，在 Activity 中通过 getFragmentManager() 获得 FragmentManager 对象。</p>

<p>在 FragmentManager 中可以做的事情是：</p>

<p>（1）获得 Fragment 对象。findFragmentById() 方法获得带界面的 Fragment；findFragmentByTag() 方法获得不带界面的 Fragment。</p>

<p>（2）从返回栈里弹出 Fragment。使用 popBackStack() 方法，模拟返回命令。</p>

<p>（3）为返回栈变动注册监听器。使用 addOnBackStackChangedListener() 方法。</p>

<p>更多信息请看 <a href="http://developer.android.com/reference/android/app/FragmentManager.html">FragmentManager</a>。</p>

<h2>4. Performing Fragment Transactions</h2>

<p>Fragment 的一个重要功能是可以灵活地响应用户交互，比如加入、移除或替换界面。一组动作称之为一个事务，你可以使用 FragmentTransaction 的接口来运行一个事务。你也可以将事务保存到由 Activity 管理的返回栈中，以便让用户按顺序返回。</p>

<p>你可以通过 FragmentManager 对象来获得 FragmentTransaction 实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>FragmentManager fragmentManager = getFragmentManager();
</span><span class='line'>FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();</span></code></pre></td></tr></table></div></figure>


<p>之后通过 add()、remove() 或 replace() 方法来响应交互，最后调用 commit() 来提交。</p>

<p>不过，在你调用 commit() 之前，你可能需要调用 addToBackStack() 来使用返回栈，这样，在点击虚拟返回按键时，会返回到上一次的 Fragment 状态。</p>

<p>例如，下面的代码展示了如何用一个 Fragment 替换现有的 Fragment，并将状态保存到返回栈中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Create new fragment and transaction
</span><span class='line'>Fragment newFragment = new ExampleFragment();
</span><span class='line'>FragmentTransaction transaction = getFragmentManager().beginTransaction();
</span><span class='line'>
</span><span class='line'>// Replace whatever is in the fragment_container view with this fragment,
</span><span class='line'>// and add the transaction to the back stack
</span><span class='line'>transaction.replace(R.id.fragment_container, newFragment);
</span><span class='line'>transaction.addToBackStack(null);
</span><span class='line'>
</span><span class='line'>// Commit the transaction
</span><span class='line'>transaction.commit();</span></code></pre></td></tr></table></div></figure>


<h2>5. Communicating with the Activity</h2>

<p>虽然 Fragment 的实现是独立于 Activity 的，但在任何时候，一个实例化的 Fragment 都会与当前绑定的 Activity 相关，这样就涉及到与 Activity 通信的问题。</p>

<p>比如 Fragment 里可以通过 getActivity() 方法来访问 Activity：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>View listView = getActivity().findViewById(R.id.list);</span></code></pre></td></tr></table></div></figure>


<p>同样，Activity 也可以在 Fragment 里调用 findFragmentById() 或 findFragmentByTag() 来获得 Fragment 实例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);</span></code></pre></td></tr></table></div></figure>


<h3>Creating event callbacks to the activity</h3>

<p>某些情况下，你可能需要让 Activity 响应 Fragment 中的事件，一个好方法是，在 Fragment 中声明一个回调接口，在 Activity 中实现这个接口。</p>

<p>比如，一个新闻应用的 Activity 中有两个 Fragment，一个展示列表（A），一个展示详情（B），当 A 的列表项被点击，A 必须告诉 Activity 这个点击事件，并由 Activity 去通知 B 加载详情数据。这个例子中，A 定义了一个 OnArticleSelectedListener 接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class FragmentA extends ListFragment {
</span><span class='line'>    ...
</span><span class='line'>    // Container Activity must implement this interface
</span><span class='line'>    public interface OnArticleSelectedListener {
</span><span class='line'>        public void onArticleSelected(Uri articleUri);
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了确认 Activity 是否实现了接口，可以在 onAttach() 中做一个转换处理：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class FragmentA extends ListFragment {
</span><span class='line'>    OnArticleSelectedListener mListener;
</span><span class='line'>    ...
</span><span class='line'>    @Override
</span><span class='line'>    public void onAttach(Activity activity) {
</span><span class='line'>        super.onAttach(activity);
</span><span class='line'>        try {
</span><span class='line'>            mListener = (OnArticleSelectedListener) activity;
</span><span class='line'>        } catch (ClassCastException e) {
</span><span class='line'>            throw new ClassCastException(activity.toString() + " must implement OnArticleSelectedListener");
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果没实现接口，就会抛出 ClassCastException 异常。</p>

<p>接着，就可以在触发事件的地方调用接口了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class FragmentA extends ListFragment {
</span><span class='line'>    OnArticleSelectedListener mListener;
</span><span class='line'>    ...
</span><span class='line'>    @Override
</span><span class='line'>    public void onListItemClick(ListView l, View v, int position, long id) {
</span><span class='line'>        // Append the clicked item's row ID with the content provider Uri
</span><span class='line'>        Uri noteUri = ContentUris.withAppendedId(ArticleColumns.CONTENT_URI, id);
</span><span class='line'>        // Send the event and Uri to the host activity
</span><span class='line'>        mListener.onArticleSelected(noteUri);
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Adding items to the Action Bar</h3>

<p>（略）</p>

<h2>6. Handling the Fragment Lifecycle</h2>

<p>管理 Fragment 的生命周期，在大多地方与管理 Activity 的生命周期相似。一个 Fragment 的生命状态有以下三种：</p>

<p>（1）Resumed<br/>
Fragment 可见。</p>

<p>（2）Paused<br/>
另一个 Activity 处于前台并拥有焦点，但 Fragment 所在的 Activity 仍然可见（比如前台 Activity 有部分透明）。</p>

<p>（3）Stopped<br/>
Fragment 不可见，要么是宿主 Activity 处于 stopped 状态，要么是这个 Fragment 被移除（如用户滑动到下一个 Fragment）并处于后台堆栈中。stopped 状态的 Fragment 仍然生存，所有的状态和成员信息都被系统保留着。如果宿主 Activity 被销毁，Fragment 也同时被销毁。</p>

<p>下图为 Activity 生命周期与 Fragment 生命周期的对应关系：
<img src="http://xuanxi.github.io/images/activity_fragment_lifecycle.png" alt="activity_fragment_lifecycle" /></p>

<p>跟 Activity 一样，你可以使用 Boundle 来保存 Fragment 的状态，万一 Activity 所在进程被杀掉了，你就可以在重建 Activity 的时候还原 Fragment 的状态。你可以在 onSaveInstanceState() 里保存状态，并在 onCreate() 、onCreateView() 或 onActivityCreated() 中恢复状态。</p>

<h3>Coordinating with the activity lifecycle</h3>

<p>onAttach()<br/>
当 Fragment 开始与 Activity 建立关联时被调用，Activity 实例被传进来。</p>

<p>onCreateView()<br/>
当 Fragment UI 与 Activity 布局建立关联时被调用。</p>

<p>onActivityCreated()<br/>
在 Activity 的 onCreate() 方法返回之后被调用。</p>

<p>onDestroyView()<br/>
Called when the view hierarchy associated with the fragment is being removed.</p>

<p>onDetach()<br/>
Called when the fragment is being disassociated from the activity.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android AIDL]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/28/android-aidl/"/>
    <updated>2014-08-28T10:13:19+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/28/android-aidl</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/aidl.html">http://developer.android.com/guide/components/aidl.html</a></p>

<p>AIDL 与其它 IDLs（接口定义语言）类似，它允许你定义客户端和服务端都能够识别的编程接口，然后通过 IPC 就可以实现两端的通信。不过，在使用 AIDL 之前，你应该思考是否一定要采用 AIDL：如果你不需要跨进程通信，那么直接实现 Binder 即可；如果你需要跨进程通信，但不要求处理多线程任务，那么使用 Messenger 即可。</p>

<p>在你开始设计 AIDL 接口之前，要意识到接口调用就是函数调用，这涉及到执行线程的问题，你不能假设调用在什么线程上执行，而事实上，这取决于调用源自本地进程还是远程进程：<br/>
（1）在本地进程调用的话，接口在调用者所在线程上执行。比如，如果在 UI 线程调用，就在 UI 线程执行。不过，这样的话就没必要用到 AIDL 了，而应该直接用 Binder。（这样说来，AIDL 其实也可以用在非 IPC 场景？）<br/>
（2）从远程进程调用的话，系统会在本地进程中建立一个线程池，并在线程池中取出线程来执行。要注意处理线程安全。<br/>
（3）The oneway keyword modifies the behavior of remote calls. When used, a remote call does not block; it simply sends the transaction data and immediately returns. The implementation of the interface eventually receives this as a regular call from the Binder thread pool as a normal remote call. If oneway is used with a local call, there is no impact and the call is still synchronous.</p>

<!--more-->


<h2>1. Defining an AIDL Interface</h2>

<h3>1.1 Create the .aidl file</h3>

<p>AIDL 使用 Java 语法来声明接口，接口可以是一个或多个带参数和返回值的方法，这些参数和返回值可以是任何类型，甚至是其他 AIDL 生成的接口。</p>

<p>AIDL 默认支持以下数据类型：<br/>
（1）所有 Java 基本类型（such as int, long, char, boolean, and so on）<br/>
（2）String<br/>
（3）CharSequence<br/>
（4）List<br/>
All elements in the List must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. A List may optionally be used as a &ldquo;generic&rdquo; class (for example, List<String>). The actual concrete class that the other side receives is always an ArrayList, although the method is generated to use the List interface.<br/>
（5）Map<br/>
All elements in the Map must be one of the supported data types in this list or one of the other AIDL-generated interfaces or parcelables you&rsquo;ve declared. Generic maps, (such as those of the form Map&lt;String,Integer> are not supported. The actual concrete class that the other side receives is always a HashMap, although the method is generated to use the Map interface.</p>

<p>如果不是上面所列举的类型，你就需要使用 import 声明。</p>

<p>下面是一个 .aidl 例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// IRemoteService.aidl
</span><span class='line'>package com.example.android;
</span><span class='line'>
</span><span class='line'>// Declare any non-default types here with import statements
</span><span class='line'>
</span><span class='line'>/** Example service interface */
</span><span class='line'>interface IRemoteService {
</span><span class='line'>    /** Request the process ID of this service, to do evil things with it. */
</span><span class='line'>    int getPid();
</span><span class='line'>
</span><span class='line'>    /** Demonstrates some basic types that you can use as parameters
</span><span class='line'>     * and return values in AIDL.
</span><span class='line'>     */
</span><span class='line'>    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
</span><span class='line'>            double aDouble, String aString);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>只要将定义好的 .aidl 文件放入 src/ directory 路径下，SDK 就会在构建工程时自动生成 IBinder 接口文件在 gen/ directory，生成的文件名与 .aidl 文件名一样，并以 .java 为扩展名。</p>

<p>如果你使用 Eclipse，并打开了自动构建选项，IBinder 接口文件会立即生成。</p>

<h3>1.2 Implement the interface</h3>

<p>在上一步生成的接口文件中包含了一个 Stub 子类，它是 .aidl 接口的抽象实现。Stub 同时定义了一些辅助方法，尤其是 asInterface()，这个方法在客户端会使用到，用于返回 IBinder 对象。</p>

<p>接下来是实现 Stub 类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
</span><span class='line'>    public int getPid(){
</span><span class='line'>        return Process.myPid();
</span><span class='line'>    }
</span><span class='line'>    public void basicTypes(int anInt, long aLong, boolean aBoolean,
</span><span class='line'>        float aFloat, double aDouble, String aString) {
</span><span class='line'>        // Does nothing
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在实现 AIDL 接口时还有几点要注意的：<br/>
（1）接口不保证会在（Service 所在的本地进程的）主线程上执行，因此，你一开始就应该考虑多线程的问题，以确保线程安全。<br/>
（2）默认情况下，RPC（远程过程调用，是 IPC 的一种形式）是同步的，如果你确定调用是耗时的，就不应该在主线程上调用，而应该在工作线程上调用。<br/>
（3）远程接口上的异常不会传递到调用方法上。</p>

<h3>1.3 Expose the interface to clients</h3>

<p>一旦实现了 Stub，你就可以将它暴露给客户端了。在 Service 的 onBind() 方法返回 Stub 对象。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class RemoteService extends Service {
</span><span class='line'>    @Override
</span><span class='line'>    public void onCreate() {
</span><span class='line'>        super.onCreate();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public IBinder onBind(Intent intent) {
</span><span class='line'>        // Return the interface
</span><span class='line'>        return mBinder;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
</span><span class='line'>        public int getPid(){
</span><span class='line'>            return Process.myPid();
</span><span class='line'>        }
</span><span class='line'>        public void basicTypes(int anInt, long aLong, boolean aBoolean,
</span><span class='line'>            float aFloat, double aDouble, String aString) {
</span><span class='line'>            // Does nothing
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>同时，需要将 .aidl 文件放在客户端工程的 src/ directory 中，以便生成 Java 形式的接口文件。</p>

<p>现在，当客户端调用 bindService() 去连接 Service 时，客户端的 onServiceConnected() 回调方法里会得到 Service 在 onBind() 中返回的 mBinder 对象。</p>

<p>当客户端从 onServiceConnected() 中得到 IBinder 对象后，还需要用 YourServiceInterface.Stub.asInterface(service) 方法将 IBinder 转换为 YourServiceInterface 类型（也就是上面生成的 Java 类），这样才能调用定义的接口。如以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>IRemoteService mIRemoteService;
</span><span class='line'>private ServiceConnection mConnection = new ServiceConnection() {
</span><span class='line'>    // Called when the connection with the service is established
</span><span class='line'>    public void onServiceConnected(ComponentName className, IBinder service) {
</span><span class='line'>        // Following the example above for an AIDL interface,
</span><span class='line'>        // this gets an instance of the IRemoteInterface, which we can use to call on the service
</span><span class='line'>        mIRemoteService = IRemoteService.Stub.asInterface(service);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    // Called when the connection with the service disconnects unexpectedly
</span><span class='line'>    public void onServiceDisconnected(ComponentName className) {
</span><span class='line'>        Log.e(TAG, "Service has unexpectedly disconnected");
</span><span class='line'>        mIRemoteService = null;
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h2>2. Passing Objects over IPC</h2>

<p>通过 IPC，你可以将一个对象传输到另一个进程。Android 提供了 Parcelable 来实现这个传输过程：Parcelable 将对象拆解为有序的基本类型，装载到 Parcel 上，然后在其它进程重新组装为对象。</p>

<p>创建支持 Parcelable 协议的类，要做以下几点：</p>

<p>（1）实现 Parcelable 接口。<br/>
（2）实现 writeToParcel 方法，将数据写入 Parcel。<br/>
（3）增加一个静态字段——CREATOR，实现 Parcelable.Creator 接口。<br/>
（4）最后，创建 .aidl 文件，在其中声明这个 Parcelable 类。</p>

<p>下面的 Rect.aidl 文件中声明了一个 Parcelable 类：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>package android.graphics;
</span><span class='line'>
</span><span class='line'>// Declare Rect so AIDL can find it and knows that it implements
</span><span class='line'>// the parcelable protocol.
</span><span class='line'>parcelable Rect;</span></code></pre></td></tr></table></div></figure>


<p>下面是一个实现 Parcelable 协议的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import android.os.Parcel;
</span><span class='line'>import android.os.Parcelable;
</span><span class='line'>
</span><span class='line'>public final class Rect implements Parcelable {
</span><span class='line'>    public int left;
</span><span class='line'>    public int top;
</span><span class='line'>    public int right;
</span><span class='line'>    public int bottom;
</span><span class='line'>
</span><span class='line'>    public static final Parcelable.Creator&lt;Rect&gt; CREATOR = new
</span><span class='line'>Parcelable.Creator&lt;Rect&gt;() {
</span><span class='line'>        public Rect createFromParcel(Parcel in) {
</span><span class='line'>            return new Rect(in);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public Rect[] newArray(int size) {
</span><span class='line'>            return new Rect[size];
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    public Rect() {
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    private Rect(Parcel in) {
</span><span class='line'>        readFromParcel(in);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void writeToParcel(Parcel out) {
</span><span class='line'>        out.writeInt(left);
</span><span class='line'>        out.writeInt(top);
</span><span class='line'>        out.writeInt(right);
</span><span class='line'>        out.writeInt(bottom);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    public void readFromParcel(Parcel in) {
</span><span class='line'>        left = in.readInt();
</span><span class='line'>        top = in.readInt();
</span><span class='line'>        right = in.readInt();
</span><span class='line'>        bottom = in.readInt();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个 Recent 类要处理的数据比较简单（都是整型），你可以查看 <a href="http://developer.android.com/reference/android/os/Parcel.html">Parcel</a> 支持的其它数据类型。</p>

<h2>3. Calling an IPC Method</h2>

<p>下面是调用远程接口的步骤：</p>

<p>（1）将 .aidl 文件放置到源码目录下。<br/>
（2）声明 IBinder 对象。<br/>
（3）实现 ServiceConnection。<br/>
（4）调用 Context.bindService()。<br/>
（5）在 onServiceConnected() 中调用 YourInterfaceName.Stub.asInterface((IBinder)service) 得到 IBinder 对象。<br/>
（6）到这步，你就可以使用接口方法了。注意，你应该捕获 DeadObjectException。<br/>
（7）要断开连接，调用 Context.unbindService()。</p>

<p>A few comments on calling an IPC service:<br/>
Objects are reference counted across processes.<br/>
You can send anonymous objects as method arguments.</p>

<p>下面是使用 AIDL 接口的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
<span class='line-number'>150</span>
<span class='line-number'>151</span>
<span class='line-number'>152</span>
<span class='line-number'>153</span>
<span class='line-number'>154</span>
<span class='line-number'>155</span>
<span class='line-number'>156</span>
<span class='line-number'>157</span>
<span class='line-number'>158</span>
<span class='line-number'>159</span>
<span class='line-number'>160</span>
<span class='line-number'>161</span>
<span class='line-number'>162</span>
<span class='line-number'>163</span>
<span class='line-number'>164</span>
<span class='line-number'>165</span>
<span class='line-number'>166</span>
<span class='line-number'>167</span>
<span class='line-number'>168</span>
<span class='line-number'>169</span>
<span class='line-number'>170</span>
<span class='line-number'>171</span>
<span class='line-number'>172</span>
<span class='line-number'>173</span>
<span class='line-number'>174</span>
<span class='line-number'>175</span>
<span class='line-number'>176</span>
<span class='line-number'>177</span>
<span class='line-number'>178</span>
<span class='line-number'>179</span>
<span class='line-number'>180</span>
<span class='line-number'>181</span>
<span class='line-number'>182</span>
<span class='line-number'>183</span>
<span class='line-number'>184</span>
<span class='line-number'>185</span>
<span class='line-number'>186</span>
<span class='line-number'>187</span>
<span class='line-number'>188</span>
<span class='line-number'>189</span>
<span class='line-number'>190</span>
<span class='line-number'>191</span>
<span class='line-number'>192</span>
<span class='line-number'>193</span>
<span class='line-number'>194</span>
<span class='line-number'>195</span>
<span class='line-number'>196</span>
<span class='line-number'>197</span>
<span class='line-number'>198</span>
<span class='line-number'>199</span>
<span class='line-number'>200</span>
<span class='line-number'>201</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static class Binding extends Activity {
</span><span class='line'>    /** The primary interface we will be calling on the service. */
</span><span class='line'>    IRemoteService mService = null;
</span><span class='line'>    /** Another interface we use on the service. */
</span><span class='line'>    ISecondary mSecondaryService = null;
</span><span class='line'>
</span><span class='line'>    Button mKillButton;
</span><span class='line'>    TextView mCallbackText;
</span><span class='line'>
</span><span class='line'>    private boolean mIsBound;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Standard initialization of this activity.  Set up the UI, then wait
</span><span class='line'>     * for the user to poke it before doing anything.
</span><span class='line'>     */
</span><span class='line'>    @Override
</span><span class='line'>    protected void onCreate(Bundle savedInstanceState) {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>
</span><span class='line'>        setContentView(R.layout.remote_service_binding);
</span><span class='line'>
</span><span class='line'>        // Watch for button clicks.
</span><span class='line'>        Button button = (Button)findViewById(R.id.bind);
</span><span class='line'>        button.setOnClickListener(mBindListener);
</span><span class='line'>        button = (Button)findViewById(R.id.unbind);
</span><span class='line'>        button.setOnClickListener(mUnbindListener);
</span><span class='line'>        mKillButton = (Button)findViewById(R.id.kill);
</span><span class='line'>        mKillButton.setOnClickListener(mKillListener);
</span><span class='line'>        mKillButton.setEnabled(false);
</span><span class='line'>
</span><span class='line'>        mCallbackText = (TextView)findViewById(R.id.callback);
</span><span class='line'>        mCallbackText.setText("Not attached.");
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Class for interacting with the main interface of the service.
</span><span class='line'>     */
</span><span class='line'>    private ServiceConnection mConnection = new ServiceConnection() {
</span><span class='line'>        public void onServiceConnected(ComponentName className,
</span><span class='line'>                IBinder service) {
</span><span class='line'>            // This is called when the connection with the service has been
</span><span class='line'>            // established, giving us the service object we can use to
</span><span class='line'>            // interact with the service.  We are communicating with our
</span><span class='line'>            // service through an IDL interface, so get a client-side
</span><span class='line'>            // representation of that from the raw service object.
</span><span class='line'>            mService = IRemoteService.Stub.asInterface(service);
</span><span class='line'>            mKillButton.setEnabled(true);
</span><span class='line'>            mCallbackText.setText("Attached.");
</span><span class='line'>
</span><span class='line'>            // We want to monitor the service for as long as we are
</span><span class='line'>            // connected to it.
</span><span class='line'>            try {
</span><span class='line'>                mService.registerCallback(mCallback);
</span><span class='line'>            } catch (RemoteException e) {
</span><span class='line'>                // In this case the service has crashed before we could even
</span><span class='line'>                // do anything with it; we can count on soon being
</span><span class='line'>                // disconnected (and then reconnected if it can be restarted)
</span><span class='line'>                // so there is no need to do anything here.
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>            // As part of the sample, tell the user what happened.
</span><span class='line'>            Toast.makeText(Binding.this, R.string.remote_service_connected,
</span><span class='line'>                    Toast.LENGTH_SHORT).show();
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public void onServiceDisconnected(ComponentName className) {
</span><span class='line'>            // This is called when the connection with the service has been
</span><span class='line'>            // unexpectedly disconnected -- that is, its process crashed.
</span><span class='line'>            mService = null;
</span><span class='line'>            mKillButton.setEnabled(false);
</span><span class='line'>            mCallbackText.setText("Disconnected.");
</span><span class='line'>
</span><span class='line'>            // As part of the sample, tell the user what happened.
</span><span class='line'>            Toast.makeText(Binding.this, R.string.remote_service_disconnected,
</span><span class='line'>                    Toast.LENGTH_SHORT).show();
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Class for interacting with the secondary interface of the service.
</span><span class='line'>     */
</span><span class='line'>    private ServiceConnection mSecondaryConnection = new ServiceConnection() {
</span><span class='line'>        public void onServiceConnected(ComponentName className,
</span><span class='line'>                IBinder service) {
</span><span class='line'>            // Connecting to a secondary interface is the same as any
</span><span class='line'>            // other interface.
</span><span class='line'>            mSecondaryService = ISecondary.Stub.asInterface(service);
</span><span class='line'>            mKillButton.setEnabled(true);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public void onServiceDisconnected(ComponentName className) {
</span><span class='line'>            mSecondaryService = null;
</span><span class='line'>            mKillButton.setEnabled(false);
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    private OnClickListener mBindListener = new OnClickListener() {
</span><span class='line'>        public void onClick(View v) {
</span><span class='line'>            // Establish a couple connections with the service, binding
</span><span class='line'>            // by interface names.  This allows other applications to be
</span><span class='line'>            // installed that replace the remote service by implementing
</span><span class='line'>            // the same interface.
</span><span class='line'>            bindService(new Intent(IRemoteService.class.getName()),
</span><span class='line'>                    mConnection, Context.BIND_AUTO_CREATE);
</span><span class='line'>            bindService(new Intent(ISecondary.class.getName()),
</span><span class='line'>                    mSecondaryConnection, Context.BIND_AUTO_CREATE);
</span><span class='line'>            mIsBound = true;
</span><span class='line'>            mCallbackText.setText("Binding.");
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    private OnClickListener mUnbindListener = new OnClickListener() {
</span><span class='line'>        public void onClick(View v) {
</span><span class='line'>            if (mIsBound) {
</span><span class='line'>                // If we have received the service, and hence registered with
</span><span class='line'>                // it, then now is the time to unregister.
</span><span class='line'>                if (mService != null) {
</span><span class='line'>                    try {
</span><span class='line'>                        mService.unregisterCallback(mCallback);
</span><span class='line'>                    } catch (RemoteException e) {
</span><span class='line'>                        // There is nothing special we need to do if the service
</span><span class='line'>                        // has crashed.
</span><span class='line'>                    }
</span><span class='line'>                }
</span><span class='line'>
</span><span class='line'>                // Detach our existing connection.
</span><span class='line'>                unbindService(mConnection);
</span><span class='line'>                unbindService(mSecondaryConnection);
</span><span class='line'>                mKillButton.setEnabled(false);
</span><span class='line'>                mIsBound = false;
</span><span class='line'>                mCallbackText.setText("Unbinding.");
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    private OnClickListener mKillListener = new OnClickListener() {
</span><span class='line'>        public void onClick(View v) {
</span><span class='line'>            // To kill the process hosting our service, we need to know its
</span><span class='line'>            // PID.  Conveniently our service has a call that will return
</span><span class='line'>            // to us that information.
</span><span class='line'>            if (mSecondaryService != null) {
</span><span class='line'>                try {
</span><span class='line'>                    int pid = mSecondaryService.getPid();
</span><span class='line'>                    // Note that, though this API allows us to request to
</span><span class='line'>                    // kill any process based on its PID, the kernel will
</span><span class='line'>                    // still impose standard restrictions on which PIDs you
</span><span class='line'>                    // are actually able to kill.  Typically this means only
</span><span class='line'>                    // the process running your application and any additional
</span><span class='line'>                    // processes created by that app as shown here; packages
</span><span class='line'>                    // sharing a common UID will also be able to kill each
</span><span class='line'>                    // other's processes.
</span><span class='line'>                    Process.killProcess(pid);
</span><span class='line'>                    mCallbackText.setText("Killed service process.");
</span><span class='line'>                } catch (RemoteException ex) {
</span><span class='line'>                    // Recover gracefully from the process hosting the
</span><span class='line'>                    // server dying.
</span><span class='line'>                    // Just for purposes of the sample, put up a notification.
</span><span class='line'>                    Toast.makeText(Binding.this,
</span><span class='line'>                            R.string.remote_call_failed,
</span><span class='line'>                            Toast.LENGTH_SHORT).show();
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    // ----------------------------------------------------------------------
</span><span class='line'>    // Code showing how to deal with callbacks.
</span><span class='line'>    // ----------------------------------------------------------------------
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * This implementation is used to receive callbacks from the remote
</span><span class='line'>     * service.
</span><span class='line'>     */
</span><span class='line'>    private IRemoteServiceCallback mCallback = new IRemoteServiceCallback.Stub() {
</span><span class='line'>        /**
</span><span class='line'>         * This is called by the remote service regularly to tell us about
</span><span class='line'>         * new values.  Note that IPC calls are dispatched through a thread
</span><span class='line'>         * pool running in each process, so the code executing here will
</span><span class='line'>         * NOT be running in our main thread like most other things -- so,
</span><span class='line'>         * to update the UI, we need to use a Handler to hop over there.
</span><span class='line'>         */
</span><span class='line'>        public void valueChanged(int value) {
</span><span class='line'>            mHandler.sendMessage(mHandler.obtainMessage(BUMP_MSG, value, 0));
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    private static final int BUMP_MSG = 1;
</span><span class='line'>
</span><span class='line'>    private Handler mHandler = new Handler() {
</span><span class='line'>        @Override public void handleMessage(Message msg) {
</span><span class='line'>            switch (msg.what) {
</span><span class='line'>                case BUMP_MSG:
</span><span class='line'>                    mCallbackText.setText("Received from service: " + msg.arg1);
</span><span class='line'>                    break;
</span><span class='line'>                default:
</span><span class='line'>                    super.handleMessage(msg);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Bound Services]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/28/android-bound-services/"/>
    <updated>2014-08-28T10:01:42+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/28/android-bound-services</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/bound-services.html">http://developer.android.com/guide/components/bound-services.html</a></p>

<p>Bound Service（绑定的服务）是“客户端-服务端”模型中的服务端部分（下文中提到的客户端和使用服务的其它组件是一个意思），它接收其它组件的服务请求并返回处理结果。它的典型使用场景是为其它组件提供有交互的服务，而并不是在后台（像 Started Service 那样）长期运行。另外一个重要作用是 IPC。</p>

<p>在深入 Bound Service 之前，最好先了解 <a href="http://blog.xuanxi.me/blog/2014/08/26/android-services/">Services</a> 的内容。</p>

<!--more-->


<h2>1. The Basics</h2>

<p>组件通过 bindService() 方法绑定 Service，同时需要实现一个 ServiceConnection，其中的 onServiceConnected() 方法用来传递 IBinder 对象，而 IBinder 对象就是“客户端-服务端”交互的接口对象。</p>

<p>Android 支持多个组件同时绑定一个 Service，不过，只在第一个组件绑定时系统会调用一次 onBind()，后面的绑定会直接获得 IBinder 对象而不需要再次调 onBind()。</p>

<p>注意： <br/>
Service 可以同时被 start 和 bind，如果这样，你需要同时实现 onBind() 和 onStartCommand()，并且只有在 unbind 和 stop 之后才会被销毁。常见的例子如音乐播放器，既需要在离开界面后在后台播放（start 方式），也需要在有界面的时候控制播放（bind 方式）。</p>

<h2>2. Creating a Bound Service</h2>

<p>Service 通过 IBinder 来提供对外接口，以下为三种接口定义方式：</p>

<p>（1）继承 Binder 类<br/>
适用于同应用同进程内绑定 Service 的情况。Binder 类实现了 IBinder 接口。</p>

<p>（2）使用 Messenger<br/>
适用于简单的 IPC，单线程执行任务。上层使用 Handler 和 Message 来运作，底层基于 AIDL。</p>

<p>（3）使用 AIDL<br/>
标准的 IPC。相比 Messenger，AIDL 支持多线程任务，但要注意处理线程安全问题。关于 AIDL 的详细介绍见 <a href="http://blog.xuanxi.me/blog/2014/08/28/android-aidl/">AIDL</a>。</p>

<h3>Extending the Binder class</h3>

<p>如果仅在同应用同进程内使用 Service，可以通过实现 Binder 来提供对外接口。</p>

<p>下面是具体的实现步骤：<br/>
（1）在 Service 内部定义一个 Binder 类，类内部提供公共方法供客户端访问，可以通过这个方法返回 Service 对象，或者 Service 所持有的其它对象。  <br/>
（2）使用上一步的 Binder 类创建一个 IBinder 对象，并在 onBind() 返回这个对象。<br/>
（3）在客户端中，通过 onServiceConnected() 方法得到 IBinder 对象，用这个 IBinder 对象就可以访问 Service 中的字段和方法了。</p>

<p>下面是一个 Bound Service 的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class LocalService extends Service {
</span><span class='line'>    // Binder given to clients
</span><span class='line'>    private final IBinder mBinder = new LocalBinder();
</span><span class='line'>    // Random number generator
</span><span class='line'>    private final Random mGenerator = new Random();
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Class used for the client Binder.  Because we know this service always
</span><span class='line'>     * runs in the same process as its clients, we don't need to deal with IPC.
</span><span class='line'>     */
</span><span class='line'>    public class LocalBinder extends Binder {
</span><span class='line'>        LocalService getService() {
</span><span class='line'>            // Return this instance of LocalService so clients can call public methods
</span><span class='line'>            return LocalService.this;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public IBinder onBind(Intent intent) {
</span><span class='line'>        return mBinder;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /** method for clients */
</span><span class='line'>    public int getRandomNumber() {
</span><span class='line'>      return mGenerator.nextInt(100);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>LocalBinder 提供了 getService() 方法让客户端得到 LocalService 对象，这样，客户端就可以使用 Service 的公共接口了。</p>

<p>下面的代码展示了一个 Activity 绑定 LocalService，并在点击按钮时调用 getRandomNumber() 接口方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class BindingActivity extends Activity {
</span><span class='line'>    LocalService mService;
</span><span class='line'>    boolean mBound = false;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onCreate(Bundle savedInstanceState) {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.main);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onStart() {
</span><span class='line'>        super.onStart();
</span><span class='line'>        // Bind to LocalService
</span><span class='line'>        Intent intent = new Intent(this, LocalService.class);
</span><span class='line'>        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onStop() {
</span><span class='line'>        super.onStop();
</span><span class='line'>        // Unbind from the service
</span><span class='line'>        if (mBound) {
</span><span class='line'>            unbindService(mConnection);
</span><span class='line'>            mBound = false;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /** Called when a button is clicked (the button in the layout file attaches to
</span><span class='line'>      * this method with the android:onClick attribute) */
</span><span class='line'>    public void onButtonClick(View v) {
</span><span class='line'>        if (mBound) {
</span><span class='line'>            // Call a method from the LocalService.
</span><span class='line'>            // However, if this call were something that might hang, then this request should
</span><span class='line'>            // occur in a separate thread to avoid slowing down the activity performance.
</span><span class='line'>            int num = mService.getRandomNumber();
</span><span class='line'>            Toast.makeText(this, "number: " + num, Toast.LENGTH_SHORT).show();
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /** Defines callbacks for service binding, passed to bindService() */
</span><span class='line'>    private ServiceConnection mConnection = new ServiceConnection() {
</span><span class='line'>
</span><span class='line'>        @Override
</span><span class='line'>        public void onServiceConnected(ComponentName className,
</span><span class='line'>                IBinder service) {
</span><span class='line'>            // We've bound to LocalService, cast the IBinder and get LocalService instance
</span><span class='line'>            LocalBinder binder = (LocalBinder) service;
</span><span class='line'>            mService = binder.getService();
</span><span class='line'>            mBound = true;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        @Override
</span><span class='line'>        public void onServiceDisconnected(ComponentName arg0) {
</span><span class='line'>            mBound = false;
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Using a Messenger</h3>

<p>对于简单的 IPC 任务，使用 Messenger 比使用 AIDL 更简单，因为 Messenger 使用一个消息队列来处理所有服务请求，而纯粹的 AIDL 需要处理并发的服务请求。</p>

<p>以下是实现要点：<br/>
（1）Service 内部定义一个 Handler 类，用来接收并处理消息。<br/>
（2）创建一个 Messenger 对象，创建时还要使用上一步的 Handler 对象。<br/>
（3）在 onBind() 中由 Messenger 创建 IBinder 对象，返回给客户端。<br/>
（4）客户端使用 IBinder 实例化一个 Messenger，用来向 Service 发送消息。<br/>
（5）Service 接收消息，并在 Handler 中处理。</p>

<p>可见，使用 Messenger 的话，Service 不能提供方法给客户端直接调用，而只能通过消息来交互。</p>

<p>Service 示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class MessengerService extends Service {
</span><span class='line'>    /** Command to the service to display a message */
</span><span class='line'>    static final int MSG_SAY_HELLO = 1;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Handler of incoming messages from clients.
</span><span class='line'>     */
</span><span class='line'>    class IncomingHandler extends Handler {
</span><span class='line'>        @Override
</span><span class='line'>        public void handleMessage(Message msg) {
</span><span class='line'>            switch (msg.what) {
</span><span class='line'>                case MSG_SAY_HELLO:
</span><span class='line'>                    Toast.makeText(getApplicationContext(), "hello!", Toast.LENGTH_SHORT).show();
</span><span class='line'>                    break;
</span><span class='line'>                default:
</span><span class='line'>                    super.handleMessage(msg);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Target we publish for clients to send messages to IncomingHandler.
</span><span class='line'>     */
</span><span class='line'>    final Messenger mMessenger = new Messenger(new IncomingHandler());
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * When binding to the service, we return an interface to our messenger
</span><span class='line'>     * for sending messages to the service.
</span><span class='line'>     */
</span><span class='line'>    @Override
</span><span class='line'>    public IBinder onBind(Intent intent) {
</span><span class='line'>        Toast.makeText(getApplicationContext(), "binding", Toast.LENGTH_SHORT).show();
</span><span class='line'>        return mMessenger.getBinder();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>客户端示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class ActivityMessenger extends Activity {
</span><span class='line'>    /** Messenger for communicating with the service. */
</span><span class='line'>    Messenger mService = null;
</span><span class='line'>
</span><span class='line'>    /** Flag indicating whether we have called bind on the service. */
</span><span class='line'>    boolean mBound;
</span><span class='line'>
</span><span class='line'>    /**
</span><span class='line'>     * Class for interacting with the main interface of the service.
</span><span class='line'>     */
</span><span class='line'>    private ServiceConnection mConnection = new ServiceConnection() {
</span><span class='line'>        public void onServiceConnected(ComponentName className, IBinder service) {
</span><span class='line'>            // This is called when the connection with the service has been
</span><span class='line'>            // established, giving us the object we can use to
</span><span class='line'>            // interact with the service.  We are communicating with the
</span><span class='line'>            // service using a Messenger, so here we get a client-side
</span><span class='line'>            // representation of that from the raw IBinder object.
</span><span class='line'>            mService = new Messenger(service);
</span><span class='line'>            mBound = true;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        public void onServiceDisconnected(ComponentName className) {
</span><span class='line'>            // This is called when the connection with the service has been
</span><span class='line'>            // unexpectedly disconnected -- that is, its process crashed.
</span><span class='line'>            mService = null;
</span><span class='line'>            mBound = false;
</span><span class='line'>        }
</span><span class='line'>    };
</span><span class='line'>
</span><span class='line'>    public void sayHello(View v) {
</span><span class='line'>        if (!mBound) return;
</span><span class='line'>        // Create and send a message to the service, using a supported 'what' value
</span><span class='line'>        Message msg = Message.obtain(null, MessengerService.MSG_SAY_HELLO, 0, 0);
</span><span class='line'>        try {
</span><span class='line'>            mService.send(msg);
</span><span class='line'>        } catch (RemoteException e) {
</span><span class='line'>            e.printStackTrace();
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onCreate(Bundle savedInstanceState) {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.main);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onStart() {
</span><span class='line'>        super.onStart();
</span><span class='line'>        // Bind to the service
</span><span class='line'>        bindService(new Intent(this, MessengerService.class), mConnection,
</span><span class='line'>            Context.BIND_AUTO_CREATE);
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    protected void onStop() {
</span><span class='line'>        super.onStop();
</span><span class='line'>        // Unbind from the service
</span><span class='line'>        if (mBound) {
</span><span class='line'>            unbindService(mConnection);
</span><span class='line'>            mBound = false;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的例子没有展示 Service 如何向客户端做出响应，如果你要接收响应，可参考 <a href="http://developer.android.com/resources/samples/ApiDemos/src/com/example/android/apis/app/MessengerService.html">MessengerService.java</a> 和 <a href="http://developer.android.com/resources/samples/ApiDemos/src/com/example/android/apis/app/MessengerServiceActivities.html">MessengerServiceActivities.java</a>。</p>

<h2>3. Binding to a Service</h2>

<p>组件调用 bindService() 绑定 Service，系统随后会调用 Service 的 onBind()，并返回 IBinder 对象用于与客户端交互。</p>

<p>绑定操作是异步的，bindService() 方法调用后会立即返回，而且不会带回 IBinder 对象。要得到 IBinder 对象，客户端必须实现 ServiceConnection 类，并在它的回调方法中得到 IBinder。</p>

<p>注意：<br/>
四大应用组件中，BroadcastReceiver 不能绑定 Service。</p>

<p>（bind 的具体实现略）</p>

<h3>补充说明</h3>

<p>（1）在客户端调用 Service 接口的时候，应该捕获 DeadObjectException 异常，以确认与 Service 的连接是否中断，这是唯一一个远程接口会抛出的异常。<br/>
（2）Objects are reference counted across processes.（Service 对象的引用计数是跨进程的？）  <br/>
（3）应该成对使用 bind 和 unbind 方法。可以 bind during onStart() and unbind during onStop()，或者 bind during onCreate() and unbind during onDestroy().<br/>
（4）你不应该 bind and unbind during your activity&rsquo;s onResume() and onPause()，因为 onResume() 和 onPause() 这两个方法在每次生命周期改变时都会被调用，你不得不控制后台处理的时间在最小范围，并且如果多个 Activity 切换（这些 Activity 都绑定了 Service），bind 和 unbind 就会频繁执行，这明显是不好的。</p>

<h2>4. Managing the Lifecycle of a Bound Service</h2>

<p><img src="http://xuanxi.github.io/images/service_binding_tree_lifecycle.png" alt="service_binding_tree_lifecycle" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Services]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/26/android-services/"/>
    <updated>2014-08-26T17:14:33+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/26/android-services</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/components/services.html">http://developer.android.com/guide/components/services.html</a></p>

<p>推荐文章：<br/>
<a href="http://blog.csdn.net/guolin_blog/article/details/11952435">Android Service完全解析，关于服务你所需知道的一切</a></p>

<p>本文包括以下几个部分：<br/>
1. The Basics<br/>
2. Creating a Started Service<br/>
3. Creating a Bound Service<br/>
4. Sending Notifications to the User<br/>
5. Running a Service in the Foreground<br/>
6. Managing the Lifecycle of a Service</p>

<!--more-->


<p>Service 是 Android 提供的四大应用组件之一，它与界面无关，用在后台执行长时间的操作。无论同一个应用还是其它应用的组件都可以启动 Service。你可以通过绑定的方式来和 Service 进行交互，以及实现进程间通信（IPC）。比如，你可以使用 Service 来处理网络请求、播放音乐、读写文件等，所有这些操作都在后台进行，而无需界面支持。</p>

<p>有两种形式的 Service：</p>

<p>（1）Started<br/>
通过 startService() 启动。这种 Service 一旦被启动，就会一直在后台运行，即使启动它的组件已经销毁。通常，它被用来执行单一的不带返回的操作，比如下载或上传文件，当下载或上传成功后，它就自动退出了。</p>

<p>（2）Bound<br/>
通过 bindService() 启动。这种 Service 用来实现“客户端-服务端”的模型——客户端发出请求，服务端执行请求并返回结果。</p>

<p>值得注意的是，一个 Service 可以同时被 start 和 bind，分别对应 onStartCommand() 和 onBind() 方法。无论是 start 方式还是 bind 方式，任何组件都可以使用 Intent 来启动 Service，就像启动 Activity 一样。不过，你可以在 manifest 文件中将 Service 设置为私有（<code>android:exported="false"</code>），这样就可以阻止其它应用的访问了。</p>

<p>注意：Service 运行在 UI 线程上，你应该创建工作线程来执行耗时操作。</p>

<h2>1. The Basics</h2>

<p>要使用 Service，你应该派生 Service 的子类，并实现相关的方法：</p>

<h4>onStartCommand()</h4>

<p>startService() 方式对应的方法，使用 stopSelf()（内部调用） 或 stopService()（其它组件调用） 来停止 Service。</p>

<h4>onBind()</h4>

<p>bindService() 方式对应的方法。无论是否采用绑定的方式，你都必须实现该方法，如果不希望被绑定，这个方法要返回 null。</p>

<h4>onCreate()</h4>

<p>在 onStartCommand() or onBind() 之前调用的方法。在 Service 生命周期内只调用一次。</p>

<h4>onDestroy()</h4>

<p>销毁 Service 的时候被调用。</p>

<h3>（重要）Should you use a service or a thread?</h3>

<p>如果你只希望在界面交互过程中做一些异步操作（异步操作的时间不会长于当前界面的停留时间），就应该考虑使用线程而不是 Service。比如，你只想在一个 Activity 上播放音乐，就可以在 onCreate() 里创建播放线程，在 onStart() 里开始播放，在 onStop() 里停止播放。另外，你应该考虑使用 AsyncTask 或 HandlerThread 来代替传统的 Thread。</p>

<p>官方这里说得太简单，我作一下补充：<br/>
（1）很多人会笼统地去区别 Service 和 Thread，我认为这是不妥的。Service 和 Thread 不是同一个层次的概念，前者是 Android 的组件机制，后者是现代操作系统的执行机制（程序的调度单位），所有的 Service 都运行在线程上，当然，你也可以在 Service 里创建一个 Thread 来执行任务。之所以容易混淆它们，是因为它们都可以用来执行后台任务，即用法相似。<br/>
（2）我们应该从具体使用场景上去比较 Service 和 Thread。比如上面官方给出的只在前台播放音乐的例子，使用 Service 也可以实现（Bound Service + Thread），只不过直接使用 Thread 更轻量级，而使用 Service 明显更麻烦，开销更大。<br/>
（3）当我们需要执行一个长期的后台任务，比如即时通信中的消息接收、心跳检测，使用 “Service + Thread” 比使用 “Activity + Thread” 能获得更长的后台处理周期。因为离开 Activity 就意味着失去对 Thread 的控制，更坏的结果是，应用进入后台进程状态后有可能被杀掉，Thread 也就随之销毁了，而使用 Service 的服务进程不会轻易被杀掉。</p>

<h3>Declaring a service in the manifest</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;manifest ... &gt;
</span><span class='line'>  ...
</span><span class='line'>  &lt;application ... &gt;
</span><span class='line'>      &lt;service android:name=".ExampleService" /&gt;
</span><span class='line'>      ...
</span><span class='line'>  &lt;/application&gt;
</span><span class='line'>&lt;/manifest&gt;</span></code></pre></td></tr></table></div></figure>


<p><code>android:name</code> 是必需属性，另外还有 <code>android:exported</code>、<code>android:permission</code> 和 <code>android:process</code> 属性可选。要注意的是，一旦发布了应用，就不要改动 Service 的名字。</p>

<p>官方建议不要为 Service 设置 intent filters，而应该使用显式 Intent 去启动，说是为了应用安全（为什么不安全？？）。如果确实需要设置 intent filters，你必须为 Intent 设置 package。</p>

<p><code>android:exported</code> 属性设置 Service 是否对其它应用开放。</p>

<h2>2. Creating a Started Service</h2>

<p>其它组件通过 startService() 启动 Service，同时可以通过 Intent 带上数据，接着，Service 的 onStartCommand() 会被调用。Service 启动后，执行独立的生命周期，与启动它的组件的生命周期无关。要结束 Service ，可在内部调用 stopSelf()，或其它组件调用 stopService()。</p>

<p>要创建 Started Service，可以继承以下两个类：</p>

<p>（1）Service<br/>
Service 的基础类，运行在主线程上。</p>

<p>（2）IntentService<br/>
Service 的子类，整合了一条工作线程（单线程模型），任务放在 onHandleIntent() 方法里执行。</p>

<h3>Extending the IntentService class</h3>

<p>IntentService 适用于对并发要求不高的情况，它具体做了以下事情：<br/>
（1）创建一条工作线程来执行任务。<br/>
（2）创建一个工作队列，按顺序处理队列中的任务。<br/>
（3）当所有任务处理完后，自动关闭服务。<br/>
（4）提供了默认的 onBind() 实现。<br/>
（5）提供了默认的 onStartCommand() 实现。<br/>
由此可见，对于 IntentService 的使用，你需要做的仅仅是实现 onHandleIntent()，以及提供构造方法。</p>

<p>补充：<br/>
从源码可知，IntentService 只是简单地使用了 HandlerThread 来实现这种单线程模型，任务队列就是线程的消息队列。</p>

<p>（具体实现略）</p>

<h3>Extending the Service class</h3>

<p>如果对并发要求很高，就要用普通的 Service，你可以在 onStartCommand() 里为每个任务创建一条线程，一般情况下使用线程池会比较好。</p>

<p>onStartCommand() 中的返回值告诉系统怎样处理被杀掉的 Service（因内存不足被系统回收），这些返回值起作用的前提是 onStartCommand() 已经执行完毕并返回：</p>

<p>（1）START_NOT_STICKY<br/>
不重建 Service，直到有新的服务请求。</p>

<p>（2）START_STICKY<br/>
重建 Service，并调用 onStartCommand()，但不带有上一次的 intent。适用于长时间运行并等待执行动作的任务，如媒体播放服务。</p>

<p>（3）START_REDELIVER_INTENT<br/>
重建 Service，调用 onStartCommand()，并带有上一次的 intent。适用于立即执行的后台任务，如文件下载。</p>

<p>（具体实现略）</p>

<h3>Starting a Service</h3>

<p>（具体实现略）</p>

<p>要注意的是，多个任务请求会调用多次 onStartCommand()，而关闭只需要一次。</p>

<h3>Stopping a service</h3>

<p>Service 的生命周期需要开发者来管理，即系统不会主动去关闭一个 Service，除非是资源回收，或者使用 IntentService（IntentService 已经在内部调用了 stopSelf()，因此也不需要开发者去关闭）
，所以，需要显式调用 stopSelf() 或 stopService()。而一旦调用了 stopSelf() or stopService()，系统就会尽快销毁这个 Service。</p>

<p>关闭 Service 时要注意一个问题，如果这个 Service 用于处理并发任务（Service 内部使用多线程），不要在一个任务执行完后就关闭 Service（调用 stopSelf() 或 stopService()），因为关闭的时候，可能一个新的服务请求已经进来，可能这个新请求尚未执行完成，就随着关闭操作而被终止了（stopping at the end of the first request would terminate the second one）。除非你可以很好地保证服务请求的次序，保证所有任务都完成后才关闭，或者关闭之前不会有新的请求进来，但这样可能需要在业务流程上做更多的处理。<br/>
官方对这个问题给出了很好的解决办法，就是使用 stopSelf(int)。留意 onStartCommand(Intent intent, int flags, int startId) 中的第三个参数 startId，每次调用都会生成一个唯一的 startId，用于对应本次服务请求。我们在 Service 内部需要关闭 Service 的地方调用 stopSelf(int)，参数是最近一次已经执行完成的服务请求的 startId。如果调用 stopSelf(int) 的时候有新请求进来，那么 stopSelf 中的 startId 和 onStartCommand 中的startId 就会不一致，stopSelf 就不会调用成功。</p>

<h2>3. Creating a Bound Service</h2>

<p>见<a href="http://blog.xuanxi.me/blog/2014/08/28/android-bound-services/">Bound Services</a></p>

<h2>4. Sending Notifications to the User</h2>

<p>Service 一旦启动，可以通过 Toaste 或 Status Bar 来显示一些必要信息，比如告诉用户后台任务已经开始或者结束。</p>

<h2>5. Running a Service in the Foreground</h2>

<p>前台服务是用户希望关注其实时状态的服务。它必须使用通知，并处于 &ldquo;Ongoing&rdquo; heading 下，这样，除非服务被暂停或者退出前台服务，否则不会从通知栏消失（被划掉）。例如，音乐播放应用使用前台进程处理音乐播放，用户可以在通知栏看到播放状态，并提供一些播放操作。</p>

<p>（具体实现略）</p>

<h2>6. Managing the Lifecycle of a Service</h2>

<h3>Implementing the lifecycle callbacks</h3>

<p><img src="http://xuanxi.github.io/images/service_lifecycle.png" alt="service_lifecycle" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Recent Apps]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/24/android-recent-apps/"/>
    <updated>2014-08-24T22:56:30+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/24/android-recent-apps</id>
    <content type="html"><![CDATA[<p>最近听一些同学说到，通过最近应用界面（官方叫 Recents screen，以下简称 Recents）可以杀掉应用，这是不完全正确的说法。本文对此作一些分析，欢迎提出异议。</p>

<!--more-->


<p>Google 在 Android Design 文档中对 Recents 的描述如下：<br/>
Recents provides an efficient way of switching between recently used applications. It provides a clear navigation path between multiple ongoing tasks. Switch to an app by touching it. Remove an item by swiping left or right.<br/>
意思是通过 Recents 可以快速切换最近的应用，也可以将应用从中删除，但并没有提到删除的结果是什么。当然了，Design 文档只针对界面设计而不会介绍运行机制的内容。</p>

<p>而就职于 Google Android 部门的 <a href="https://plus.google.com/105051985738280261832/posts">Dianne Hackborn</a> 的一篇<a href="https://plus.google.com/105051985738280261832/posts/GfwRYCC42uX">文章</a>讨论到多任务的话题，他在一条评论的回复中说到：</p>

<p><em>what specifically happens when you swipe away a recent task is it: (1) kills any background or empty processes of the application (see <a href="http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html#Lifecycle">http://developer.android.com/guide/topics/fundamentals/processes-and-threads.html#Lifecycle</a> for what this means), and (2) uses the new <a href="http://developer.android.com/reference/android/app/Service.html#onTaskRemoved(android.content.Intent)">http://developer.android.com/reference/android/app/Service.html#onTaskRemoved(android.content.Intent)</a> API to tell any services of the application about the task being removed so it can do whatever it thinks is appropriate.</em></p>

<p>他在另一篇<a href="http://www.extremetech.com/computing/112013-how-multitasking-works-on-android-and-ios#comment-402624620">文章</a>的评论中也说到：</p>

<p><em>Actually, removing an entry in recent tasks will kill any background processes that exist for the process. It won&rsquo;t directly causes services to stop, however there is an API for them to find out the task was removed to decide if they want this to mean they should stop. This is so that removing say the recent task of an e-mail app won&rsquo;t cause it to stop checking for e-mail.<br/>
If you really want to completely stop an app, you can long press on recent tasks to go to app info, and hit force stop there. For stop is a complete kill of the app &mdash; all processes are killed, all services stopped, all notifications removed, all alarms removed, etc. The app is not allowed to launch again until explicitly requested.</em></p>

<p>他的意思是以下几点：<br/>
（1）删除应用只会杀掉与该应用相关的后台进程和空进程，而不会杀掉服务进程，关于 Android 进程的介绍点击<a href="http://blog.xuanxi.me/blog/2014/08/23/android-processes-and-threads/">这里</a>；<br/>
（2）如果想在删除过程中对 Service 做一些操作，可重写 onTaskRemoved()；<br/>
（3）如果需要关闭整个应用，可以：长按应用->应用信息->强制停止，这样所有相关进程都被杀掉了。</p>

<p>我们可以验证一下：<br/>
（1）打开一个带有 Service 组件的应用，如 QQ；<br/>
（2）从 Recents 将 QQ 删除；<br/>
（3）打开“设置->应用->正在运行（非缓存）”，可以看到 QQ 仍然在运行，处于服务进程状态；<br/>
（4）再打开一个只有 Activity 组件的应用；<br/>
（5）打开“正在运行（缓存）”，可以看到应用已经转为后台进程状态；<br/>
（5）从 Recents 删除；<br/>
（6）打开“正在运行（缓存）”，应用很快就消失了，说明进程已被杀掉。</p>

<p>验证结果证实了 <a href="https://plus.google.com/105051985738280261832/posts">Dianne Hackborn</a> 的说法。</p>

<p>Android 有一套比较完善的内存管理机制，通常情况下，会试图让进程运行尽量长的时间，以提供更好的用户体验（如更快的启动速度），当内存确实不足的时候，就会按一定规则去杀掉进程，上述这些内存管理工作都是不需要用户直接参与的。对于 Recents，虽然通过它的确可以杀掉后台进程并释放一定空间，但这个本来就是系统自身的工作，并且已经在底层默默进行着，所以，我认为 Android 提供 Recents 界面的初衷就是让用户可以快速切换最近的应用或者说任务，只不过用户把应用删掉之后，Android 可以更确定地把这个应用的空间也释放出来。</p>

<p>补充：从3.1开始，被强制停止的应用处于 Stopped 状态，而 Stopped 状态是接收不到广播的，除非给广播带上 FLAG_INCLUDE_STOPPED_PACKAGES。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Processes and Threads]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/23/android-processes-and-threads/"/>
    <updated>2014-08-23T12:05:49+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/23/android-processes-and-threads</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://developer.android.com/guide/components/processes-and-threads.html">http://developer.android.com/guide/components/processes-and-threads.html</a></p>

<p>在一个应用组件启动的时候，如果当前这个应用没有其它组件在运行，Android 就会为该应用分配一个带有一条独立执行线程（称之为 main 线程）的 Linux 进程。默认情况下，这个应用后来启动的所有组件都会运行在相同的进程和线程中。当然，你也可以为不同的组件创建不同的进程，以及为同一个进程创建多条线程。</p>

<!--more-->


<h2>1. Processes</h2>

<p>一般情况下，一个应用所有的组件都运行在同一个进程里，进程的名字是应用的根包名。如果你需要为某个组件提供独立的进程，可以在 manifest 文件中设置。</p>

<p>manifest 文件中的四大组件元素——<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code>、<code>&lt;provider&gt;</code>——都支持通过 <code>android:process</code> 属性来指定运行的进程，你可以为每个组件创建独立的进程，或者几个组件共享一个进程。也可以为不同应用的组件配置同一个进程，前提是这些应用使用相同的 <code>android:sharedUserId</code>和签名。</p>

<p>补充：通过为不同应用设置相同的 sharedUserId 和签名，可以共享各自沙盒内的数据文件，比如数据库和 SharedPreference。如果再给它们的组件设置同一个进程，那么就可以共享任何数据了（文件数据和内存数据）。</p>

<p>另外，<code>&lt;application&gt;</code> 元素也支持 <code>android:process</code>，可以为所有的组件设置同一个进程。</p>

<h3>Process lifecycle</h3>

<p>Android 会试图让进程运行尽可能长的时间，只有在内存不足时，才会终止那些旧的进程，以此来保证更好的用户体验。Android 管理进程的机制是：将所有进程放入一个“重要性等级树”中，这个“重要性等级树”基于组件的运行状态，低等级的进程会首先被终止，然后是等级高一点的进程，以此类推。</p>

<p>进程的重要性等级按降低顺序排列如下：</p>

<h4>（1）前台进程</h4>

<p>前台进程是用户正在交互的进程，包括以下情况：<br/>
1）持有一个与用户交互的 Activity（onResume() 被调用）；<br/>
2）持有一个 Service，这个 Service 被绑定到一个正在与用户交互的 Activity 中；<br/>
3）持有一个 Service，它调用了 startForeground()，也叫前台 Service（如在通知栏显示的音乐播放服务）；<br/>
4）持有一个正在执行生命周期方法的 Service，如 onCreate()、onStart()、or onDestroy()；<br/>
5）持有一个正在执行 onReceive() 的 BroadcastReceiver。</p>

<p>通常，在任何时间内只会存在少数的前台进程，它们只会在内存空间紧张到不能保证全部前台进程都正常运行的情况下被杀掉。那时，设备处于内存分页状态（增加内存空间的机制，见下面的解释），只能通过杀掉一些前台进程来保持用户界面的响应。</p>

<p>Paging：In computer operating systems, paging is one of the memory-management schemes by which a computer can store and retrieve data from secondary storage for use in main memory.</p>

<h4>（2）可视进程</h4>

<p>可视进程不含有任何前台组件，但仍然对用户看见的界面有影响：<br/>
1）持有一个 Activity，它不处于前台与用户交互，但仍然可见（调用了 onPause()），比如打开一个对话框后，这个 Activity 位于对话框下面，处于可见状态；<br/>
2）持有一个 Service，它被绑定到一个可视或前台 Activity（这里官方说到前台 Activity，那不就是前台进程了么？？）；</p>

<h4>（3）服务进程</h4>

<p>服务进程中运行着一个通过 startService() 启动的 Service。虽然服务进程跟用户可见的界面没有关联，但它通常在处理用户关心的事情，比如后台音乐播放、文件下载等。</p>

<h4>（4）后台进程</h4>

<p>后台进程持有一个用户不可见的 Activity（调用了 onStop() 方法，注意并不是 onDestroy()），这些进程不会对用户体验产生影响，所以系统可以在任何时候将它们杀掉。一般会有许多后台进程在运行着，系统通过 LRU （最近使用）列表来管理这里进程，以确保最常使用的进程在最后才被杀掉。</p>

<h4>（5）空进程</h4>

<p>空进程中不包含任何处在生命周期中的组件，保留空进程的原因仅仅是作为缓存使用，当下次启动相关联的组件的时候，进程可以快速运行起来。</p>

<p>Android 会尽量将一个进程放在它能到达的最高的等级。比如，进程中持有一个 Service 和 一个可视的 Activity，这个进程将被视为可视进程，而不是服务进程。</p>

<p>另外，当一个进程为另一个进程提供服务时，这个进程不会比另一个进程的等级低。比如，进程 A 中的 Content Provider 为进程 B 提供服务，或者，进程 A 的 Service 被绑定到进程 B，这两个例子中的进程 A 的等级至少和进程 B 一样高。</p>

<p>（非常重要的总结）<br/>
因为服务进程比后台进程的重要性高，所以如果要在 Activity 中进行一些耗时操作，最好把这些操作放到 Service 中，尤其是这些操作会比 Activity 运行时间更长的情况下。比如，对于 Activity 中的图片上传操作，应该开启一个 Service 去执行，以便在退出 Activity 后上传操作可以继续在服务进程中进行，否则，进程在转为后台进程甚至空进程后，很有可能被杀死，上传操作也随之中断。所以说，使用 Service 可以保证某些操作至少运行在“服务进程”的级别，而不管 Activity 是否已经退出。同样地，BroadcastReceiver 中的耗时操作也应该放到 Service 中进行（Android 对 onReceive() 方法有时间限制，通常为5秒）。</p>

<h2>2. Threads</h2>

<p>当应用启动的时候，系统会为之创建一条主线程。主线程非常重要，它负责用户界面事件的分发和处理，包括绘图事件、UI 事件等，主线程通常也被叫做 UI 线程。所有同一个进程中的系统组件都运行在 UI 线程上，所以，系统回调方法（像 onKeyDown() 或者生命周期方法）都会在 UI 线程上执行。</p>

<p>例如，当用户点击按钮，应用的 UI 线程会将点击事件分发给控件，控件就会置当前状态为按下状态，同时发送 invalidate 请求到 UI 线程的事件队列，UI 线程取出请求消息并通知控件重绘。</p>

<p>当交互过程中要执行一些耗时操作时，比如请求网络或读取数据库，可能会阻塞 UI 线程，以致不能分发和处理其它事件，包括绘图事件。如果阻塞超过5秒，系统会弹出 ANR 对话框。这种糟糕的体验会令用户退出你的应用，甚至卸载。</p>

<p>另外，UI 组件不是线程安全的，你不能在工作线程上处理 UI。综上所述，有两种规则去处理 Android 的单线程模型：<br/>
（1）不要阻塞 UI 线程；<br/>
（2）不要在非 UI 线程上操作 UI。</p>

<h3>Worker threads</h3>

<p>Android 的单线程模型要求你不能阻塞 UI 线程，所以你应该将耗时操作放在新的线程上执行，称之为后台线程或工作线程。</p>

<p>例如，下面的代码是一个点击事件监听器，使用工作线程下载图片并显示在 ImageView 上：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onClick(View v) {
</span><span class='line'>    new Thread(new Runnable() {
</span><span class='line'>        public void run() {
</span><span class='line'>            Bitmap b = loadImageFromNetwork("http://example.com/image.png");
</span><span class='line'>            mImageView.setImageBitmap(b);
</span><span class='line'>        }
</span><span class='line'>    }).start();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但上面的代码并没有遵守第二条规则：不要在非 UI 线程上操作 UI。</p>

<p>Android 提供了几种方法支持从工作线程中访问 UI 线程：<br/>
（1）Activity.runOnUiThread(Runnable)<br/>
（2）View.post(Runnable)<br/>
（3）View.postDelayed(Runnable, long)</p>

<p>于是，上面的代码可以修改为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onClick(View v) {
</span><span class='line'>    new Thread(new Runnable() {
</span><span class='line'>        public void run() {
</span><span class='line'>            final Bitmap bitmap = loadImageFromNetwork("http://example.com/image.png");
</span><span class='line'>            mImageView.post(new Runnable() {
</span><span class='line'>                public void run() {
</span><span class='line'>                    mImageView.setImageBitmap(bitmap);
</span><span class='line'>                }
</span><span class='line'>            });
</span><span class='line'>        }
</span><span class='line'>    }).start();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>修改之后的代码就保证线程安全了。</p>

<p>可是，随着这种跨线程 UI 操作的增多，代码会变得复杂和难于维护，为了在工作线程中能够处理更复杂的交互，你可以使用 Hanlder，将 UI 操作都放到 Handler 中执行。不过，AsyncTask 也许是更好的解决方案。</p>

<h3>Using AsyncTask</h3>

<p>AsyncTask 允许你在界面中执行异步工作，它将阻塞操作放在工作线程上运行，并将结果发送到 UI 线程上，这样就避免了你直接去使用线程和 Handler。</p>

<p>要使用 AsyncTask，你需要从 AsyncTask 类派生一个子类，并实现 doInBackground() 方法，这个方法运行在线程池中。如果要更新 UI，你还需要实现 onPostExecute() 方法，这个方法接收来自 doInBackground() 的返回，以及运行在 UI 线程上。</p>

<p>例如，你可以这样实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void onClick(View v) {
</span><span class='line'>    new DownloadImageTask().execute("http://example.com/image.png");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private class DownloadImageTask extends AsyncTask&lt;String, Void, Bitmap&gt; {
</span><span class='line'>    /** The system calls this to perform work in a worker thread and
</span><span class='line'>      * delivers it the parameters given to AsyncTask.execute() */
</span><span class='line'>    protected Bitmap doInBackground(String... urls) {
</span><span class='line'>        return loadImageFromNetwork(urls[0]);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    /** The system calls this to perform work in the UI thread and delivers
</span><span class='line'>      * the result from doInBackground() */
</span><span class='line'>    protected void onPostExecute(Bitmap result) {
</span><span class='line'>        mImageView.setImageBitmap(result);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在，UI 操作安全了，代码也比较简洁，因为它将后台操作与前台 UI 操作分开了。</p>

<p>注意：在你使用工作线程的时候可能会遇到另一个问题，就是当前的 Activity 会因为配置的改变而重建（如改变屏幕方向），以致销毁了工作线程。要解决这个问题，可参考 Shelves 源码。</p>

<h3>Thread-safe methods</h3>

<p>某些情况下，你的方法需要被多个线程调用，因此要确保这些方法是线程安全的。</p>

<h2>3. Interprocess Communication</h2>

<p>Android 使用远程过程调用（RPC）的方式来实现进程间通信（IPC），即在 Activity 或其它应用组件中调用方法，在远程（其它进程）执行方法，并将结果返回给调用者。这种过程的实现，需要将方法调用和附带的数据解析到系统可以识别的类型，将它们从本地进程和地址空间传输到远程目标进程和地址空间，然后重新组装并执行调用，返回值会按相反的方向传输回去。Android 已经提供了这种 RPC 通信过程的实现，你只需要定义和实现远程调用接口即可。</p>

<p>另外，要实现 IPC，你的应用必须使用 bindService() 绑定到一个（其它进程的） Service。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于个人知识/兴趣的看法]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/18/about-personal-knowledge-and-interest/"/>
    <updated>2014-08-18T18:59:25+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/18/about-personal-knowledge-and-interest</id>
    <content type="html"><![CDATA[<p>今天读到国内知名 Android 开发者 Trinea 的一篇博客：
<a href="http://www.trinea.cn/plan-summary/self-blog-why-what-target/">写在前面, 自己搭博客why and target</a>。从其中一张图可以看出作者的知识/兴趣面：</p>

<p><img src="http://xuanxi.github.io/images/Trinea.jpg" alt="Trinea" /></p>

<p>这跟我的个人规划比较接近，于是也尝试总结一下：</p>

<!--more-->


<p>五年的工作经历，使我慢慢意识到不要把全部精力放在技术上。从一个产品的角度来说，包含前期调研（用户、市场）、需求、UI、开发测试、推广、运营等，如果只了解和参与技术工作的话就未免被局限住了，所以我会利用一定空余时间去了解技术之外的产品相关的知识和经验，事实证明是无比正确的选择：）。当然，也有人会说“我就只对技术感兴趣”、“我的职业规划就是开发”，这是个人发展方向的问题了，并无对错之分。</p>

<p>学习工作技能之余，补充一些其它领域的知识对个人成长也大有好处，比如作者就提到了经济学、心理学和文学，而我为自己规划的是经济学、心理学和历史。经济学让人明白社会的运行规律，心理学可以开发心智，文学可以提高素养，历史可以明智，这些知识的作用也只有认真去学的人才能体会到。我也建议正在念大学的弟妹们多读这几方面的书以扩大视野。另外再说一下历史，因为最近一段时间在看，就我的感受而言，主要是两点：历史在团队建设、企业管理方面有很多值得借鉴的地方；让我对社会有更理性成熟的认识，有助于在社会上走好每一步。顺便提一句，关于中国现代史，最好还是阅读墙外的资料吧，原因你懂的。</p>

<p>图中还提到作者喜欢旅行。我想，作为一个放松身心、体验生活的好事情，旅行是值得大家去做的，尤其对于我们这些长期跟计算机打交道，一坐10个小时的程序猿们。即使真腾不出时间出门，也应该在平时多找机会让自己可以放松精神和身体，比如做简单的体操动作，听听音乐，补充维生素等。前几天在微信朋友圈上总结自己工作五年最大的体会，毫不犹豫地写了“身体是革命的本钱”，希望大家不但有好的工作成绩，更有好的身体：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio vs Eclipse: What Are the Main Differences?]]></title>
    <link href="http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences/"/>
    <updated>2014-08-07T14:09:55+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/08/07/android-studio-vs-eclipse-main-differences</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/">http://www.avocarrot.com/blog/android-studio-vs-eclipse-main-differences/</a></p>

<p><img src="http://xuanxi.github.io/images/androidstudio.png" alt="androidstudio" /></p>

<!--more-->


<p>Most of Google’s 2013 I/O event was about Android. One specific announcement managed to attract a lot of hype and that was no other than Google’s own Android IDE, Android Studio. It has been just over a year now since the first public release and Android Studio has come a long way, despite still being in beta. The IDE itself is based off the very popular IntelliJ IDEA from JetBrains and is being offered by Google for free.</p>

<p>Google 2013 I/O 大会的大部分内容是与 Android 相关，其中，专为 Android 打造的开发环境——Android Studio 无疑最引人注目。Android Studio 从公开第一个版本至今已经走过一个年头，尽管仍然处于 beta 版本（公开测试版），但相比一年前，Google 已经对其做了相当多的改进。Android Studio 基于非常著名的 JetBrains 公司的产品——IntelliJ IDEA，并免费提供给开发者。</p>

<p>On the other hand, Eclipse is more mature than ever and Google’s ADT plugin which transforms the popular IDE into a fully featured Android developing environment has become very stable. Eclipse feels like home for many Java developers and is a natural starting point for Java developers who want to get into Android development.</p>

<p>另一方面，基于 Google ADT 插件的 Eclipse 现在已经成为 Android 开发的一个非常成熟稳定的环境，作为要进入 Android 开发领域的 Java 开发人员，Eclipse 是一个自然而然的选择。</p>

<p>While both solutions look promising, which one has the edge over the other? In this blog we will compare the two in 5 distinct areas in an effort to reveal the main differences in the Android Studio vs Eclipse battle.</p>

<p>两个开发环境看起来都有不错的前景，那么哪个更具优势呢？本文试图从5个方面分析它们的不同。</p>

<h3>Build Tools</h3>

<p>Android Studio utilizes the fast growing Gradle build system. It builds on top of the concepts of Apache Ant and Apache Maven but it also introduces a Groovy DSL (Domain-Specific Language) that allows for scripted builds which opens up many automation possibilities like uploading your beta .apk to TestFlight for testing. Eclipse on the other hand uses Apache Ant as its main build system which a very robust XML based build system that many Java developers may already be familiar with.</p>

<p>Android Studio 使用了当前发展迅猛的 Gradle 构建系统，它基于 Groovy 脚本语言，可以实现比 Ant 和 Maven 更灵活的构建过程，如自动上传测试包。而 Eclipse 使用成熟健壮的 Ant 作为构建系统。</p>

<h3>Advanced Code Completion/Refactoring</h3>

<p>Both IDEs feature the standard Java code auto completion but in the case of Android Studio, Google has baked in deeper support for specific Android code and refactoring. Android Studio can refactor your code in places where it’s just not possible using Eclipse and ADT. In addition, in my opinion IntelliJ’s Java auto completion seems more “intelligent” and predicts better what I want to do so there is definitely an improvement in this area over Eclipse.</p>

<p>两个 IDE 都提供了代码补全和重构功能，不过，Android Studio 在对 Android 代码的补全和重构方面做了更好的支持。另外，我认为 IntelliJ 的 Java 代码补全更加智能，预判准确率更高，这个相比 Eclipse 无疑是一个进步。</p>

<h3>User Interface Design</h3>

<p>One of the main selling point Google used to market Android Studio when it came out was its completely redesigned user interface design tool. After working with it for some time, it’s clear that the new tool is much better than the old. It literally crashes it. The new interface design tool in Android Studio is faster, responds to changes more rapidly and has more customization options that with Eclipse, you had to manually set in the XML.</p>

<p>用户界面设计工具是 Android Studio 的一个主要卖点。比起 ADT，Android Studio 上的设计工具更快、更灵活，比如在 Android Studio 的设计面板上可以直接设置元素属性，而在 Eclipse 上只能手动修改 XML 文件。</p>

<h3>Project Organization</h3>

<p>Both IDEs work differently in an effort to help you manage and organize your projects. If you’ve used Eclipse then you must be familiar with the concept of workspaces. When Eclipse starts, you select the workspace that contains your projects and you can load all project of that workspace in your tree navigation. If you want to switch to a project in a different workspace, then you have to restart the whole IDE. Android Studio treats this situation differently by introducing the concept of modules. Your app could be one module, a library that you just downloaded can be another and the Ad SDK you are currently integrating could be a third. Each of these modules can have their own Gradle build files and declare their own dependencies. To me, Android Studio seems more natural but it takes some time to get used to if you have been using Eclipse for a long time.</p>

<p>两个 IDE 在工程组织上各不相同。Eclipse 使用 workspace &ndash; project 的结构，Android Studio 使用 project &ndash; module 的结构，我更偏向 Android Studio 的组织方式。（从表面上看，貌似也没多大差别啊）</p>

<h3>IDE Performance/Stability</h3>

<p>Eclipse is a purely Java based software, and a big one. In order to run it reliably you need to have more than decent amount of RAM and good CPU power to back it up. Many user who do not strictly meet these criteria are reporting very bad experiences with it. It is not unusual for Eclipse to crash while exporting an apk or having to restart it after using it for a few hours straight. Having said that, Android Studio is still in beta so it comes with its own bugs that crash the IDE every now and then but in the meanwhile, the whole experience feels faster and more robust.</p>

<p>Eclipse 是一个使用纯 Java 语言编写的程序，由于它是基于可扩展的设计思想，即通过各种插件来提供特定开发环境，所以本身体积较大，运行时需要较多的内存和 CPU 资源，你可能会遇到这样的情况：打包 apk 时程序崩溃了，或者运行几个小时后因为响应太慢而不得不重启。对于 Android Studio ，上面已经提到它仍然处于 beta 阶段，会偶尔崩溃，不过，现时它的整体体验已经相对更快和更稳定。</p>

<h3>Conclusion</h3>

<p>Having used both Android Studio and Eclipse for a while now, I would personally say that Android Studio has the edge over the two. It might be a bit unstable yet and some updates require a complete re-installation of the software but when it eventually comes out of beta, it will blow Eclipse with ADT out of the water. I especially like the stability of the editor and not having to reboot every now and then, the new and improved UI designer and the sexy themes that make Android Studio a real eye candy. What side will you take in the Android Studio vs Eclipse battle?</p>

<p>我同时使用 Android Studio 和 Eclipse 已有一段时间，我个人认为 Android Studio 更具优势，虽然存在不稳定性，以及升级可能需要重装，但就在 beta 版发布之后，它完全可以击败 Eclipse。我尤其喜欢它的编辑器的稳定、无需重启、增强的界面设计和性感的外观。</p>

<h2>我的看法</h2>

<p>和本文作者一样，我也同时使用这两个 IDE 一段时间了（公司用 Eclipse，个人用 Android Studio），并同样感受到 Android Studio 的明显优势：<br/>
1. 快，无论是启动程序，还是打开 XML 文件，都可以明显看出两个 IDE 的速度差别；<br/>
2. 酷，那个 Darcula 的外观实在比 Eclipse 呆板的外观好看得多（Eclipse 中可使用 color theme 来美化外观，但个人觉得也比不上 Android Studio）。<br/>
对于重构和新的界面设计工具，我的使用经验还不多，这里就不作评论了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style (2)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/29/android-style-2/"/>
    <updated>2014-07-29T09:56:06+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/29/android-style-2</id>
    <content type="html"><![CDATA[<p>本篇包括以下内容：<br/>
6. Color<br/>
7. Iconography<br/>
8. Your Branding<br/>
9. Writing Style</p>

<!--more-->


<h2>6. Color</h2>

<h2>7. Iconography</h2>

<p><img src="http://xuanxi.github.io/images/iconography_overview.png" alt="iconography_overview" /></p>

<p>图标就是⼀个直观的图形，占据屏幕一个小空间，用来代表⼀个操作、⼀种状态或者⼀个应用本身。</p>

<p>当你为应用设计图标时，需要紧记的是你的应用可能会被安装到多种分辨率的设备中。不过，你可以通过提供不同大小的图标来适配各种密度的设备。</p>

<p>因为你要提供多种规格图标来适配多种密度，下文中提到的图标尺寸都用 dp 为单位。dp 是以 MDPI 中的像素为基准的，即在 MDPI 中 1dp=1px，在 HDPI 中 1dp=1.5px，在 XHDPI 中 1dp=2px，如下图所示：</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<p>这样，当你设计图标的时候，应该按照  2:3:4:6:8（或者 1:1.5:2:3:4） 的比例去缩放。例如，一个应用启动图标的规格为 48x48 dp，意味着 MDPI 的大小是 48x48 px，HDPI 的大小是 72x72 px，以此类推。</p>

<p>注意：Android 也支持一种更小的屏幕密度 LDPI，不过通常不需要考虑这种密度，因为 Android 会将 HDPI 中的图标缩小一半来适配它。<br/>
补充：在要求不太严格的情况下，我们可以只为高密度屏幕设计一套图标，比如 XHDPI，Android 会自动缩小尺寸适配所有密度屏幕。</p>

<h3>Launcher</h3>

<p>启动图标</p>

<p>启动图标用在 Home 界面和 All Apps 界面。因为用户可以改变 Home 的背景，所以要考虑启动图标是否能够在任何类型的背景中都清晰可见。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_size.png" alt="iconography_launcher_size" /></p>

<p>Sizes &amp; scale <br/>
1. 启动图标在移动设备中必须为 48x48 dp；<br/>
2. 启动图标在 Google Play 中必须为 512x512 pixels。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_focal.png" alt="iconography_launcher_focal" /></p>

<p>Proportions<br/>
图标不要留白，要占满 48x48 dp 大小。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_style.png" alt="iconography_launcher_style" /></p>

<p>Style<br/>
Use a distinct silhouette. Three-dimensional, front view, with a slight perspective as if viewed from above, so that users perceive some depth.<br/>
使用清晰的轮廓。三维的正面视图，看起来稍微有点从上往下的俯视效果，使用户能看到⼀些景深。</p>

<p><img src="http://xuanxi.github.io/images/iconography_launcher_example2.png" alt="iconography_launcher_example2" /></p>

<h3>Action Bar</h3>

<p>操作栏图标是⼀个图形按钮，用来表示用户在应用中可以执行的重要操作。使用简洁明了的图像代表将要执行的操作，让用户⼀目了然。</p>

<p>Android 内置了一些通用操作的图标供使用，例如“刷新”和“分享”。下面提供了图标包的下载链接，其中包括多种屏幕分辨率，以及对应 Holo Light和 Holo Dark 主题的图标。包中带有尚未样式化的图标，同时提供 Adobe® Illustrator® 源文件，你可以自由修改以搭配自⼰的主题。</p>

<p><a href="http://developer.android.com/downloads/design/Android_Design_Icons_20131106.zip">Download the Action Bar Icon Pack</a></p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_size.png" alt="iconography_actionbar_size" /></p>

<p>Sizes &amp; scale<br/>
Action bar icons for phones should be 32x32 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_focal.png" alt="iconography_actionbar_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset 整体大小, 32x32 dp<br/>
Optical square 实际内容, 24x24 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_style.png" alt="iconography_actionbar_style" /></p>

<p>Style<br/>
Pictographic, flat, not too detailed, with smooth curves or sharp shapes. If the graphic is thin, rotate it 45° left or right to fill the focal space. The thickness of the strokes and negative spaces should be a minimum of 2 dp.<br/>
形象化，扁平，不要⼩细节，使用平滑曲线或尖锐的轮廓。如果是瘦长型的图形，将它转45度角再填满内容区。线的宽度不应低于2 dp。</p>

<p><img src="http://xuanxi.github.io/images/iconography_actionbar_colors.png" alt="iconography_actionbar_colors" /></p>

<p>Colors for Light<br/>
Colors: #333333<br/>
Enabled: 60% opacity<br/>
Disabled: 30% opacity</p>

<p>Colors for Dark<br/>
Colors: #FFFFFF<br/>
Enabled: 80% opacity<br/>
Disabled: 30% opacity</p>

<h3>Small / Contextual Icons</h3>

<p>小图标与上下文图标</p>

<p>在应用的主体区域中，使用⼩图标表示操作或者特定对象的状态。例如在 Gmail 应用中，每条信息都有⼀个星型图标用来标记“重要”。</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_size.png" alt="iconography_small_size" /></p>

<p>Sizes &amp; scale<br/>
Small icons should be 16x16 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_focal.png" alt="iconography_small_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 16x16 dp<br/>
Optical square, 12x12 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_style.png" alt="iconography_small_style" /></p>

<p>Style<br/>
Neutral, flat, and simple. Filled shapes are easier to see than thin strokes. Use a single visual metaphor so that a user can easily recognize and understand its purpose.<br/>
灰色为主、扁平和简单。最好使用填充图标而不是细线条勾勒。使用简单直观的图形，让用户容易理解图标的作用。</p>

<p><img src="http://xuanxi.github.io/images/iconography_small_colors.png" alt="iconography_small_colors" /></p>

<p><img src="http://xuanxi.github.io/images/iconography_small_example.png" alt="iconography_small_example" /></p>

<p>Colors<br/>
在特殊情况下使用非灰色的图标。例如在 Gmail 应用中，使用了黄色的星型图标表示重要的信息。如果图标是可点击的，使用和背景形成对比的颜色。</p>

<h3>Notification Icons</h3>

<p>通知图标</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_size.png" alt="iconography_notification_size" /></p>

<p>Sizes &amp; scale<br/>
Notification icons must be 24x24 dp.</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_focal.png" alt="iconography_notification_focal" /></p>

<p>Focal area &amp; proportions<br/>
Full asset, 24x24 dp<br/>
Optical square, 22x22 dp</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_style.png" alt="iconography_notification_style" /></p>

<p>Style<br/>
Keep the style flat and simple, using the same single, visual metaphor as your launcher icon.<br/>
扁平，简单，类似启动图标。</p>

<p><img src="http://xuanxi.github.io/images/iconography_notification_example.png" alt="iconography_notification_example" /></p>

<p>Colors<br/>
Notification icons must be entirely white. Also, the system may scale down and/or darken the icons.<br/>
通知图标必须为纯白色，另外，系统会缩小图标或令图标变暗。</p>

<h3>Design Tips</h3>

<p>下面是一些图标设计建议，这些建议假设你使用 Photoshop 或者其它栅格或矢量图形工具。</p>

<h4>Use vector shapes where possible</h4>

<p>尽量使用矢量图</p>

<h4>Start with large artboards</h4>

<p>从大画板开始设计</p>

<h4>When scaling, redraw bitmap layers as needed</h4>

<p>？？</p>

<h4>Use common naming conventions for icon assets</h4>

<p> 使用统一的命名方法，使得所有图标在文件夹中会聚在一起并按字母顺序排列，如下图：</p>

<p><img src="http://xuanxi.github.io/images/icon_common_naming.png" alt="icon_common_naming" /></p>

<h4>Set up a working space that organizes files by density</h4>

<p>为不同密度图标建立对应文件夹：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>art/...
</span><span class='line'>    mdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png
</span><span class='line'>    hdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png
</span><span class='line'>    xhdpi/...
</span><span class='line'>        _pre_production/...
</span><span class='line'>            working_file.psd
</span><span class='line'>        finished_asset.png</span></code></pre></td></tr></table></div></figure>


<h4>Remove unnecessary metadata from final assets</h4>

<p>尽管 Android 在打包时会自动压缩 png 图片，但图片中仍然包含着不必要的头部信息和 metadata，你应该把这些信息也删除掉。可以使用以下两个工具：<br/>
<a href="http://optipng.sourceforge.net/">OptiPNG</a><br/>
<a href="http://pmt.sourceforge.net/pngcrush/">Pngcrush</a>。</p>

<h2>8. Your Branding</h2>

<p>你的品牌</p>

<p>遵循 Android 的设计模式并不意味着你的应用和其它应用没什么区别，相反，你的应用可以表现出你的品牌的特点。</p>

<h3>Color</h3>

<p>品牌颜色</p>

<p>用你的品牌颜色取代 Android 默认的蓝色，新的颜色将会体现在复选框、进度条、单选按钮、滑动条、tab 按钮、滑动指示等常用控件上。</p>

<p>在合适的地方用高对比度的颜色来作强调，比如 action bar 的背景颜色或者一个主要的按钮。记住不要过度使用这种颜色，因为不是所有操作都同等重要，所以只能用在一到两个最重要的地方。</p>

<p>在自定义颜色的时候，记得对触摸反馈也做出轻微调整——比原始状态稍亮或稍暗，具体可参考 “3.Touch Feedback”。</p>

<p><img src="http://xuanxi.github.io/images/branding_wallet.png" alt="branding_wallet" /></p>

<p>The four colors of the Google Wallet logo provide a playful accent to the four dots that appear as the user enters a PIN.</p>

<p><img src="http://xuanxi.github.io/images/branding_googlemusic.png" alt="branding_googlemusic" /></p>

<p>The Google Play Music app has an orange theme color, which is used for emphasis in the action bar and for accent in the selected tab, scroll indicator, and hyperlinks.</p>

<h3>Logo</h3>

<p>品牌 logo</p>

<p>首先要明确的是，启动图标（launcher icon）不等于 logo，启动图标只是基于 logo 设计的图标。不过，启动图标是一个展示品牌 logo 的关键，因为用户要寻找它并通过它来启动应用。直接把启动图标放在 action bar 上就可以达到展示品牌的目的。</p>

<p>另一方法是将 logo 放在 action bar 上，而不是使用启动图标和应用名字。</p>

<p><img src="http://xuanxi.github.io/images/branding_launcher_icon.png" alt="branding_launcher_icon" /></p>

<p><img src="http://xuanxi.github.io/images/branding_logo_icon_action_bar.png" alt="branding_logo_icon_action_bar" /></p>

<p>Google+ 直接把启动图标放在 action bar 上。</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_app.png" alt="yourbranding_app" /></p>

<p>将 logo 放在 action bar 上的例子。</p>

<h3>Icons</h3>

<p>品牌图标</p>

<p>如果你在其它平台的 app 上有符合你的品牌要求的图标，也可以用到 Android 上来，但要确保品牌与这些图标的风格一致。</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_in-app-icons.png" alt="yourbranding_in-app-icons" /></p>

<p>One exception: For any icon in your existing set where the symbol is different from Android&rsquo;s, use Android&rsquo;s symbol but give it your brand&rsquo;s styling. That way, users will understand what the purpose of the icon is based on what they&rsquo;ve learned in other Android apps (Design principle: Give me tricks that work everywhere). But the icon will still look like it belongs with all of your other icons as a part of your brand.</p>

<p>Example:<br/>
The brand&rsquo;s normal icon for sharing on other platforms is a right arrow.</p>

<p><img src="http://xuanxi.github.io/images/yourbranding_sharing.png" alt="yourbranding_sharing" /></p>

<p>如果你没有自己的图标，并且只创建 Android 应用，这样的话，可以使用 Android 提供的标准图标，而通过颜色和 logo 来展示你的品牌。（对设计能力不足的小团队可以这样做）</p>

<h2>9. Writing Style</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不要因为学太多而压垮自己]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/25/dont-overwhelm-trying-learn-much/"/>
    <updated>2014-07-25T11:16:38+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/25/dont-overwhelm-trying-learn-much</id>
    <content type="html"><![CDATA[<p><a href="http://simpleprogrammer.com/2014/06/23/dont-overwhelm-trying-learn-much/"><em>Don’t Overwhelm Yourself Trying to Learn Too Much</em></a> 一文是作者 John Sonmez 对学习新技术的看法，我对此也深有体会，以下为摘录和笔记。</p>

<!--more-->


<p>参考译文：<br/>
<a href="http://blog.jobbole.com/73648/">http://blog.jobbole.com/73648/</a></p>

<h4>作者首先提出软件开发领域中遇到的困扰：</h4>

<p><em>But, in the software development field, sometimes there are so many new technologies, so many things to learn, that we can start to feel overwhelmed and like all we ever do is learn.<br/>
在软件开发领域，有如此多的新技术，有如此多要学习的东西，以致我们感觉快要崩溃。</em></p>

<p><em>You can start to feel like you are always playing catch-up, but never actually getting ahead–not even keeping up. The treadmill is going just a few paces faster than you can run, and you are slowly losing ground, threatening to drop off the end at any time.<br/>
你感觉你一直在扮演追赶的角色，却一直都赶不上，甚至无法坚持下去。就像是跑步机一直比你能跑的最快速度还要快几步，你一直受挫，还有在最后关头掉队的危险。</em></p>

<h4>然后结合自己的亲身经历指出问题所在——学习量太大：</h4>

<p><em>The problem is trying to learn too much. There are 100 different technologies you have to work with or want to work with at your job. You might feel that in order to be competent, in order to be the best you can be, you need to learn and master all of them. The problem though, is that you feel like you haven’t even mastered one of them.<br/>
问题就是尝试学太多导致的。有100种不同的技术，这些都是你必须或想要在工作中应用的。你感觉为了能够胜任，为了做到最好，你需要学习和精通所有的这些技术。然而问题是，你感觉你其实一个都不精通。</em></p>

<p><em>You spend your nights and weekends reading books, going through online training, and reading blog posts.But. is it really effective, or does it just stress you out more?Do you even remember half of what you read?<br/>
你把晚上和周末的时间都用来读书，进行在线训练并且读一些博客。<br/>
但是，这样是真的有效，还是让你承受了太大的压力？<br/>
你能记得你读的一半内容吗？</em></p>

<h4>解决办法：Just-in-time learning</h4>

<p><em>Instead, I think the best way to improve your skills and to learn what you need to do is to do the learning as close to the time you need the information as possible–just-in-time learning.<br/>
我认为提高技能的最好方法是：在你的确需要用到这方面知识的时候才去学习。</em></p>

<p><em>Now, this doesn’t mean that you should just start working with a technology before you know anything about it. You’ll waste a lot of time flopping around trying to get started if you just dive right in without any prior knowledge. But, I’ve found you only need to learn three things before you can dive in and start working with a technology:<br/>
How to get started<br/>
What you can do with the technology–how big it is.<br/>
The basics–the most common things you’ll do 90% of the time.<br/>
接下来，这不意味着在了解一门技术前就开始相关的工作。如果你对要使用的技术一无所知，你会在开始阶段就浪费大量时间。但是，我发现只要先了解关于这门技术的三件事，你就能够开始使用它去工作了。<br/>
1. 这门技术应该如何起步<br/>
2. 这门技术可以做什么<br/>
3. 这门技术最基础的知识，即90%的时间里都会用到的东西</em></p>

<p><em>It is no coincidence that I structure most of my online courses in that way. I try to tell you how to get started, show you what is possible and then give you the very basics. I try to avoid going into details about every little aspect of a technology, because you are better off learning that information when you need it. As long as you know what you can do, you can always find out how later.<br/>
这并非巧合，我大部分的在线课程都是这样的结构。我试着告诉你如何起步，展示它能做的，并且告诉你一些基础。我试着避免深入技术各个方面的细节，因为这些东西最好是你需要它们的时候再去学习比较好。只要你知道了如何做，具体的细节可以以后再学习。</em></p>

<p><em>Often the hardest part of learning a new technology is learning what is possible.<br/>
通常，学一门新技术最难的地方是学习它能实现什么。</em></p>

<p><em>I’ve found that the faster you start actually using a technology and trying to solve real problems with it the better. Once you’ve covered the three bases I’ve mentioned above, your time is much better spent actually working with the technology rather than learning about it further.<br/>
我发现，越快在实际中应用一项技术并且解决实际的问题，越能够有提高。只要你做到了以上我提到的三点，能让你的时间更好的花在用技术解决工作中的问题而不是仅仅学习技术本身。</em></p>

<h4>新问题：You can’t know everything</h4>

<p><em>Even if you had all the time in the world to learn, and even if you apply just-in-time learning techniques, you still won’t ever learn a fraction of what there is to learn in the software development field. New technologies are popping up every day and the depth of existing ones increases at an alarming rate.<br/>
即使你有足够的时间学习，即使你运用 just-in-time learning，你仍然只会学到软件开发领域的一点点。新技术每天都在出现，现有的技术也在不断发展。</em></p>

<h4>解决办法：Specializing and General Knowledge</h4>

<p><em>It is important to face the reality that you just can’t know it all. Not only can you not know it all, but what you can know is just a tiny fraction of what there is to know.<br/>
意识到你不可能把所有的东西都学会是很重要的。你不可能全部学会，而你知道的可能只是现有技术的一小部分。</em></p>

<p><em>This is one of the main reasons why I talk about specializing so much. You are much better off picking a single technology that you can focus on learning in-depth than spreading yourself too thin trying to be a master at everything.<br/>
这是我谈到专门钻研某一方面的原因之一。你最好能选一门技术，并且深入钻研它而不是所有的技术都想要精通。</em></p>

<p><em>That doesn’t mean you shouldn’t expand your skills in many different directions; you should definitely try to have a broad base. Just don’t expect to be an expert in more than one or two main areas of focus. <br/>
这不意味着你不应该在不同的方向上扩展你的技术，相反，你当然应该尝试不同的东西，但不要觉得你能在好几个领域内都能够精通。</em></p>

<p><em>A single specialty that you will master<br/>
General software development skills that will apply to more than one technology. (For example, a book like Code Complete falls in this category.)<br/>
尝试让你的学习集中在以下两个方面：<br/>
1. 一个你要精通的特长<br/>
2. 在软件开发领域里通用的技术（如《代码大全》）</em></p>

<p><em>Don’t try and spread yourself too thin. Rely on your ability to learn things as you need them. If you have a solid base, with time and experience, you’ll find that you can learn whatever you need to know when you need to know it. Trust yourself.<br/>
不要去让自己的精力太分散。在你需要的时候根据自己的能力进行学习。如果你基础很好，依靠时间和经验，你能学会任何你需要用到的技术。</em></p>

<h4>Super-programmer ??</h4>

<p><em>Sometimes it can seem like there are super-programmers out there who seem to know everything and can do everything, but it is only an illusion. Those super-programmers are usually programmers that have one or two areas of expertise and a large amount of general knowledge that they apply to a variety of different domains.<br/>
有时候，一些超级程序员看起来什么都知道，并且什么都能做，但这只是幻觉。这些超级程序员通常是在一两个领域内非常精通，并且了解大量在很多领域里通用的知识。</em></p>

<hr />

<h3>关于自己</h3>

<p>之所以对 John Sonmez 的看法深有体会，是因为我也曾经犯过 Learning Too Much 的错误。在大学以及刚开始工作的时候，因为兴趣和工作需要我接触过各类技术：<br/>
游戏开发相关的C/C++/Lua/DirectX/OpenGL/OpenSceneGraph/OGRE；<br/>
移动开发相关的Java/Objective-C/Android/iOS/Symbian；<br/>
服务端开发相关的Struts/Spring/Hibernate/MySQL/Orecal/JavaScript/VMware；<br/>
桌面开发相关的MFC/.NET；<br/>
等等。</p>

<p>现在看来，其实并没有对任何一种技术有深入一点的掌握，反而长时间不使用的话就会忘得一干二净，更严重的是浪费了不少资源，包括时间和金钱。</p>

<p>后悔之余，现在要做的就是为自己选定一个方向。就如 John Sonmez 所说的，要将精力放在特长和通用技术上：<br/>
1. 移动开发：Android 为主，iOS 为辅，并适量掌握一些后端技术；<br/>
2. 通用技术：操作系统、算法等。</p>

<p>最后推荐一个非常实用的站点：<br/>
<a href="http://www.bento.io/">http://www.bento.io/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Styles and Themes]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/24/styles-and-themes/"/>
    <updated>2014-07-24T17:50:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/24/styles-and-themes</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/guide/topics/ui/themes.html">http://developer.android.com/guide/topics/ui/themes.html</a></p>

<p>一个 style 是某些属性的集合，这些属性定义了 view 或 window 的外观和格式，比如 height、padding、font color、font size、background color 等。</p>

<!--more-->


<p>与 web 设计中的 CSS 相似，Android style 的目的是设计与内容分离。例如，使用 style 的话，你可以将以下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="wrap_content"
</span><span class='line'>    android:textColor="#00FF00"
</span><span class='line'>    android:typeface="monospace"
</span><span class='line'>    android:text="@string/hello" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>替换为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    style="@style/CodeFont"
</span><span class='line'>    android:text="@string/hello" /&gt;    </span></code></pre></td></tr></table></div></figure>


<p>theme 就是一个用于 Activity 和 Application 的 style，而普通的 style 只用于单独的 view。当 style 被当做 theme 使用之后，在 Activity 或 Application 中的所有 view 都会应用该 style 的属性。例如，你可以将一个字体 style 用作一个 Activity 的 theme，然后该 Activity 里的所有文本都会使用这个字体。</p>

<h2>1. 定义 Styles</h2>

<p>要创建一组 style，首先在 res/values/ 目录下创建一个 xml 文件，文件名可自定义，通常为 styles.xml。文件的根节点为 <code>&lt;resoueces&gt;</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="utf-8"?&gt;
</span><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt;
</span><span class='line'>        &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
</span><span class='line'>        &lt;item name="android:typeface"&gt;monospace&lt;/item&gt;
</span><span class='line'>    &lt;/style&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<p>每个 <code>&lt;resources&gt;</code> 元素的子节点在编译时都被转换为一个应用程序资源对象，其可以通过 <code>&lt;style&gt;</code> 元素的 <code>name</code> 属性的值来引用，如 <code>style="@style/CodeFont"</code>。</p>

<p><code>&lt;style&gt;</code> 中的 parent 属性是可选的，用来指定另外一个 style 的资源ID，前者继承后者的所有属性。你也可以覆写继承来的 style 属性。</p>

<p>用在 Activity 或应用程序上的 theme 的定义方式和 style 的定义方式是相同的。一个如同上面那样例子中定义的 style 既可以用作一个 View的 style，也可以用作一个 Activity 或应用程序的 theme。</p>

<h3>继承</h3>

<p>parent 属性让你可以继承一个 style，然后定义你想改变或添加的属性。你可以从自定义的 style 或者平台的 style 中继承：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="GreenText" parent="@android:style/TextAppearance"&gt;
</span><span class='line'>    &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>如果你要继承自定义的 style，不必用到 parent，仅需要把父 style 名字作为新 style 名字的前缀即可，中间用点分隔：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="CodeFont.Red"&gt;
</span><span class='line'>    &lt;item name="android:textColor"&gt;#FF0000&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>上面的 style 使用 <code>@style/CodeFont.Red</code> 来引用。也可以多次继承：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="CodeFont.Red.Big"&gt;
</span><span class='line'>    &lt;item name="android:textSize"&gt;30sp&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>要注意的是，前缀加点间隔的方法仅使用与自定义的 style，并不适用于平台内建的 style。</p>

<h3>Style 属性</h3>

<p>接下来，你需要了解在 <code>&lt;style&gt;</code> 的 <code>&lt;item&gt;</code> 元素中可以定义哪些属性值。比如你可能已经知道的 layout_width 和 textColor 等等。</p>

<p>要知道某个 view 的所有属性，最好的地方就是它的官方参考文档（比如 TextView 的 &lt;<a href="http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8">http://developer.android.com/reference/android/widget/TextView.html%EF%BC%89%EF%BC%8C%E5%9C%A8</a> XML Attributes 的地方就列出了所有支持的属性，这些属性都可以用在 style 里。</p>

<p>下面以 EditText 的 android:inputType 属性为例子，一般情况你可以在布局中直接使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;EditText
</span><span class='line'>    android:inputType="number"
</span><span class='line'>    ... /&gt;</span></code></pre></td></tr></table></div></figure>


<p>你也可以定义一个 style：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="Numbers"&gt;
</span><span class='line'>  &lt;item name="android:inputType"&gt;number&lt;/item&gt;
</span><span class='line'>  ...
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p>然后你的布局变成这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;EditText
</span><span class='line'>    style="@style/Numbers"
</span><span class='line'>    ... /&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个例子看起来是增加了工作量，但当你的 style 里包含了更多的属性，并且在多个布局中都使用到这个 style 的时候，style 的作用就会凸显。</p>

<p>要知道的是，不是所有的 View 都接受相同的 style 属性，所以你应该先查看所支持的属性。不过，如果一个 style 中包含了 View 不支持的属性，这些属性会被忽略。</p>

<p>有些属性不被任何 View 支持，只能用作 theme，比如隐藏应用标题栏，隐藏状态栏，改变窗口背景等。<a href="http://developer.android.com/reference/android/R.attr.html">R.attr</a> 中以 <code>windows</code> 起头的属性就是这样的属性。</p>

<p>注意，每一个属性要使用 <code>android:</code> 作为命名空间，比如: <code>&lt;item name="android:inputType"&gt;</code>。</p>

<h2>2. 使用自定义的 Styles 和 Themes</h2>

<p>有两种方式使用一个 style：<br/>
对一个独立的 View，添加 style 属性到你的布局的 View 元素中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;TextView
</span><span class='line'>    style="@style/CodeFont"
</span><span class='line'>    android:text="@string/hello" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>对一个 Activity 或应用，添加 <code>android:theme</code> 属性到 Android manifest 的 <code>&lt;activity&gt;</code> 或 <code>&lt;application&gt;</code> 元素中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;application android:theme="@style/CustomTheme"&gt;
</span><span class='line'>&lt;activity android:theme="@style/CustomTheme"&gt;</span></code></pre></td></tr></table></div></figure>


<h2>3. 使用系统自带的 Styles and Themes</h2>

<p>Android 平台提供了大量的 style 和 theme 供你使用。你可以在<a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 类中找到所有可用的 style，只需要用句号替换 style 名称中的下划线即可。例如，你可以通过 <code>@android:style/Theme.NoTitleBar</code> 使用 Theme_NoTitleBar theme。</p>

<p>由于 <a href="http://developer.android.com/reference/android/R.style.html">R.style</a> 文档的不完善，你可以查看源码以更深入了解这些 style 的定义情况：<br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/styles.xml">Android Styles (styles.xml)</a><br/>
<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/core/res/res/values/themes.xml">Android Themes (themes.xml)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Designing for Multiple Screens]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens/"/>
    <updated>2014-07-17T22:07:15+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/17/designing-for-multiple-screens</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/training/multiscreen/index.html">http://developer.android.com/training/multiscreen/index.html</a></p>

<p>Android 设备的多样性要求应用要适配多种屏幕尺寸，本篇包含以下三部分：<br/>
1. 支持不同尺寸（Supporting Different Screen Sizes）；<br/>
2. 支持不同密度（Supporting Different Screen Densities）；<br/>
3. 执行正确的界面流程（Implementing Adaptative UI Flows）。</p>

<!--more-->


<p>推荐文章：<br/>
<a href="http://stormzhang.github.io/android/2014/05/16/android-screen-adaptation/">Android 屏幕适配</a></p>

<h2>1. 支持不同尺寸</h2>

<p>本节将告诉你如何让应用支持不同尺寸的屏幕。</p>

<h3>使用 &ldquo;wrap_content&rdquo; and &ldquo;match_parent&rdquo;</h3>

<p>使用 wrap_content 和 match_parent 令布局自适应到不同的屏幕。</p>

<p><img src="http://xuanxi.github.io/images/layout-hvga.png" alt="layout-hvga" /><br/>
上图中的横竖两种状态时是自动适配屏幕的。</p>

<h3>使用 RelativeLayout</h3>

<p>LinearLayout 用于简单的线性布局，而 RelativeLayout 提供了更灵活的手段去布置子控件。</p>

<p><img src="http://xuanxi.github.io/images/relativelayout1.png" alt="relativelayout1" /></p>

<h3>使用 size 限定符（Size Qualifiers）</h3>

<p>一种布局自适应所有屏幕并不代表提供了最好的用户体验，还要考虑为不同大小的屏幕建立不同的布局，以充分发挥不同尺寸屏幕的各自的优势。</p>

<p>举个例子，很多应用都会有两个功能窗口，一个是列表，一个是列表项详情，对于平板或电视的大屏幕，一次就可以展示这两个窗口，而手机屏幕只能展示一个。以下示例使用了一个 layout 布局和一个 layout-large 布局，应用在运行时会根据屏幕大小读取对应的布局：</p>

<p>res/layout/main.xml, single-pane (default) layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:orientation="vertical"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"&gt;
</span><span class='line'>
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="match_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/layout-large/main.xml, two-pane layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<h3>使用最小宽度限定符（Smallest-width Qualifier）</h3>

<p>在 3.2 版本系统之前，使用 Size 限定符有一个问题会让很多程序员感到头疼，large 到底是指多大呢？很多时候5寸和7寸都被当做 large，但很多应用都希望能够更自由地为不同屏幕设备加载不同的布局，不管它们是不是被系统认定为&#8221;large&#8221;。这就是Android为什么在3.2以后引入了&#8221;Smallest-width&#8221;限定符。</p>

<p>Smallest-width 限定符允许你设定一个具体的最小值(以dp为单位)来指定屏幕。例如，7寸的平板最小宽度是600dp，所以如果你想让你的UI在这种屏幕上显示 two pane，在更小的屏幕上显示 single pane，你可以使用sw600dp来表示你想在600dp以上宽度的屏幕上使用 two pane 模式：</p>

<p>res/layout/main.xml, single-pane (default) layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:orientation="vertical"
</span><span class='line'>    android:layout_width="match_parent"
</span><span class='line'>    android:layout_height="match_parent"&gt;
</span><span class='line'>
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="match_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/layout-sw600dp/main.xml, two-pane layout:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>这意味着，那些最小屏幕宽度大于600dp的设备会选择 layout-sw600dp/main.xml(two-pane)布局，而更小屏幕的设备将会选择 layout/main.xml(single-pane)布局。</p>

<p>可是，3.2系统之前不支持 Smallest-width 限定符，你仍然需要 large 限定符去兼容那些老系统，即需要同时存在 layout-sw600dp 和 layout-large，并且里面的布局文件是一样的。可是，这样就造成重复定义布局的问题，下一节会介绍一种避免重复布局的技术。</p>

<h3>使用布局别名（Layout Aliases）</h3>

<p>Smallest-width 限定符只在 Android 3.2 及之后的系统中有效，所以，你需要同时使用 Size 限定符(small, normal, large 和 xlarge)来兼容更早的系统。例如，你想手机上显示 single-pane 界面，而在7寸平板和更大屏的设备上显示 multi-pane 界面，你需要提供以下文件：<br/>
res/layout/main.xml: single-pane 布局<br/>
res/layout-large/main.xml: multi-pane 布局<br/>
res/layout-sw600dp/main.xml: multi-pane 布局</p>

<p>最后的两个文件是完全相同的，一个用于3.2及以上系统，一个用于3.2以下系统，这明显是重复工作。Android提供别名来避免重复。例如，可以定义以下布局：<br/>
res/layout/main.xml, single-pane layout<br/>
res/layout/main_twopanes.xml, two-pane layout</p>

<p>加入以下两个 values 文件：</p>

<p>res/values-large/layout.xml:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<p>res/values-sw600dp/layout.xml:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;resources&gt;
</span><span class='line'>    &lt;item name="main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;
</span><span class='line'>&lt;/resources&gt;</span></code></pre></td></tr></table></div></figure>


<h3>使用方向限定符（Orientation Qualifiers）</h3>

<p>有些布局在横竖屏时都显示正常，但大多数情况下可以做调整以显示更好。例如，在 News Reader 示例程序中，布局在不同屏幕尺寸和不同屏幕方向中是这样显示的：<br/>
小屏幕, 竖屏: 单面板, 显示logo<br/>
小屏幕, 横屏: 单面板, 显示logo<br/>
7寸平板, 竖屏: 单面板, 显示action bar<br/>
7寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
10寸平板, 竖屏: 双面板, 窄, 显示action bar<br/>
10寸平板, 横屏: 双面板, 宽, 显示action bar<br/>
电视, 横屏: 双面板, 宽, 显示action bar</p>

<h3>使用点9图（Nine-patch Bitmaps）</h3>

<p>（略）</p>

<h2>2. 支持不同密度</h2>

<p>上一节解决了怎样让布局适配屏幕的问题，本节解决怎样让控件显示正确和让图片显示最佳的问题。Android 提供两种方式支持不同的屏幕密度：<br/>
使用 dp（Density-independent Pixels）单位； <br/>
提供对应的图片资源。</p>

<h3>使用 dp 单位</h3>

<p>Android 设备屏幕有多种密度，在布局时要避免使用像素来定义尺寸，而应该使用 dp 或 sp。<br/>
dp 是密度无关单位，在 160dpi 屏幕下，1dp=1px；<br/>
sp 与 dp 类似，是缩放比例无关单位，用于文字。</p>

<h3>提供对应的图片资源</h3>

<p>不同密度对应不用的图片：<br/>
xhdpi: 2.0<br/>
hdpi: 1.5<br/>
mdpi: 1.0 (baseline)<br/>
ldpi: 0.75</p>

<h2>3. 执行正确的界面流程</h2>

<p>上两节介绍了如何布局及配置图片资源，本节介绍如何在代码里执行对应的界面流程。</p>

<p>根据设备屏幕的不同，Android 会调用对应的布局，同时也要求代码里执行与布局对应的界面流程。例如，如果此时应用是 dual-pane 模式布局，在左边点击 item 后，右边应该直接显示内容；如果是 single-pane 模式布局，内容应该通过打开另一个 activity 显示。</p>

<h3>确定当前布局</h3>

<p>因为针对不同布局的具体实现会略有不同，所以你在处理界面之前应该首先确定当前使用的是哪个布局。例如，你需要知道当前是 dual-pane 还是 single-pane。你可以通过查询某个 view 是否存在来确定：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class NewsReaderActivity extends FragmentActivity {
</span><span class='line'>    boolean mIsDualPane;
</span><span class='line'>
</span><span class='line'>    @Override
</span><span class='line'>    public void onCreate(Bundle savedInstanceState) {
</span><span class='line'>        super.onCreate(savedInstanceState);
</span><span class='line'>        setContentView(R.layout.main_layout);
</span><span class='line'>
</span><span class='line'>        View articleView = findViewById(R.id.article);
</span><span class='line'>        mIsDualPane = articleView != null && 
</span><span class='line'>                        articleView.getVisibility() == View.VISIBLE;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以上代码查询 article 是否存在，存在的话说明是 dual-pane 模式。这种方式比直接查询调用了哪个布局更灵活简单。</p>

<p>也可以在执行动作前检查 view 是否存在：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Button catButton = (Button) findViewById(R.id.categorybutton);
</span><span class='line'>OnClickListener listener = /* create your listener here */;
</span><span class='line'>if (catButton != null) {
</span><span class='line'>    catButton.setOnClickListener(listener);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>响应当前布局</h3>

<p>确定了当前布局后，就可以根据不同的布局做出不同的响应了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Override
</span><span class='line'>public void onHeadlineSelected(int index) {
</span><span class='line'>    mArtIndex = index;
</span><span class='line'>    if (mIsDualPane) {
</span><span class='line'>        /* display article on the right pane */
</span><span class='line'>        mArticleFragment.displayArticle(mCurrentCat.getArticle(index));
</span><span class='line'>    } else {
</span><span class='line'>        /* start a separate activity */
</span><span class='line'>        Intent intent = new Intent(this, ArticleActivity.class);
</span><span class='line'>        intent.putExtra("catIndex", mCatIndex);
</span><span class='line'>        intent.putExtra("artIndex", index);
</span><span class='line'>        startActivity(intent);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>在其它 Activity 中复用 Fragment</h3>

<p>在支持多种屏幕的设计中有一种复用模式，就是把界面的一部分当做一个独立个体，这个个体在大屏幕中是一个 pane，在小屏幕中是一个 activity。这种模式可以使用 fragment 来实现。</p>

<p>例如，定义一个 ArticleFragment，大屏幕时用在 dual-pane 布局中：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
</span><span class='line'>    android:layout_width="fill_parent"
</span><span class='line'>    android:layout_height="fill_parent"
</span><span class='line'>    android:orientation="horizontal"&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/headlines"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.HeadlinesFragment"
</span><span class='line'>              android:layout_width="400dp"
</span><span class='line'>              android:layout_marginRight="10dp"/&gt;
</span><span class='line'>    &lt;fragment android:id="@+id/article"
</span><span class='line'>              android:layout_height="fill_parent"
</span><span class='line'>              android:name="com.example.android.newsreader.ArticleFragment"
</span><span class='line'>              android:layout_width="fill_parent" /&gt;
</span><span class='line'>&lt;/LinearLayout&gt;</span></code></pre></td></tr></table></div></figure>


<p>小屏幕时用在 ArticleActivity 中（无需再针对 activity 布局）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ArticleFragment frag = new ArticleFragment();
</span><span class='line'>getSupportFragmentManager().beginTransaction().add(android.R.id.content, frag).commit();</span></code></pre></td></tr></table></div></figure>


<p>在设计 fragment 时我们需要注意的一点是：不要为特定的 activity 创建强耦合的 fragment。你可以在 Fragment 里创建接口，通过接口和 activity 进行交互：
例如，HeadlinesFragment 这样设计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class HeadlinesFragment extends ListFragment {
</span><span class='line'>    ...
</span><span class='line'>    OnHeadlineSelectedListener mHeadlineSelectedListener = null;
</span><span class='line'>
</span><span class='line'>    /* Must be implemented by host activity */
</span><span class='line'>    public interface OnHeadlineSelectedListener {
</span><span class='line'>        public void onHeadlineSelected(int index);
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>
</span><span class='line'>    public void setOnHeadlineSelectedListener(OnHeadlineSelectedListener listener) {
</span><span class='line'>        mHeadlineSelectedListener = listener;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>activity 需要实现这个接口，这样，当用户点击左边 item 的时候，fragment 会通知 host activity 的 listener 进行操作，而 activity 在实现 listener 的 onHeadlineSelected 方法里面会进行当前布局的判断，从而选择合适的 UI（是显示在右边还是另起一个 activity）。下面是 fragment 响应点击事件，通知 activity 的 listener 进行实际操作的代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class HeadlinesFragment extends ListFragment {
</span><span class='line'>    ...
</span><span class='line'>    @Override
</span><span class='line'>    public void onItemClick(AdapterView&lt;?&gt; parent, 
</span><span class='line'>                            View view, int position, long id) {
</span><span class='line'>        if (null != mHeadlineSelectedListener) {
</span><span class='line'>            mHeadlineSelectedListener.onHeadlineSelected(position);
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>Handle Screen Configuration Changes</h3>

<p>略：）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Patterns (1)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-patterns-1/"/>
    <updated>2014-07-16T22:43:39+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-patterns-1</id>
    <content type="html"><![CDATA[<blockquote><p>Design apps that behave in a consistent, predictable fashion.</p></blockquote>

<p>原文：<br/>
<a href="http://developer.android.com/design/patterns/index.html">http://developer.android.com/design/patterns/index.html</a></p>

<p>本篇包括以下内容：<br/>
1. New in Android<br/>
2. Gestures<br/>
3. App Structure<br/>
4. Navigation with Back and Up<br/>
5. Action Bar</p>

<!--more-->


<h2>1. New in Android</h2>

<p>新版本系统中更新的设计风格和设计模式介绍。</p>

<h3>Android 4.4 KitKat</h3>

<h4>Your branding</h4>

<p>你的品牌</p>

<p><img src="http://xuanxi.github.io/images/branding_googlemusic.png" alt="branding_googlemusic" /></p>

<p>KitKat 更加强调应用的品牌，提供了展示品牌 logo 和品牌颜色的建议。（似乎也不是什么新特性，因为大部分应用早就这么做了）</p>

<h4>Touch feedback</h4>

<p>新的触摸反馈风格</p>

<p>在 kitKat 之前，Android 的触摸反馈颜色是明亮的蓝色。每次触摸都以高对比的颜色来响应，这可能与你的品牌颜色不搭配。</p>

<p>KitKat 之后，有了细微调整：触摸之后，默认情况下背景颜色轻微变亮或变暗。这样有两个好处：（1）sprinkles of encouragement are more pleasant than jolts；（2）更容易与品牌颜色搭配。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_reaction_response.png" alt="touch_feedback_reaction_response" /></p>

<h4>Full screen</h4>

<p>为全屏提供了更好的支持。</p>

<p><img src="http://xuanxi.github.io/images/fullscreen_landing.png" alt="fullscreen_landing" /></p>

<h4>Gestures</h4>

<p>更新两种手势：double touch drag 和 double touch。</p>

<h3>Android 4.1 Jelly Bean</h3>

<h4>Notifications</h4>

<p>4.1 版本的通知有较大增强：<br/>
1. &hellip;<br/>
2. 在大小和布局上更灵活<br/>
3. 提供优先排序<br/>
4. 可以折叠和展开<br/>
通知的基本布局不变，兼容老版本。</p>

<h4>Resizable Application Widgets</h4>

<h4>Accessibility</h4>

<h3>Android 4.0 Ice Cream Sandwich</h3>

<h4>Navigation bar</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_nav_bar.png" alt="whats_new_nav_bar" /></p>

<h4>Action bar</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_action_bar.png" alt="whats_new_action_bar" /></p>

<h4>Multi-pane layouts</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_multipanel.png" alt="whats_new_multipanel" /></p>

<h4>Selection</h4>

<p><img src="http://xuanxi.github.io/images/whats_new_multiselect.png" alt="whats_new_multiselect" /></p>

<h2>2. Gestures</h2>

<p>8种手势</p>

<p>Touch 点击<br/>
Long press 长按<br/>
Swipe or drag 轻触快速滑动或慢速拖动<br/>
Long press drag 长按拖动（Home 界面的拖动应用图标）</p>

<p><img src="http://xuanxi.github.io/images/gesture_touch.png" alt="gesture_touch" />  <img src="http://xuanxi.github.io/images/gesture_longtouch.png" alt="gesture_longtouch" />  <img src="http://xuanxi.github.io/images/gesture_swipe.png" alt="gesture_swipe" />  <img src="http://xuanxi.github.io/images/gesture_drag.png" alt="gesture_drag" /></p>

<p>Double touch 双击<br/>
Double touch drag 双击拖动（地图的缩放）<br/>
Pinch open 张指放大<br/>
Pinch close 并指缩小</p>

<p><img src="http://xuanxi.github.io/images/gesture_doubletouch.png" alt="gesture_doubletouch" />  <img src="http://xuanxi.github.io/images/gesture_doubletouchdrag.png" alt="gesture_doubletouchdrag" />  <img src="http://xuanxi.github.io/images/gesture_pinchopen.png" alt="gesture_pinchopen" />  <img src="http://xuanxi.github.io/images/gesture_pinchclose.png" alt="gesture_pinchclose" /></p>

<h2>3. App Structure</h2>

<p>应用结构</p>

<p>针对不同需求的应用有不同的界面表现形式，如 Android 官方的日历或摄像使用一个窗口即可完成大部分操作，而 Gamil 使用导航抽屉区域来切换不同的功能窗口。</p>

<hr />

<h3>不再更新：）</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Style (1)]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/16/android-style-1/"/>
    <updated>2014-07-16T22:30:21+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/16/android-style-1</id>
    <content type="html"><![CDATA[<blockquote><p>Build visually compelling apps that look great on any device.<br/>
构建在任何设备上都引人注目的应用。</p></blockquote>

<p>原文：<br/>
<a href="http://developer.android.com/design/style/index.html">http://developer.android.com/design/style/index.html</a></p>

<p>本篇包括以下内容：<br/>
1. Devices and Displays  <br/>
2. Themes  <br/>
3. Touch Feedback<br/>
4. Metrics and Grids<br/>
5. Typography</p>

<!--more-->


<h2>1. Devices and Displays</h2>

<p>设备与显示</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_main.png" alt="devices_displays_main" /></p>

<p>Android 作为一个开放的平台，支持种类繁多的设备和屏幕尺寸，因此，解决设备适配问题一直以来是应用开发中的重点工作。Android 为此提供了以下三种基本方式来实现屏幕适配。</p>

<h4>Be flexible 自适应</h4>

<p>Android 会根据不同屏幕的宽高值缩放布局。宽高值可以定义为 WRAP_CONTENT、MATCH_PARENT、FILL_PARENT（API-8以下）、dp值、px值等。</p>

<h4>Optimize layouts 布局优化</h4>

<p>针对大屏幕设备，通过设计混合 view 来展示更多的内容（如平板的一屏使用两个 fragment 来实现左边显示列表右边显示内容），以此充分利用屏幕空间。</p>

<h4>Assets for all 资源集</h4>

<p>为了让应用界面在所有屏幕上以最佳质量显示，需要根据不同密度屏幕提供不同尺寸的图片资源。目前主流手机的屏幕密度在 XHDPI左右的范围（即通常说的视网膜）。下图是屏幕密度分布：</p>

<p><img src="http://xuanxi.github.io/images/devices_displays_density@2x.png" alt="devices_displays_density@2x" /></p>

<h4>Strategies 适配策略</h4>

<p>有两种方式开始屏幕适配工作：<br/>
1. 从 normal size 和 MDPI 开始；<br/>
2. 从应用要支持的最大屏幕以及对应的 DPI 开始。<br/>
通常采用方法2，或者挑选一个主流或偏高的屏幕开始，比如 1280x768 及对应的 XHDPI，这样才能够保证多数用户的体验。MDPI 和 HDPI 设备已逐渐退出市场。</p>

<p>Developer Guide<br/>
更多关于屏幕适配的内容, read <a href="http://blog.xuanxi.me/blog/2014/07/17/designing-for-multiple-screens/">Designing for Multiple Screens</a> and <a href="http://developer.android.com/training/basics/fragments/index.html">Building a Dynamic UI with Fragments</a>.</p>

<h2>2. Themes</h2>

<p>主题</p>

<p>theme 是让应用界面风格保持一致的机制，theme 其实就是一个 style，而 style 是诸如 color、height、padding、front size 等属性值的集合。在 4.0 系统之后，Android 提供了两种 theme（Hole Light 和 Holo Dark），使用官方的 theme 可以让你的应用更好的符合 Android 设计规范。这两种 theme 如下图所示：</p>

<p>Gmail in Holo Light：<br/>
<img src="http://xuanxi.github.io/images/themes_holo_light.png" alt="themes_holo_light" /></p>

<p>Settings in Holo Dark：<br/>
<img src="http://xuanxi.github.io/images/themes_holo_dark.png" alt="themes_holo_dark" /></p>

<p>如果你希望设计一个与众不同的应用，一个好办法是在 Holo Light 或 Holo Dark 的基础上进行定制。</p>

<p>更多关于使用 theme 的信息请看 <a href="http://blog.xuanxi.me/blog/2014/07/24/styles-and-themes/">Styles and Themes</a></p>

<h2>3. Touch Feedback</h2>

<p>触摸反馈</p>

<p>使用明暗效果来响应用户的触摸（如下文的 States），对手势做出结果导向的界面行为（如下文的 Communication）。</p>

<h3>States</h3>

<p>大部分的 Android 界面元素都内置了触摸反馈效果，比如 Button。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_states.png" alt="touch_feedback_states" /></p>

<h3>Communication</h3>

<p>当你的界面能够响应更复杂的手势时，要让用户知道接下来会发生什么。<br/>
比如，在 Recents 界面，当用户向左或向右拖动一个应用缩略图时，缩略图会渐渐变暗，以此来告诉用户拖动操作会删除该应用。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_manipulation.png" alt="touch_feedback_manipulation" /></p>

<h3>Boundaries</h3>

<p>当用户在一个可滚动的区域尝试越过起始或结尾位置时，应该给予一个边界提示。Android 提供的 ListView 和 GridView 都带有这种效果。</p>

<p><img src="http://xuanxi.github.io/images/touch_feedback_communication.png" alt="touch_feedback_communication" /></p>

<h2>4. Metrics and Grids</h2>

<p>设备之间除了屏幕尺寸不同，屏幕的像素密度 (DPI) 也不一样。为了简化为不同的屏幕设计 UI 的复杂度，可以将所有的设备按照大小和像素密度如下分类。<br/>
1. 按设备大小分有两类，分别是手持设备 (小于 600 dp) 和 平板 (大于等于 600dp)；<br/>
2. 按像素密度分有 LDPI、MDPI、HDPI、XHDPI、XXHDPI 和 XXXHDPI。</p>

<p><img src="http://xuanxi.github.io/images/metrics_diagram.png" alt="metrics_diagram" /></p>

<p>dp: <code>density-independent pixels</code> 密度无关像素单位，意思是相同 dp 值在不同密度屏幕上的显示效果一样。Android 提供 dp 的目的是为了自适应屏幕。</p>

<p>更多关于市面上设备分布的信息请看
<a href="http://developer.android.com/about/dashboards/index.html">Screen Sizes and Densities Device Dashboard</a></p>

<h3>48dp Rhythm</h3>

<p>可触摸元素的尺寸通常设置在 48dp 左右的范围。</p>

<p><img src="http://xuanxi.github.io/images/metrics_48.png" alt="metrics_48" /></p>

<h4>Why 48dp?</h4>

<p>就平均而言，48dp 转化为物理上的长度是 9mm，这是手指可操作的比较适合的范围（7-10mm）。</p>

<p><img src="http://xuanxi.github.io/images/metrics_closeup.png" alt="metrics_closeup" /></p>

<h4>Mind the gaps</h4>

<p>元素间的间隔通常为 8dp。</p>

<h3>Examples</h3>

<p><img src="http://xuanxi.github.io/images/metrics_forms.png" alt="metrics_forms" /></p>

<h2>5. Typography</h2>

<p>字体</p>

<p><img src="http://xuanxi.github.io/images/typography_main.png" alt="typography_main" /></p>

<p>Android 的英文字体设计基于传统的印刷排版技术，例如字体缩放、字间距规则和对齐网格。这些技术的成功运用，让用
户可以快速理解屏幕上的信息。为此，Ice Cream Sandwich 系统引⼊了全新的 Roboto 字体，它专为高分辨率屏幕而设计。</p>

<p>TextView 控件默认支持 thin、light、regular、bold，以及对应权重的斜体。也提供了叫 Condensed 的变种版本。</p>

<p><img src="http://xuanxi.github.io/images/typography_variants@2x.png" alt="typography_variants@2x" /></p>

<h4>Default type colors</h4>

<p>Android 使用 textColorPrimary 和 textColorSecondary 作为默认颜色值。在 light 主题中使用 textColorPrimaryInverse 和 textColorSecondaryInverse。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;style name="Theme.Light"&gt;
</span><span class='line'>  &lt;item name="textColorPrimary"&gt;@android:color/primary_text_light&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorSecondary"&gt;@android:color/secondary_text_light&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorPrimaryInverse"&gt;@android:color/primary_text_dark&lt;/item&gt;
</span><span class='line'>  &lt;item name="textColorSecondaryInverse"&gt;@android:color/secondary_text_dark&lt;/item&gt;
</span><span class='line'>&lt;/style&gt;</span></code></pre></td></tr></table></div></figure>


<p><img src="http://xuanxi.github.io/images/typography_defaults.png" alt="typography_defaults" /></p>

<h4>Typographic Scale</h4>

<p>字体⼤⼩上的不同有利于创造出有序和容易理解的布局。不过，在同⼀个界面中使用过多的字体⼤⼩则会造成混乱。Android 设计框架建议使用以下⼏种字体⼤⼩：</p>

<p><img src="http://xuanxi.github.io/images/typography_sizes.png" alt="typography_sizes" /></p>

<p>sp: <code>scale-independent pixels</code> 缩放无关像素单位。</p>

<p>用户可以在<code>设置</code>中调整整个系统的字体⼤⼩。为了支持这⼀特性，字体的⼤⼩应尽量使用sp。另外，要针对支持 sp 缩放的布局做测试，即改变系统字体大小，看布局是否显示正常。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android UI Framework]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/15/android-ui-framework/"/>
    <updated>2014-07-15T21:21:41+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/15/android-ui-framework</id>
    <content type="html"><![CDATA[<p>原文：<br/>
<a href="http://developer.android.com/design/handhelds/index.html">http://developer.android.com/design/handhelds/index.html</a></p>

<p>本文针对手机和平板，其它设备点击以下链接：<br/>
1. 可穿戴设备 <a href="http://developer.android.com/design/wear/index.html">Wear</a>;<br/>
2. 电视 <a href="http://developer.android.com/design/tv/index.html">TV</a>;<br/>
3. 汽车 <a href="http://developer.android.com/design/auto/index.html">Auto</a>.</p>

<p>Android 界面框架主要分为四大部分：<br/>
1. 应用集合：Home、All Apps、and Recents；<br/>
2. System Bar：Status Bar、Navigation Bar；<br/>
3. Notifications；<br/>
4. 应用框架：Action Bar、Navigation Drawer、Content Area。</p>

<!--more-->


<h2>1. Home, All Apps, and Recents</h2>

<h3>Home screen</h3>

<p>Home 作为 Android 系统的主界面，用来放置应用快捷方式、文件夹和 Widgets（窗口部件），通过左右滑动来切换多个 Home 页面。<br/>
Home 的底部是一个特殊的托盘，固定放置最常用的应用快捷方式或文件夹。托盘中间的按钮可以打开全部应用列表。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_home_screen.png" alt="ui_overview_home_screen" /></p>

<h3>All apps screen</h3>

<p><img src="http://xuanxi.github.io/images/ui_overview_all_apps.png" alt="ui_overview_all_apps" /></p>

<h3>Recents screen</h3>

<p><img src="http://xuanxi.github.io/images/ui_overview_recents.png" alt="ui_overview_recents" /></p>

<h2>2. System Bars</h2>

<p>System Bars 包含 Status Bar 和 Navigation Bar 两部分。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_system_ui.png" alt="ui_overview_system_ui" /></p>

<h3>Status Bar</h3>

<p>Status Bar 用来展示通知信息和设备信息。下拉展示通知详情。</p>

<h3>Navigation Bar</h3>

<p>Navigation Bar 出现在4.0之后的版本，用来取代设备的物理按钮，同时提供菜单按钮以兼容2.3及以下的版本。<br/>
从目前市面上的设备来看，大多依然具备物理导航键如三星，有的就虚拟导航和物理按键相结合如魅族MX2。</p>

<h2>3. Notifications</h2>

<p>通知用于随时提醒用户一些简单而重要信息并且不会打断当前的用户操作。点击一个通知应该进入相关的应用。典型的通知布局包含一行标题和一行消息。需要的话也可以加入第三行。</p>

<p><img src="http://xuanxi.github.io/images/ui_overview_notifications.png" alt="ui_overview_notifications" /></p>

<p><img src="http://xuanxi.github.io/images/notifications_dismiss.png" alt="notifications_dismiss" /></p>

<h2>4. Common App UI</h2>

<p>一个典型的 Android 应用包含 Action Bar 和 Content Area 两部分。如果应用的结构较复杂，可以使用 Navigation Drawer 来切换主要页面。</p>

<p><img src="http://xuanxi.github.io/images/app_structure_drawer.png" alt="app_structure_drawer" /></p>

<h3>Action Bar</h3>

<p>Action Bar 用来承载与当前页面相关的主要操作，也可用于页面的切换。</p>

<h3>Navigation Drawer</h3>

<p>Navigation Drawer 的弹出不覆盖 Action Bar，展示方式与目前流行在iOS应用中的侧边栏有所不同。</p>

<h3>Content Area</h3>

<p>内容区域</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Objective-C和Swift]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/14/something-about-objective-c-and-swift/"/>
    <updated>2014-07-14T10:47:10+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/14/something-about-objective-c-and-swift</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Design Principles]]></title>
    <link href="http://xuanxi.github.io/blog/2014/07/13/android-design-principles/"/>
    <updated>2014-07-13T22:13:04+08:00</updated>
    <id>http://xuanxi.github.io/blog/2014/07/13/android-design-principles</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://developer.android.com/design/get-started/principles.html">http://developer.android.com/design/get-started/principles.html</a></p>

<p>推荐应用：<br/>
<a href="http://www.any.do/">Any.do</a></p>

<p>These design principles were developed by and for the Android User Experience Team to keep user&rsquo;s best interests in mind.For Android developers and designers,they continue to underline the more detailed design guidelines for different types of devices.<br/>
Consider these principles as you apply your own creativity and design thinking.Deviate with purpose.<br/>
以下设计准则由Android用户体验团队秉承用户利益至上的原则开发。当你发挥自己的创造力和思考的时候，请将它们纳入考虑之中，并有意识地加以实践。</p>

<!--more-->


<h2><em>Enchant ME</em></h2>

<p><em>迷住我</em></p>

<h3>Delight me in surprising ways</h3>

<p>以意想不到的方式取悦我</p>

<p>A beautiful surface,a carefully-places animation,or a well-timed sound effect is a joy to experience. Subtle effects contribute to a feeling of effortlessness and a sense that a powerful force is at hand.<br/>
一个漂亮的界面，一个悉心摆放的动画，或者一个适时的声音效果，都是一种快乐的体验。精细的效果能产生一种轻松的氛围，感觉手中有一股强大可控的力量。</p>

<p><img src="http://xuanxi.github.io/images/principles_delight.png" alt="principles_delight" /></p>

<h3>Real objects are more fun than buttons and menus</h3>

<p>真实对象比按钮和菜单更加有趣</p>

<p>Allow people to directly touch and manipulate objects in your app. It reduces the cognitive effort needed to perform a task while making it more emotionally satisfying.<br/>
允许人们直接触摸和操作你应用中的对象。它减少了执行一项任务所需的认识上的力量，并使之更加令人舒心。</p>

<p><img src="http://xuanxi.github.io/images/principles_real_objects.png" alt="principles_real_objects" /></p>

<h3>Let me make it mine</h3>

<p>让我把它变成我的</p>

<p>People love to add personal touches because it helps them feel at home and in control. Provide sensible, beautiful defaults, but also consider fun, optional customizations that don&rsquo;t hinder primary tasks.<br/>
人们喜欢加入个人手势，因为这让他们感觉自在与可控。提供可感的、漂亮的默认手势，但同时又考虑好玩、可选又不影响主要任务的定制项。</p>

<p><img src="http://xuanxi.github.io/images/principles_make_it_mine.png" alt="principles_make_it_mine" /></p>

<h3>Get to know me</h3>

<p>学会了解我</p>

<p>Learn peoples&#8217; preferences over time. Rather than asking them to make the same choices over and over, place previous choices within easy reach.<br/>
随着时间的推移，学习用户的偏好。不要反复地问用户同样的问题，将用户先前的选择列出来以供快捷选择。</p>

<p><img src="http://xuanxi.github.io/images/principles_get_to_know_me.png" alt="principles_get_to_know_me" /></p>

<h2><em>Simplify My Life</em></h2>

<p><em>简化我的生活</em></p>

<h3>Keep it brief</h3>

<p>用语简洁</p>

<p>Use short phrases with simple words. People are likely to skip sentences if they&rsquo;re long.<br/>
使用由简单词汇构成的短句。人们更倾向于跳过过长的句子。</p>

<p><img src="http://xuanxi.github.io/images/principles_keep_it_brief.png" alt="principles_keep_it_brief" /></p>

<h3>Pictures are faster than words</h3>

<p>图像比文字更能直达理解</p>

<p>Consider using pictures to explain ideas. They get people&rsquo;s attention and can be much more efficient than words.<br/>
考虑使用图像来解释观点。图像能捕获人们的注意力，往往比文字更有效率。</p>

<p><img src="http://xuanxi.github.io/images/principles_pictures.png" alt="principles_pictures" /></p>

<h3>Decide for me but let me have the final say</h3>

<p>为我决定，但最终由我说了算</p>

<p>Take your best guess and act rather than asking first. Too many choices and decisions make people unhappy. Just in case you get it wrong, allow for &lsquo;undo&rsquo;.<br/>
做最好的猜测，先做而非先问。太多的选择和决定会令人不愉。只当你可能会犯错时，才提供个‘撤消’，然后仍然先做后问。</p>

<p><img src="http://xuanxi.github.io/images/principles_decide_for_me.png" alt="principles_decide_for_me" /></p>

<h3>Only show what I need when I need it</h3>

<p>只在我需要的时候显示我所要的</p>

<p>People get overwhelmed when they see too much at once. Break tasks and information into small, digestible chunks. Hide options that aren&rsquo;t essential at the moment, and teach people as they go.<br/>
当一下子看到太多东西时，人们容易受打击。将任务和信息分解成小的、可消化的片段。隐藏当前非必须的选项，并指导人们如何走下去。</p>

<p><img src="http://xuanxi.github.io/images/principles_information_when_need_it.png" alt="principles_information_when_need_it" /></p>

<h3>I should always know where I am</h3>

<p>我应该总能知道我在哪里</p>

<p>Give people confidence that they know their way around. Make places in your app look distinct and use transitions to show relationships among screens. Provide feedback on tasks in progress.<br/>
给人们以清楚自己在哪的信心。把你应用中的不同场景设计得可区分，并使用变换效果来显示不同场景（窗口）之间的关系。提供任务进度反馈。</p>

<p><img src="http://xuanxi.github.io/images/principles_navigation.png" alt="principles_navigation" /></p>

<h3>Never lose my stuff</h3>

<p>决不能丢失我的东西</p>

<p>Save what people took time to create and let them access it from anywhere. Remember settings, personal touches, and creations across phones, tablets, and computers. It makes upgrading the easiest thing in the world.<br/>
保存用户花时间创建的东西，使得他们能随处访问。跨手机、平板电脑及计算机等平台，记住设置、个人手势以及作品。这将使得软件升级成为世界上最简单的事。</p>

<p><img src="http://xuanxi.github.io/images/principles_never_lose_stuff.png" alt="principles_never_lose_stuff" /></p>

<h3>If it looks the same, it should act the same</h3>

<p>如果看起来一样，所做的事就该一样</p>

<p>Help people discern functional differences by making them visually distinct rather than subtle. Avoid modes, which are places that look similar but act differently on the same input.<br/>
通过在视觉上加以区别，来帮助人们区分出功能的差异来。避免出现雷同场景，即看上去一样，但对于同一输入结果不同的场景。</p>

<p><img src="http://xuanxi.github.io/images/principles_looks_same.png" alt="principles_looks_same" /></p>

<h3>Only interrupt me if it&rsquo;s important</h3>

<p>只在十分重要时打断我</p>

<p>Like a good personal assistant, shield people from unimportant minutiae. People want to stay focused, and unless it&rsquo;s critical and time-sensitive, an interruption can be taxing and frustrating.<br/>
尤如一个好的个人助理，应该保护上司不被不重要的小事打扰。人们需要专注，除非情况十分严重并且紧急，打扰会是十分令人不悦的。</p>

<p><img src="http://xuanxi.github.io/images/principles_important_interruption.png" alt="principles_important_interruption" /></p>

<h2><em>Make Me Amazing</em></h2>

<p><em>让我惊讶</em></p>

<h3>Give me tricks that work everywhere</h3>

<p>给我点处处可行的诀窍</p>

<p>People feel great when they figure things out for themselves. Make your app easier to learn by leveraging visual patterns and muscle memory from other Android apps. For example, the swipe gesture may be a good navigational shortcut.<br/>
人们如果能够自己探索出东西来，将会兴奋不已。通过使用可视的模式和习惯操作，使你的应用更加易于学习。比如，猛击操作会是一个很好的导航快捷手势。</p>

<p><img src="http://xuanxi.github.io/images/principles_tricks.png" alt="principles_tricks" /></p>

<h3>It&rsquo;s not my fault</h3>

<p>这不是我的错</p>

<p>Be gentle in how you prompt people to make corrections. They want to feel smart when they use your app. If something goes wrong, give clear recovery instructions but spare them the technical details. If you can fix it behind the scenes, even better.<br/>
在提示用户改正错误时，应该礼貌。他们在用你应用的时候，需要被认为是聪明的。如果出错了，给出明确的恢复指令，而不是将技术细节留给他们。如果你可以在后台修复错误，那当然最好。</p>

<p><img src="http://xuanxi.github.io/images/principles_error.png" alt="principles_error" /></p>

<h3>Sprinkle encouragement</h3>

<p>挥洒鼓励</p>

<p>Break complex tasks into smaller steps that can be easily accomplished. Give feedback on actions, even if it&rsquo;s just a subtle glow.<br/>
将复杂的任务分解成小的容易被完成的步骤。对用户的操作给出反馈，即使只是一小步的成功。</p>

<p><img src="http://xuanxi.github.io/images/principles_sprinkle_encouragement.png" alt="principles_sprinkle_encouragement" /></p>

<h3>Do the heavy lifting for me</h3>

<p>为我担负重任</p>

<p>Make novices feel like experts by enabling them to do things they never thought they could. For example, shortcuts that combine multiple photo effects can make amateur photographs look amazing in only a few steps.<br/>
通过使他们做成他们认为自己不可能做到的事，让新手感觉自己像专家一样。比如，综合多个照片效果的快捷操作可使得外行简单几步做出惊人的照片效果来。</p>

<p><img src="http://xuanxi.github.io/images/principles_heavy_lifting.png" alt="principles_heavy_lifting" /></p>

<h3>Make important things fast</h3>

<p>让重要的事情能更快地完成</p>

<p>Not all actions are equal. Decide what&rsquo;s most important in your app and make it easy to find and fast to use, like the shutter button in a camera, or the pause button in a music player.<br/>
并非所有的操作都是平等的。确定你应用中最重要的操作，使它能很容易地被发现与使用，比如相机上的快门，又如音乐播放器上的暂停按钮。</p>

<p><img src="http://xuanxi.github.io/images/principles_make_important_fast.png" alt="principles_make_important_fast" /></p>
]]></content>
  </entry>
  
</feed>
